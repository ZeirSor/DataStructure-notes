<!DOCTYPE html>
<html>
<head>
<title>Notes_DataStructure.md</title>
<meta http-equiv="Content-type" content="text/html;charset=UTF-8">

<style>
/* https://github.com/microsoft/vscode/blob/master/extensions/markdown-language-features/media/markdown.css */
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

body {
	font-family: var(--vscode-markdown-font-family, -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif);
	font-size: var(--vscode-markdown-font-size, 14px);
	padding: 0 26px;
	line-height: var(--vscode-markdown-line-height, 22px);
	word-wrap: break-word;
}

#code-csp-warning {
	position: fixed;
	top: 0;
	right: 0;
	color: white;
	margin: 16px;
	text-align: center;
	font-size: 12px;
	font-family: sans-serif;
	background-color:#444444;
	cursor: pointer;
	padding: 6px;
	box-shadow: 1px 1px 1px rgba(0,0,0,.25);
}

#code-csp-warning:hover {
	text-decoration: none;
	background-color:#007acc;
	box-shadow: 2px 2px 2px rgba(0,0,0,.25);
}

body.scrollBeyondLastLine {
	margin-bottom: calc(100vh - 22px);
}

body.showEditorSelection .code-line {
	position: relative;
}

body.showEditorSelection .code-active-line:before,
body.showEditorSelection .code-line:hover:before {
	content: "";
	display: block;
	position: absolute;
	top: 0;
	left: -12px;
	height: 100%;
}

body.showEditorSelection li.code-active-line:before,
body.showEditorSelection li.code-line:hover:before {
	left: -30px;
}

.vscode-light.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(0, 0, 0, 0.15);
}

.vscode-light.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(0, 0, 0, 0.40);
}

.vscode-light.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-dark.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 255, 255, 0.4);
}

.vscode-dark.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 255, 255, 0.60);
}

.vscode-dark.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-high-contrast.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 160, 0, 0.7);
}

.vscode-high-contrast.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 160, 0, 1);
}

.vscode-high-contrast.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

img {
	max-width: 100%;
	max-height: 100%;
}

a {
	text-decoration: none;
}

a:hover {
	text-decoration: underline;
}

a:focus,
input:focus,
select:focus,
textarea:focus {
	outline: 1px solid -webkit-focus-ring-color;
	outline-offset: -1px;
}

hr {
	border: 0;
	height: 2px;
	border-bottom: 2px solid;
}

h1 {
	padding-bottom: 0.3em;
	line-height: 1.2;
	border-bottom-width: 1px;
	border-bottom-style: solid;
}

h1, h2, h3 {
	font-weight: normal;
}

table {
	border-collapse: collapse;
}

table > thead > tr > th {
	text-align: left;
	border-bottom: 1px solid;
}

table > thead > tr > th,
table > thead > tr > td,
table > tbody > tr > th,
table > tbody > tr > td {
	padding: 5px 10px;
}

table > tbody > tr + tr > td {
	border-top: 1px solid;
}

blockquote {
	margin: 0 7px 0 5px;
	padding: 0 16px 0 10px;
	border-left-width: 5px;
	border-left-style: solid;
}

code {
	font-family: Menlo, Monaco, Consolas, "Droid Sans Mono", "Courier New", monospace, "Droid Sans Fallback";
	font-size: 1em;
	line-height: 1.357em;
}

body.wordWrap pre {
	white-space: pre-wrap;
}

pre:not(.hljs),
pre.hljs code > div {
	padding: 16px;
	border-radius: 3px;
	overflow: auto;
}

pre code {
	color: var(--vscode-editor-foreground);
	tab-size: 4;
}

/** Theming */

.vscode-light pre {
	background-color: rgba(220, 220, 220, 0.4);
}

.vscode-dark pre {
	background-color: rgba(10, 10, 10, 0.4);
}

.vscode-high-contrast pre {
	background-color: rgb(0, 0, 0);
}

.vscode-high-contrast h1 {
	border-color: rgb(0, 0, 0);
}

.vscode-light table > thead > tr > th {
	border-color: rgba(0, 0, 0, 0.69);
}

.vscode-dark table > thead > tr > th {
	border-color: rgba(255, 255, 255, 0.69);
}

.vscode-light h1,
.vscode-light hr,
.vscode-light table > tbody > tr + tr > td {
	border-color: rgba(0, 0, 0, 0.18);
}

.vscode-dark h1,
.vscode-dark hr,
.vscode-dark table > tbody > tr + tr > td {
	border-color: rgba(255, 255, 255, 0.18);
}

</style>

<style>
/* Tomorrow Theme */
/* http://jmblog.github.com/color-themes-for-google-code-highlightjs */
/* Original theme - https://github.com/chriskempson/tomorrow-theme */

/* Tomorrow Comment */
.hljs-comment,
.hljs-quote {
	color: #8e908c;
}

/* Tomorrow Red */
.hljs-variable,
.hljs-template-variable,
.hljs-tag,
.hljs-name,
.hljs-selector-id,
.hljs-selector-class,
.hljs-regexp,
.hljs-deletion {
	color: #c82829;
}

/* Tomorrow Orange */
.hljs-number,
.hljs-built_in,
.hljs-builtin-name,
.hljs-literal,
.hljs-type,
.hljs-params,
.hljs-meta,
.hljs-link {
	color: #f5871f;
}

/* Tomorrow Yellow */
.hljs-attribute {
	color: #eab700;
}

/* Tomorrow Green */
.hljs-string,
.hljs-symbol,
.hljs-bullet,
.hljs-addition {
	color: #718c00;
}

/* Tomorrow Blue */
.hljs-title,
.hljs-section {
	color: #4271ae;
}

/* Tomorrow Purple */
.hljs-keyword,
.hljs-selector-tag {
	color: #8959a8;
}

.hljs {
	display: block;
	overflow-x: auto;
	color: #4d4d4c;
	padding: 0.5em;
}

.hljs-emphasis {
	font-style: italic;
}

.hljs-strong {
	font-weight: bold;
}
</style>

<style>
/*
 * Markdown PDF CSS
 */

 body {
	font-family: -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif, "Meiryo";
	padding: 0 12px;
}

pre {
	background-color: #f8f8f8;
	border: 1px solid #cccccc;
	border-radius: 3px;
	overflow-x: auto;
	white-space: pre-wrap;
	overflow-wrap: break-word;
}

pre:not(.hljs) {
	padding: 23px;
	line-height: 19px;
}

blockquote {
	background: rgba(127, 127, 127, 0.1);
	border-color: rgba(0, 122, 204, 0.5);
}

.emoji {
	height: 1.4em;
}

code {
	font-size: 14px;
	line-height: 19px;
}

/* for inline code */
:not(pre):not(.hljs) > code {
	color: #C9AE75; /* Change the old color so it seems less like an error */
	font-size: inherit;
}

/* Page Break : use <div class="page"/> to insert page break
-------------------------------------------------------- */
.page {
	page-break-after: always;
}

</style>

<script src="https://unpkg.com/mermaid/dist/mermaid.min.js"></script>
</head>
<body>
  <script>
    mermaid.initialize({
      startOnLoad: true,
      theme: document.body.classList.contains('vscode-dark') || document.body.classList.contains('vscode-high-contrast')
          ? 'dark'
          : 'default'
    });
  </script>
<!-- vscode-markdown-toc -->
<ul>
<li>
<ol>
<li><a href="#1."> 1. 绪论</a></li>
</ol>
<ul>
<li>1.1. <a href="#"> 基本概念与术语</a></li>
<li>1.2. <a href="#-1">数据结构</a></li>
<li>1.3. <a href="#AbstractDataTypeADP">抽象数据类型 Abstract Data Type（ADP）</a></li>
<li>1.4. <a href="#Algorithm">算法 Algorithm ：解决特定问题求解步骤的描述</a>
<ul>
<li>1.4.1. <a href="#-1">算法特性</a></li>
<li>1.4.2. <a href="#-1">算法设计的要求</a></li>
<li>1.4.3. <a href="#-1">算法效率的度量方法</a></li>
<li>1.4.4. <a href="#-1">函数渐进增长性：对比不同算法的优劣</a></li>
<li>1.4.5. <a href="#-1">复杂度</a></li>
<li>1.4.6. <a href="#-1">算法的分析</a></li>
</ul>
</li>
</ul>
</li>
<li>
<ol start="2">
<li><a href="#-1">线性表</a></li>
</ol>
<ul>
<li>2.1. <a href="#-1">顺序表的顺序存储</a>
<ul>
<li>2.1.1. <a href="#-1">补充：操作算法中用到的预定义常量和类型</a></li>
<li>2.1.2. <a href="#-1">线性表顺序存储的结构代码</a></li>
<li>2.1.3. <a href="#-1">顺序表基本操作的实现</a></li>
</ul>
</li>
<li>2.2. <a href="#-1">顺序表的链式存储（链表）</a>
<ul>
<li>2.2.1. <a href="#-1">单链表</a></li>
<li>2.2.2. <a href="#-1">单向循坏链表</a></li>
<li>2.2.3. <a href="#-1">双向循环链表</a></li>
</ul>
</li>
</ul>
</li>
<li>
<ol start="3">
<li><a href="#-1">栈与队列</a></li>
</ol>
<ul>
<li>3.1. <a href="#stackLastInFirstOut">栈(stack)Last In First Out</a>
<ul>
<li>3.1.1. <a href="#-1">栈的顺序存储</a></li>
<li>3.1.2. <a href="#-1">栈的链式存取</a></li>
</ul>
</li>
<li>3.2. <a href="#QueueFirstInFirstOut">队列(Queue)First In First Out</a>
<ul>
<li>3.2.1. <a href="#-1">链队列</a></li>
<li>3.2.2. <a href="#-1">顺序队列/循环队列</a></li>
</ul>
</li>
</ul>
</li>
<li>
<ol start="4">
<li><a href="#-1">串、数组与广义表</a></li>
</ol>
</li>
<li>
<ol start="5">
<li><a href="#-1">树和二叉树</a></li>
</ol>
<ul>
<li>5.1. <a href="#-1">一些基本概念</a></li>
<li>5.2. <a href="#-1">二叉树</a>
<ul>
<li>5.2.1. <a href="#-1">二叉树的性质</a></li>
<li>5.2.2. <a href="#-1">二叉树的存储结构</a></li>
<li>5.2.3. <a href="#-1">二叉树的遍历（递归算法）</a></li>
<li>5.2.4. <a href="#-1">二叉树的遍历（非递归算法）</a></li>
<li>5.2.5. <a href="#-1">二叉树的建立</a></li>
<li>5.2.6. <a href="#-1">求最大结点</a></li>
<li>5.2.7. <a href="#-1">查找指定结点</a></li>
<li>5.2.8. <a href="#-1">二叉树的销毁</a></li>
<li>5.2.9. <a href="#-1">各种数量</a></li>
</ul>
</li>
<li>5.3. <a href="#Tree">树与森林（Tree）</a>
<ul>
<li>5.3.1. <a href="#-1">树的存储结构</a></li>
<li>5.3.2. <a href="#-1">树的创建</a></li>
<li>5.3.3. <a href="#-1">树和二叉树的转换</a></li>
<li>5.3.4. <a href="#-1">树的基本操作</a></li>
</ul>
</li>
</ul>
</li>
<li>
<ol start="6">
<li><a href="#-1">图</a></li>
</ol>
<ul>
<li>6.1. <a href="#-1">图的一些基本概念与术语</a></li>
<li>6.2. <a href="#-1">图的存储结构</a>
<ul>
<li>6.2.1. <a href="#AdjacencyMatrix">邻接矩阵存储 <strong>Adjacency Matrix</strong></a></li>
<li>6.2.2. <a href="#AdjacencycList">邻接表存储 <strong>Adjacencyc List</strong></a></li>
<li>6.2.3. <a href="#-1">十字链表</a></li>
<li>6.2.4. <a href="#-1">邻接多重表</a></li>
<li>6.2.5. <a href="#-1">边集数组</a></li>
</ul>
</li>
<li>6.3. <a href="#TraversingGraph">图的遍历 Traversing Graph</a>
<ul>
<li>6.3.1. <a href="#Depth-FirstSearchDFS">深度优先搜索(Depth-First Search, DFS)</a></li>
<li>6.3.2. <a href="#Breadth-FirstSearchBFS">广度优先搜索(Breadth-First Search, BFS)</a></li>
</ul>
</li>
<li>6.4. <a href="#MinimumCostSpanningTree">最小生成树 Minimum Cost Spanning Tree</a>
<ul>
<li>6.4.1. <a href="#PrimsAlgorithm">普里姆算法 Prim's Algorithm</a></li>
<li>6.4.2. <a href="#KruskalsAlgorithm">克鲁斯卡尔算法 Kruskal's Algorithm</a></li>
</ul>
</li>
<li>6.5. <a href="#-1">最短路径</a>
<ul>
<li>6.5.1. <a href="#DijkstrasAlgorithm">迪杰斯特拉算法 Dijkstra's Algorithm</a></li>
<li>6.5.2. <a href="#FloydWarshallAlgorithm">弗洛伊德算法 Floyd–Warshall Algorithm</a></li>
</ul>
</li>
<li>6.6. <a href="#-1">拓扑排序</a>
<ul>
<li>6.6.1. <a href="#-1">基本概念</a></li>
<li>6.6.2. <a href="#-1">拓扑排序算法</a></li>
</ul>
</li>
<li>6.7. <a href="#-1">关键路径</a>
<ul>
<li>6.7.1. <a href="#-1">基本概念</a></li>
<li>6.7.2. <a href="#-1">关键路径的算法</a></li>
</ul>
</li>
</ul>
</li>
<li>
<ol start="7">
<li><a href="#-1">查找</a></li>
</ol>
<ul>
<li>7.1. <a href="#-1">基本概念</a>
<ul>
<li>7.1.1. <a href="#SearchTable">查找表 Search Table</a></li>
<li>7.1.2. <a href="#Key">关键字 Key</a></li>
<li>7.1.3. <a href="#SecondaryKey">次关键字 Secondary Key</a></li>
<li>7.1.4. <a href="#StaticSearchTable">静态查找表 Static Search Table</a></li>
<li>7.1.5. <a href="#DynamicSearchTable">动态查找表 Dynamic Search Table</a></li>
<li>7.1.6. <a href="#ASL">平均查找长度ASL</a></li>
</ul>
</li>
<li>7.2. <a href="#-1">顺序表查找</a>
<ul>
<li>7.2.1. <a href="#-1">普通法</a></li>
<li>7.2.2. <a href="#sentry">优化法(设置哨兵)sentry</a></li>
</ul>
</li>
<li>7.3. <a href="#-1">有序表查找</a>
<ul>
<li>7.3.1. <a href="#-1">折半查找(二分查找)</a></li>
<li>7.3.2. <a href="#-1">插值查找</a></li>
<li>7.3.3. <a href="#-1">斐波那契查找</a></li>
</ul>
</li>
<li>7.4. <a href="#-1">索引查找</a>
<ul>
<li>7.4.1. <a href="#-1">稠密索引</a></li>
<li>7.4.2. <a href="#-1">分块索引</a></li>
<li>7.4.3. <a href="#-1">倒排索引</a></li>
</ul>
</li>
<li>7.5. <a href="#BSTBinarySortTree">二叉排序树 BST(Binary Sort Tree)</a></li>
<li>7.6. <a href="#ALV">平衡二叉树 ALV树</a>
<ul>
<li>7.6.1. <a href="#-1">二叉平衡树的实现原理</a></li>
</ul>
</li>
<li>7.7. <a href="#B">多路查找树(B树)</a>
<ul>
<li>7.7.1. <a href="#-1">2-3树</a></li>
<li>7.7.2. <a href="#-1">2-3-4树</a></li>
<li>7.7.3. <a href="#B-1">B树</a></li>
<li>7.7.4. <a href="#B-1">B+树</a></li>
</ul>
</li>
<li>7.8. <a href="#-1">哈希表(散列表)查找)</a>
<ul>
<li>7.8.1. <a href="#-1">散列函数的构造方法</a></li>
<li>7.8.2. <a href="#-1">处理散列冲突的方法</a></li>
</ul>
</li>
</ul>
</li>
<li>
<ol start="8">
<li><a href="#-1">排序</a></li>
</ol>
</li>
<li>
<ol start="9">
<li><a href="#or">实验or应用</a></li>
</ol>
<ul>
<li>9.1. <a href="#-1">线性表</a>
<ul>
<li>9.1.1. <a href="#-1">简单的学生成绩管理</a></li>
<li>9.1.2. <a href="#-1">图书信息管理</a></li>
<li>9.1.3. <a href="#-1">党史学习</a></li>
<li>9.1.4. <a href="#-1">学习强国</a></li>
<li>9.1.5. <a href="#-1">集合及其运算</a></li>
<li>9.1.6. <a href="#-1">双向循环链表实验</a></li>
</ul>
</li>
<li>9.2. <a href="#-1">栈的应用</a>
<ul>
<li>9.2.1. <a href="#-1">进制转换</a></li>
<li>9.2.2. <a href="#-1">括号匹配</a></li>
<li>9.2.3. <a href="#-1">回文判断</a></li>
<li>9.2.4. <a href="#-1">表达式求值</a></li>
</ul>
</li>
<li>9.3. <a href="#-1">队列的应用</a>
<ul>
<li>9.3.1. <a href="#-1">舞伴问题</a></li>
<li>9.3.2. <a href="#-1">排队模拟问题</a></li>
<li>9.3.3. <a href="#-1">求二项式系数</a></li>
<li>9.3.4. <a href="#-1">无冲突子集的划分</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<!-- vscode-markdown-toc-config
	numbering=true
	autoSave=true
	/vscode-markdown-toc-config -->
<!-- /vscode-markdown-toc -->
<h1 id="data-structure-notes">DATA STRUCTURE NOTES</h1>
<p>[toc]</p>
<h2 id="1-a-name1a-1-%E7%BB%AA%E8%AE%BA">1. <a name='1.'></a> 1. 绪论</h2>
<pre><code>	程序 = 算法 + 数据结构
    数据结构 = 数据对象 + 结构
</code></pre>
<h3 id="11-a-namea-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E4%B8%8E%E6%9C%AF%E8%AF%AD">1.1. <a name=''></a> 基本概念与术语</h3>
<pre><code class="language-mermaid"><div class="mermaid">	graph TB
	基本概念与术语---数据
	基本概念与术语---数据对象 --- 集合
	数据对象 --- 同性质数据
	基本概念与术语---数据元素---单位
	基本概念与术语---数据项---原子项
	数据项---组合项
	基本概念与术语---数据结构---相互存在某种逻辑关系的数据元素的集合
</div></code></pre>
<h3 id="12-a-name-1a%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84">1.2. <a name='-1'></a>数据结构</h3>
<pre><code class="language-mermaid"><div class="mermaid">	graph TB
	数据结构---逻辑结构---线性	
	逻辑结构---集合
	逻辑结构---树形
	逻辑结构---图形
	数据结构---存储结构---顺序
	存储结构---链式
	存储结构---索引
	存储结构---哈希
	数据结构----在数据对象上的操作

</div></code></pre>
<h3 id="13-a-nameabstractdatatypeadpa%E6%8A%BD%E8%B1%A1%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B-abstract-data-typeadp">1.3. <a name='AbstractDataTypeADP'></a>抽象数据类型 Abstract Data Type（ADP）</h3>
<ul>
<li>数据类型
<ul>
<li>原子类型</li>
<li>结构类型</li>
</ul>
</li>
<li>ADP：一个数学模型以及定义在该模型上的一组操作。
<ul>
<li>体现了程序设计的<strong>问题分解</strong>、<strong>抽象</strong>和<strong>信息隐藏</strong></li>
<li><strong>描述</strong></li>
<li>
<pre><code>ADP 抽象数据类型名
Data
    数据元素之间逻辑关系的定义
Operation
    操作1
        初始条件
        操作结果描述
    操作2
        初始条件
        操作结果描述
    操作3
        初始条件
        操作结果描述
    ···
    操作n
        初始条件
        操作结果描述
end ADP
</code></pre>
</li>
</ul>
</li>
</ul>
<h3 id="14-a-namealgorithma%E7%AE%97%E6%B3%95-algorithm-%E8%A7%A3%E5%86%B3%E7%89%B9%E5%AE%9A%E9%97%AE%E9%A2%98%E6%B1%82%E8%A7%A3%E6%AD%A5%E9%AA%A4%E7%9A%84%E6%8F%8F%E8%BF%B0">1.4. <a name='Algorithm'></a>算法 Algorithm ：解决特定问题求解步骤的描述</h3>
<h4 id="141-a-name-1a%E7%AE%97%E6%B3%95%E7%89%B9%E6%80%A7">1.4.1. <a name='-1'></a>算法特性</h4>
<pre><code class="language-mermaid"><div class="mermaid">	graph TB
	输入
	输出
	有穷性
	确定性//无二义
	可行性//有限时间

</div></code></pre>
<h4 id="142-a-name-1a%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E7%9A%84%E8%A6%81%E6%B1%82">1.4.2. <a name='-1'></a>算法设计的要求</h4>
<ul>
<li>正确性</li>
<li>可读性</li>
<li>健壮性</li>
<li>时间效率高、存储量低</li>
</ul>
<h4 id="143-a-name-1a%E7%AE%97%E6%B3%95%E6%95%88%E7%8E%87%E7%9A%84%E5%BA%A6%E9%87%8F%E6%96%B9%E6%B3%95">1.4.3. <a name='-1'></a>算法效率的度量方法</h4>
<ul>
<li>事后统计（不科学、不准确）</li>
<li>事前分析估算</li>
</ul>
<h4 id="144-a-name-1a%E5%87%BD%E6%95%B0%E6%B8%90%E8%BF%9B%E5%A2%9E%E9%95%BF%E6%80%A7%E5%AF%B9%E6%AF%94%E4%B8%8D%E5%90%8C%E7%AE%97%E6%B3%95%E7%9A%84%E4%BC%98%E5%8A%A3">1.4.4. <a name='-1'></a>函数渐进增长性：对比不同算法的优劣</h4>
<h4 id="145-a-name-1a%E5%A4%8D%E6%9D%82%E5%BA%A6">1.4.5. <a name='-1'></a>复杂度</h4>
<h5 id="%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6tn--o-f-n">时间复杂度：T（n） = O（ f（ n ））</h5>
<pre><code>    T（n）：执行次数
    看数量级
    看增长率
    越小越优
</code></pre>
<h6 id="%E5%88%86%E7%B1%BB">分类</h6>
<ul>
<li>常数阶：    O（1）</li>
<li>线性阶：    O（n）</li>
<li>平方阶：    O（n^2^）</li>
<li>对数阶：    O（logn）</li>
<li>nlogn阶：   O（nlogn）</li>
<li>立方阶：    O（n^3^）</li>
<li>指数阶：    O（2^n^）</li>
<li>······</li>
</ul>
<h6 id="%E6%8E%A8%E5%AF%BC%E5%A4%A7o%E9%98%B6">推导大O阶</h6>
<ul>
<li>
<p>用“1”取代加法常数</p>
</li>
<li>
<p>只保留最高阶项</p>
</li>
<li>
<p>最高阶项系数改为1</p>
<p>注：O(1) &lt; O(logn) &lt; O(n) &lt; O(nlogn) &lt; (n^2^) &lt; O(n^3^) &lt; O(2^n^) &lt; O(n!) &lt; O(n^n^)</p>
</li>
</ul>
<h5 id="%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6sn--o-f-n--%E6%89%80%E9%9C%80%E5%AD%98%E5%82%A8%E7%A9%BA%E9%97%B4">空间复杂度：S（n） = O（ f（ n ）） 所需存储空间</h5>
<pre><code>注：“复杂度”一般指时间复杂度
</code></pre>
<h4 id="146-a-name-1a%E7%AE%97%E6%B3%95%E7%9A%84%E5%88%86%E6%9E%90">1.4.6. <a name='-1'></a>算法的分析</h4>
<ul>
<li>平均情况：期望的运行时间，计算平均时间复杂度。</li>
<li>最坏情况：计算最坏时间复杂度，是一种保证，一般时间复杂度指最坏情况。</li>
</ul>
<h2 id="2-a-name-1a%E7%BA%BF%E6%80%A7%E8%A1%A8">2. <a name='-1'></a>线性表</h2>
<h3 id="21-a-name-1a%E9%A1%BA%E5%BA%8F%E8%A1%A8%E7%9A%84%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8">2.1. <a name='-1'></a>顺序表的顺序存储</h3>
<h4 id="211-a-name-1a%E8%A1%A5%E5%85%85%E6%93%8D%E4%BD%9C%E7%AE%97%E6%B3%95%E4%B8%AD%E7%94%A8%E5%88%B0%E7%9A%84%E9%A2%84%E5%AE%9A%E4%B9%89%E5%B8%B8%E9%87%8F%E5%92%8C%E7%B1%BB%E5%9E%8B">2.1.1. <a name='-1'></a>补充：操作算法中用到的预定义常量和类型</h4>
<ul>
<li>函数结果状态代码</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> TRUE         1</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> FALSE        0</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> OK           1</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ERROR        0</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> INFEASIBLE  -1</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> OVERFLOW    -2</span>
</div></code></pre>
<ul>
<li>Status是函数的类型，其值是函数结果状态代码</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">int</span> Status;
<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">char</span> Elemtype;
</div></code></pre>
<h4 id="212-a-name-1a%E7%BA%BF%E6%80%A7%E8%A1%A8%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E7%9A%84%E7%BB%93%E6%9E%84%E4%BB%A3%E7%A0%81">2.1.2. <a name='-1'></a>线性表顺序存储的结构代码</h4>
<pre class="hljs"><code><div><span class="hljs-comment">//顺序存储结构代码		创建线性表</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MAXSIZE 20				<span class="hljs-comment">/*存储空间初始分配量*/</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> OK 1</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ERROR 0</span>

<span class="hljs-comment">//线性表的动态分配存储结构</span>
<span class="hljs-meta"># <span class="hljs-meta-keyword">define</span> ListInitSize 100		<span class="hljs-comment">/*存储空间初始分配量*/</span></span>
<span class="hljs-meta"># <span class="hljs-meta-keyword">define</span> ListIncrement 10		<span class="hljs-comment">/*存储空间分配增量*/</span></span>
<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">int</span> Status;
<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">int</span> Elemtype;
Elemtype *newbase;				<span class="hljs-comment">//重新分配存储空间</span>

<span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span>
{</span>	
	Elemtype *data;				<span class="hljs-comment">/*储存数据元素  这里使用指针方便后边进行动态分配	储存空间基址*/</span>
	<span class="hljs-keyword">int</span> length;					<span class="hljs-comment">/*当前线性表的长度	线性表长度&lt;=数组长度*/</span>
	<span class="hljs-keyword">int</span> listsize;				<span class="hljs-comment">//当前分配的存储容量 第三个属性根据需要，可有可无</span>
}SqList;
</div></code></pre>
<pre><code>注：status是一种函数类型，当函数返回值为函数结果状态代码时，函数定义为Status类型。
    函数结果状态码：	
                    TRUE        1、FALSE    0
                    OK          1、ERROR    0
	                INFEASIBLE -1、OVERFLOW -2
</code></pre>
<h4 id="213-a-name-1a%E9%A1%BA%E5%BA%8F%E8%A1%A8%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%E7%9A%84%E5%AE%9E%E7%8E%B0">2.1.3. <a name='-1'></a>顺序表基本操作的实现</h4>
<h5 id="initlistl">InitList(&amp;L)</h5>
<pre><code>初始化操作，建立一个空的线性表L
</code></pre>
<ul>
<li>C</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-function">Status <span class="hljs-title">InitList</span><span class="hljs-params">(SqList* L)</span>			<span class="hljs-comment">//构造一个空的线性表</span>
</span>{
	<span class="hljs-comment">//动态分配</span>
	L-&gt;data = (Elemtype *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(Elemtype) * ListInitSize )
	
	<span class="hljs-keyword">if</span> (!L-&gt;data);      <span class="hljs-comment">//存储分配失败退出</span>
		exti(ERROR);

	L-&gt;length = <span class="hljs-number">0</span>;      <span class="hljs-comment">//空表长度为0</span>
	L-&gt;listsize = ListInitSize;
	<span class="hljs-keyword">return</span> OK;
}
</div></code></pre>
<ul>
<li>C++</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-function">Status <span class="hljs-title">InitList</span><span class="hljs-params">(SqList* L)</span>			<span class="hljs-comment">//构造一个空的线性表</span>
</span>{
	<span class="hljs-comment">//动态分配</span>
	L-&gt;data = <span class="hljs-keyword">new</span> Elemtype(ListInitSize);
	
	<span class="hljs-keyword">if</span> (!L-&gt;data);      <span class="hljs-comment">//存储分配失败退出</span>
		exti(ERROR);

	L-&gt;length = <span class="hljs-number">0</span>;      <span class="hljs-comment">//空表长度为0</span>
	L-&gt;listsize = ListInitSize;
	<span class="hljs-keyword">return</span> OK;
}
</div></code></pre>
<h5 id="destroylistl">DestroyList(&amp;L)</h5>
<pre><code>销毁已存在的线性表L
</code></pre>
<ul>
<li>C</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">DestroyList</span><span class="hljs-params">(SqList *L)</span>
</span>{
    <span class="hljs-keyword">if</span>(L-&gt;data)  <span class="hljs-built_in">free</span>(L-&gt;data);  <span class="hljs-comment">//释放存储空间</span>
}
</div></code></pre>
<ul>
<li>C++</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">DestroyList</span><span class="hljs-params">(SqList &amp;L)</span>
</span>{
    <span class="hljs-keyword">if</span>(L.data)  <span class="hljs-keyword">delete</span>[] L.data;  <span class="hljs-comment">//释放存储空间</span>
}
</div></code></pre>
<pre><code>注：如果动态分配了一个数组，但是却用delete p的方式释放，没有用[]，则编译时没有问题，运行时也一般不会发生错误，但实际上会导致动态分配的数组没有被完全释放。
</code></pre>
<h5 id="clearlistl">ClearList(&amp;L)</h5>
<pre><code>将线性表清空
</code></pre>
<ul>
<li>C++</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">ClearList</span><span class="hljs-params">(SqList &amp;L)</span>
</span>{
    L-&gt;length = <span class="hljs-number">0</span>;          <span class="hljs-comment">//将线性表的长度置为零</span>
}
</div></code></pre>
<pre><code>注：其实这只是形式上的清空，让计算机识别不了而已，真正的线性表在内存中还存在。
</code></pre>
<h5 id="listlnsertl-i-e">Listlnsert(&amp;L, i, e)</h5>
<pre><code>在线性表L中第i个位置插入新元素e
</code></pre>
<ul>
<li>C</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-function">Status <span class="hljs-title">ListInsert</span><span class="hljs-params">(SqList* L, <span class="hljs-keyword">int</span> i, Elemtype e)</span>			<span class="hljs-comment">//在第i个位置插入新元素e</span>
</span>{
	<span class="hljs-comment">//初始条件      i的位置要合理同时线性表要有空间可以插入新元素</span>
	<span class="hljs-keyword">int</span> k;
	<span class="hljs-keyword">if</span> (L-&gt;length == MAXSIZE)
		<span class="hljs-keyword">return</span> ERROR;
	<span class="hljs-keyword">if</span> (i &lt; <span class="hljs-number">1</span> || i &gt; L-&gt;length + <span class="hljs-number">1</span>)
		<span class="hljs-keyword">return</span> ERROR;
	<span class="hljs-keyword">if</span> (L-&gt;length &gt;= L-&gt;listsize)		<span class="hljs-comment">//存储空间已满，需要重新分配</span>
	{
		newbase = (Elemtype*)<span class="hljs-built_in">realloc</span>(L-&gt;data, (L-&gt;listsize + ListInitSize) * <span class="hljs-keyword">sizeof</span>(Elemtype))
			<span class="hljs-keyword">if</span> (!newbase)
				<span class="hljs-built_in">exit</span>(EOVERFLOW);
		L-&gt;data = newbase;
		L-&gt;listsize += ListIncrement;
	}

	<span class="hljs-comment">//操作结果</span>
	<span class="hljs-keyword">if</span> (i &lt;= L-&gt;length)
	{

		<span class="hljs-keyword">for</span> (k = L-&gt;length - <span class="hljs-number">1</span>; k &gt;= i - <span class="hljs-number">1</span>; k--)
			L-&gt;data[k + <span class="hljs-number">1</span>] = L-&gt;data[k];
	}
	L-&gt;data[i<span class="hljs-number">-1</span>] = e;
	L-&gt;length++;

	<span class="hljs-keyword">return</span> OK;

}


L.date[length] = e;
L.length++;

e = L.data[length];
L.length--;
</div></code></pre>
<ul>
<li>C++</li>
</ul>
<pre class="hljs"><code><div>
</div></code></pre>
<h5 id="listdeletel-i-e">ListDelete(&amp;L, i, &amp;e)</h5>
<pre><code>删除线性表L中第i个位置元素，用e返回
</code></pre>
<ul>
<li>C</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-function">Status <span class="hljs-title">ListDelete</span><span class="hljs-params">(SqList* L, <span class="hljs-keyword">int</span> i, Elemtype* e)</span>
</span>{
	<span class="hljs-comment">//初始条件</span>
	<span class="hljs-keyword">int</span> k;
	<span class="hljs-keyword">if</span> (i&lt;<span class="hljs-number">1</span> || i&gt;L-&gt;length)			<span class="hljs-comment">//删除的位置不合理</span>
		<span class="hljs-keyword">return</span> ERROR;
	<span class="hljs-keyword">if</span> (L-&gt;length == <span class="hljs-number">0</span>)				<span class="hljs-comment">//线性表没有元素可以删除</span>
		<span class="hljs-keyword">return</span> ERROR;

	<span class="hljs-comment">//操作结果</span>
	*e = L-&gt;data[i - <span class="hljs-number">1</span>];

	<span class="hljs-keyword">if</span> (i &lt; L-&gt;length)
	{
		<span class="hljs-keyword">for</span> (k = i; k &lt; L-&gt;length; k++)
			L-&gt;data[k - <span class="hljs-number">1</span>] = L-&gt;data[k];
	}
	L-&gt;length--;
	<span class="hljs-keyword">return</span> OK;

}
</div></code></pre>
<ul>
<li>C++</li>
</ul>
<pre class="hljs"><code><div></div></code></pre>
<h5 id="lsemptyl">lsEmpty(L)</h5>
<pre><code>若线性表为空，返回true，否则false
</code></pre>
<ul>
<li>C</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">IsEmpty</span><span class="hljs-params">(SqList *L)</span>
</span>{
    <span class="hljs-keyword">if</span>(L-&gt;length == <span class="hljs-number">0</span>)
        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</div></code></pre>
<ul>
<li>C++</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">IsEmpty</span><span class="hljs-params">(SqList &amp;L)</span>
</span>{
    <span class="hljs-keyword">if</span>(L-&gt;length == <span class="hljs-number">0</span>)
        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</div></code></pre>
<h5 id="listlengthl">ListLength(L)</h5>
<pre><code>返回线性表L的元素个数
</code></pre>
<ul>
<li>C</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">ListLength</span><span class="hljs-params">(SqList *L)</span>
</span>{
    <span class="hljs-keyword">return</span> L-&gt;length;
}
</div></code></pre>
<ul>
<li>C++</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">ListLength</span><span class="hljs-params">(SqList &amp;L)</span>
</span>{
    <span class="hljs-keyword">return</span> L-&gt;length;
}
</div></code></pre>
<h5 id="locateeleml-e">LocateElem(L, e)</h5>
<pre><code>L中查找与给定值e相等的元素，若成功返回该元素在表中的序号，否则返回0
</code></pre>
<center>顺序查找 O（n） </center>
<pre class="hljs"><code><div><span class="hljs-comment">//for语句实现</span>
<span class="hljs-function">Status <span class="hljs-title">LocateElem</span><span class="hljs-params">(SqList *L,Elemtype *e)</span>
</span>{
	<span class="hljs-keyword">int</span> i;
	<span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; L-&gt;length; i++)
	{
		<span class="hljs-keyword">if</span>(L-&gt;data[i] == *e)
		<span class="hljs-keyword">return</span> i+<span class="hljs-number">1</span>;
	}
	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}

<span class="hljs-comment">//while语句实现</span>
<span class="hljs-function">Status <span class="hljs-title">LocateElem</span><span class="hljs-params">(SqList *L,Elemtype *e)</span>
</span>{
	<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;
	<span class="hljs-keyword">while</span>( i &lt; L-&gt;length &amp;&amp; L-&gt;data[i] != *e)
	{
		i++;
		<span class="hljs-keyword">if</span>( i &lt; L-&gt;length)
			<span class="hljs-keyword">return</span> i+<span class="hljs-number">1</span>;
	}
		
	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}

</div></code></pre>
<h5 id="geteleml-i-e">GetElem(L, i, &amp;e)</h5>
<pre><code>将线性表L中的第i个位置元素返回给e
</code></pre>
<ul>
<li>C</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-function">Status <span class="hljs-title">GetElem</span><span class="hljs-params">(SqList L, <span class="hljs-keyword">int</span> i, Elemtype *e)</span>	<span class="hljs-comment">//获得元素操作，讲读取的元素赋给e</span>
</span>{
	<span class="hljs-comment">//初始条件  i的位置要合理</span>
	<span class="hljs-keyword">if</span> (L.length == <span class="hljs-number">0</span> || i &lt; <span class="hljs-number">1</span> || i &gt; L.length)			
		<span class="hljs-keyword">return</span> ERROR;
	<span class="hljs-comment">//操作结果</span>
	*e = L.data[i - <span class="hljs-number">1</span>];

	<span class="hljs-keyword">return</span> OK;
}
</div></code></pre>
<ul>
<li>C++</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-function">Status <span class="hljs-title">GetElem</span><span class="hljs-params">(SqList L, <span class="hljs-keyword">int</span> i, Elemtype &amp;e)</span>	<span class="hljs-comment">//获得元素操作，讲读取的元素赋给e</span>
</span>{
	<span class="hljs-comment">//初始条件  i的位置要合理</span>
	<span class="hljs-keyword">if</span> (L.length == <span class="hljs-number">0</span> || i &lt; <span class="hljs-number">1</span> || i &gt; L.length)			
		<span class="hljs-keyword">return</span> ERROR;
	<span class="hljs-comment">//操作结果</span>
	*e = L.data[i - <span class="hljs-number">1</span>];

	<span class="hljs-keyword">return</span> OK;
}
</div></code></pre>
<h3 id="22-a-name-1a%E9%A1%BA%E5%BA%8F%E8%A1%A8%E7%9A%84%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8%E9%93%BE%E8%A1%A8">2.2. <a name='-1'></a>顺序表的链式存储（链表）</h3>
<h4 id="221-a-name-1a%E5%8D%95%E9%93%BE%E8%A1%A8">2.2.1. <a name='-1'></a>单链表</h4>
<pre class="hljs"><code><div><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span>
{</span>
	<span class="hljs-keyword">char</span> name[<span class="hljs-number">20</span>];
	<span class="hljs-keyword">float</span> score;
}STD;
</div></code></pre>
<h5 id="%E5%8D%95%E9%93%BE%E8%A1%A8%E7%BB%93%E6%9E%84%E4%BB%A3%E7%A0%81">单链表结构代码</h5>
<pre class="hljs"><code><div><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span>
{</span>
	Elemtype data;		<span class="hljs-comment">//数据域</span>
	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span> *<span class="hljs-title">next</span>;</span>	<span class="hljs-comment">//指针域</span>
}LNode,*LinkList;		<span class="hljs-comment">//Node为数据类型&lt;=&gt;struct node</span>
						<span class="hljs-comment">//LinkList为指向结点的指针类型</span>
<span class="hljs-comment">//申请一个结点</span>
s = (LinkList)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(Node));	
s = (LNode*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(LNode))
</div></code></pre>
<h5 id="%E5%88%9D%E5%A7%8B%E5%8C%96%E6%9E%84%E9%80%A0%E7%A9%BA%E8%A1%A8-int-initlistlinklist-l">初始化构造空表 int InitList(LinkList *L)</h5>
<pre class="hljs"><code><div><span class="hljs-comment">//①被动修改</span>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">InitList</span><span class="hljs-params">(LinkList *L)</span>
</span>{
	*L = (LNode*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(LNode));
	<span class="hljs-keyword">if</span>(*L = <span class="hljs-literal">NULL</span>)
		<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
	(*L)-&gt;next = <span class="hljs-literal">NULL</span>;
		<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
}
<span class="hljs-comment">//②主动接受</span>
<span class="hljs-function">LinkList <span class="hljs-title">InitList</span><span class="hljs-params">()</span>		<span class="hljs-comment">//返回地址，不传参数</span>
</span>{
	LinkList L;
	L = (LNode*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(LNode));
	<span class="hljs-keyword">if</span>( L == <span class="hljs-literal">NULL</span>)
		<span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;
	L-&gt;next = <span class="hljs-literal">NULL</span>;
		<span class="hljs-keyword">return</span> L;
}
<span class="hljs-comment">//调用</span>
	LinkList H;
	H = InitList();

</div></code></pre>
<h5 id="%E5%88%A4%E6%96%AD%E9%93%BE%E8%A1%A8%E6%98%AF%E5%90%A6%E4%B8%BA%E7%A9%BA-int-islinklistemptylinklist-l">判断链表是否为空 int IsLinkListEmpty(LinkList L)</h5>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">IsLinkListEmpty</span><span class="hljs-params">(LinkList L)</span>
</span>{
	<span class="hljs-keyword">if</span>(L-&gt;next)
		<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
	<span class="hljs-keyword">else</span>
		<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
}
</div></code></pre>
<h5 id="%E5%88%9B%E5%BB%BA%E9%9D%9E%E7%A9%BA%E5%8D%95%E9%93%BE%E8%A1%A8-int-createlistlinklist-l-int-n">创建非空单链表 int CreateList(LinkList *L, int n)</h5>
<center>头插法</center>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">CreateLinkListFront</span><span class="hljs-params">(LinkList *L, <span class="hljs-keyword">int</span> n)</span>				<span class="hljs-comment">//O(n)</span>
</span>{
	*L = (*LNode)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(LNode));		<span class="hljs-comment">//建立带头节点的链表</span>
	<span class="hljs-keyword">if</span>(*L == <span class="hljs-literal">NULL</span>)
		<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
	
	<span class="hljs-keyword">int</span> i;
	LinkList s;
	<span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i&lt; n; i++)
	{
		s = (LinkList)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(LNode));
		<span class="hljs-built_in">scanf</span>(&amp;s-&gt;data);						<span class="hljs-comment">//伪代码</span>
		s-&gt;next = (*L)-&gt;next;
		(*L)-&gt;next = s;
	}
	<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
}
</div></code></pre>
<pre class="hljs"><code><div>
	s-&gt;next = L-&gt;next;
	L-&gt;next = s;


</div></code></pre>
<center>尾插法</center>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">CreateLinkListRear</span><span class="hljs-params">(LinkList *L, <span class="hljs-keyword">int</span> n)</span>				<span class="hljs-comment">//O(n)</span>
</span>{
	*L= (LinkList)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(LNode))
	<span class="hljs-keyword">if</span>(*L == <span class="hljs-literal">NULL</span>)
		<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
	(*L)-&gt;next = <span class="hljs-literal">NULL</span>;

	LinkList R;
	R = *L;
	<span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i&lt;n; i++)
	{
		LinkList s;
		s = (LinkList)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(LNode));
		<span class="hljs-built_in">scanf</span>(&amp;s-&gt;data);	<span class="hljs-comment">//伪代码</span>
		s-&gt;next = <span class="hljs-literal">NULL</span>;
		R-&gt;next = s;
		R = s;
	}
}
</div></code></pre>
<center>初始化函数和插入函数组合</center>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">CreateList</span><span class="hljs-params">(LinkList *L,<span class="hljs-keyword">int</span> n)</span>
</span>{
	<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>;
	Elemtype e；
	InitList(L);
	<span class="hljs-keyword">while</span>( i &lt; n )
	{
		InsertList(L,i++,e)
	}
	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>；
}	
</div></code></pre>
<h5 id="%E9%81%8D%E5%8E%86-int-traverlinklistlinklist-l">遍历 int TraverLinkList(LinkList L)</h5>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">TraverLinkList</span><span class="hljs-params">(LinkList L)</span>		<span class="hljs-comment">//O(n)</span>
</span>{
	LinkList p = L-&gt;next;
	<span class="hljs-keyword">while</span>(p)
	{
		<span class="hljs-built_in">printf</span>(p-&gt;data);		<span class="hljs-comment">//只是伪代码</span>
		p = p-&gt;next;
	}
}
</div></code></pre>
<h5 id="%E6%8C%89%E5%80%BC%E6%9F%A5%E6%89%BE-linklist-locateelemlinklist-l-elemtype-e">按值查找 LinkList LocateElem(LinkList L, ElemType e)</h5>
<center>返回地址</center>
<pre class="hljs"><code><div> <span class="hljs-function">LinkList <span class="hljs-title">LocateElem</span><span class="hljs-params">(LinkList L, ElemType e)</span>		<span class="hljs-comment">//返回地址</span>
 </span>{
	 LinkList p = L-&gt;next;
	 <span class="hljs-keyword">while</span>(p)
	 {
		 <span class="hljs-keyword">if</span>( p-&gt;data == e )		<span class="hljs-comment">//伪代码</span>
		 	<span class="hljs-keyword">break</span>;
			p = p-&gt;next;
	 }
	 <span class="hljs-keyword">return</span> p;					<span class="hljs-comment">//就算找不到也是返回NULL</span>
 }
</div></code></pre>
<center>返回位序</center>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">LocateElem</span><span class="hljs-params">(LinkList L,ElemType e)</span>
</span>{
	LinkList p = L-&gt;next;
	<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>;
	<span class="hljs-keyword">while</span>(p &amp;&amp; p-&gt;data != e)
	{
		p = p-&gt;next;
		j++;
	}
	<span class="hljs-keyword">if</span>(p)
		<span class="hljs-keyword">return</span> j;
	<span class="hljs-keyword">else</span> 
		<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</div></code></pre>
<h5 id="%E6%8C%89%E4%BD%8D%E5%BA%8F%E6%9F%A5%E6%89%BE-linklist-getposelemlinklist-lint-i">按位序查找 LinkList GetPosElem(LinkList L,int i)</h5>
<pre class="hljs"><code><div><span class="hljs-function">LinkList <span class="hljs-title">GetPosElem</span><span class="hljs-params">(LinkList L,<span class="hljs-keyword">int</span> i)</span>	<span class="hljs-comment">//LinkList类型，返回结点地址或空指针</span>
</span>{
	<span class="hljs-keyword">if</span>( i &lt; <span class="hljs-number">0</span> )
		<span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;
	LinkList p = L-&gt;next;
	<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>;
	<span class="hljs-keyword">while</span>( p &amp;&amp; j &lt; i )
	{
		p = p-&gt;next;
		j++;
	}
	<span class="hljs-keyword">if</span>( !p || j &gt; i )
		<span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;
	<span class="hljs-keyword">return</span> p; 
}
</div></code></pre>
<h5 id="%E6%B1%82%E9%95%BF%E5%BA%A6-int-listlengthlinklist-l">求长度 int ListLength(LInkList L)</h5>
<pre class="hljs"><code><div>{
	LinkList p = L-&gt;next;
	<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>;
	<span class="hljs-keyword">while</span>(p)
	{
		p = p-&gt;next;
		j++;
	}
}
</div></code></pre>
<h5 id="%E6%8C%89%E4%BD%8D%E5%BA%8F%E6%8F%92%E5%85%A5-int-insertlistlinklist-l-int-i-elemtype-e">按位序插入 int InsertList(LinkList L, int i, ElemType e)</h5>
<pre class="hljs"><code><div><span class="hljs-comment">//已知头指针L，位置i，待插入元素值e</span>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">InsertList</span><span class="hljs-params">(LinkList L, <span class="hljs-keyword">int</span> i, ElemType e)</span>
</span>{
	<span class="hljs-keyword">if</span>(i &lt;= <span class="hljs-number">0</span>)				<span class="hljs-comment">//越界</span>
		<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;

	LinkList p;
		p = L;
	<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>;				
	<span class="hljs-keyword">while</span>(p &amp;&amp; j&lt;i<span class="hljs-number">-1</span>)		<span class="hljs-comment">//&lt;=&gt; p = GetPosElem(L, i-1)</span>
	{
		p = p-&gt;next;
		++j;
	}

	<span class="hljs-keyword">if</span>(!p)					<span class="hljs-comment">//越界</span>
		<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;

	LinkList s = (LNode*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(LNode));		<span class="hljs-comment">//生成新结点</span>
	s-&gt;data = e;
	s-&gt;next = p-&gt;next;
	p-&gt;next = s;							<span class="hljs-comment">//插入</span>
}
</div></code></pre>
<h5 id="%E6%8C%89%E4%BD%8D%E5%BA%8F%E5%88%A0%E9%99%A4-int-deletelistlist-l-int-i-elemtype-e">按位序删除 int DeleteList(List L, int i; ElemType *e)</h5>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">DeleteList</span><span class="hljs-params">(LinkList L, <span class="hljs-keyword">int</span> i, ElemType *e)</span>		<span class="hljs-comment">//O(n)</span>
</span>{
	<span class="hljs-keyword">if</span>(i&lt;=<span class="hljs-number">0</span>)
		<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
	
	LinkList p;
	p = L;
	<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>;
	<span class="hljs-keyword">while</span>(p &amp;&amp; j&lt;i<span class="hljs-number">-1</span>)
	{
		p = p-&gt;next;
		++j;
	}

	<span class="hljs-keyword">if</span>(!p)
		<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
	
	LinkList q;
	q = p-&gt;next;
	p-&gt;next = q-&gt;next;
	*e = q-&gt;data;
	<span class="hljs-built_in">free</span>(q);
		<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
}
</div></code></pre>
<h5 id="%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E6%B8%85%E7%A9%BA-int-clearlistlinklist-l">单链表的清空 int ClearList(LinkList *L)</h5>
<pre><code>清空只清空元素，保留头节点和头指针
</code></pre>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">ClearList</span><span class="hljs-params">(LinkList L)</span>			<span class="hljs-comment">//O(n)</span>
</span>{
	LinkList p;
	<span class="hljs-keyword">while</span>((*L)-&gt;next)
	{
		p = (*L)-&gt;next;
		(*L)-&gt;next = p-&gt;next;
		<span class="hljs-built_in">free</span>(p);
	}
}
</div></code></pre>
<h5 id="%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E9%94%80%E6%AF%81-int-destroylistlinklist-l">单链表的销毁 int DestroyList(LinkList *L)</h5>
<pre><code>销毁不保留头节点
</code></pre>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">DestroyList</span><span class="hljs-params">(LinkList *L)</span>
</span>{
	LinkList p;
	<span class="hljs-keyword">while</span>(L)
	{
		p = (*L);
		(*L) = (*L)-&gt;next;
		<span class="hljs-built_in">free</span>(p);
	}
}
</div></code></pre>
<h5 id="%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E9%80%86%E7%BD%AE-void-invertedlinklist-l">单链表的逆置 void inverted(LinkList L)</h5>
<pre><code>算法思路：讲单链表从头节点开始分割成两个链表，用头插法重新插入即可
</code></pre>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Inverted</span><span class="hljs-params">(LinkList L)</span>
</span>{
    LinkList p;
    p = L-&gt;next;		<span class="hljs-comment">//临时指针，用于头插法</span>
    L-&gt;next = <span class="hljs-literal">NULL</span>;		<span class="hljs-comment">//断成两个链表</span>
    <span class="hljs-keyword">while</span> (p) {
        LinkList q;     <span class="hljs-comment">//临时指针，保存链表</span>
        q = p-&gt;next;
        p-&gt;next = L-&gt;next;
        L-&gt;next = p;
        p = q;
    }
}
</div></code></pre>
<pre><code>迭代法
</code></pre>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Inverted</span><span class="hljs-params">(LinkList L)</span>
</span>{
	LinkList pre = <span class="hljs-literal">NULL</span>;
	LinkList cur = L-&gt;next;
	<span class="hljs-keyword">while</span>(cur)
	{
		LinkList Next = cur-&gt;next;
		cur-&gt;next = pre;
		pre = cur;
		cur = Next;
	}
}
</div></code></pre>
<h5 id="%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8%E7%9A%84%E5%B0%B1%E5%9C%B0%E6%8E%92%E5%BA%8F-int-sortlinklist-l">单向链表的就地排序 int sort(LinkList L)</h5>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sort</span><span class="hljs-params">(LinkList *L)</span>
</span>{
	LinkList p;
	p = (*L)-&gt;next;
	(*L)-&gt;next = <span class="hljs-literal">NULL</span>;
	<span class="hljs-keyword">while</span>(p){
		LinkList q;				<span class="hljs-comment">//q用于保存未排序的链表</span>
		linkList s;				<span class="hljs-comment">//s用于保存第i-1个结点，确定插入位置</span>
		q = p-&gt;next;
		s = (*L);
		<span class="hljs-keyword">while</span>(s-&gt;next!=<span class="hljs-literal">NULL</span> &amp;&amp; s-&gt;next-&gt;data &lt;p-&gt;data){
			s = s-&gt;next;
		}
		p-&gt;next = s-&gt;next;
		s-&gt;next = p;
		p = q;
	}
	<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
}
</div></code></pre>
<h5 id="%E6%9C%89%E5%BA%8F%E8%A1%A8%E7%9A%84%E5%BD%92%E5%B9%B6">有序表的归并</h5>
<pre class="hljs"><code><div><span class="hljs-comment">/*	问题:已知线性表LA和LB，数据元素均按值非递减有序排列，
	将LA、LB归并成一个新的线性表Lc，
	且Lc中的数据元素按值非递减有序排列。
*/</span>

<span class="hljs-comment">//顺序表</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">MergeSq</span><span class="hljs-params">(SqList LA, SqList LB, SqList *LC)</span>
</span>{
	<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>, k = <span class="hljs-number">0</span>;
	LC-&gt;length = LA.length + LB.length;
	<span class="hljs-keyword">while</span>(i&lt;LA.length &amp;&amp; j&lt;LB.length){		<span class="hljs-comment">//LA和LB非空，写入小的元素到LC</span>
		<span class="hljs-keyword">if</span>( LA.elme[i] &lt; LB.elem[j] )
			LC-&gt;elem[k++] = LA.elem[i++];
		<span class="hljs-keyword">else</span> LC-&gt;elem[k++] = LB.elem[j++];
	}
	<span class="hljs-keyword">while</span>(i&lt;LA.length)
		LC-&gt;elem[k++] = LA.elem[i++];
	<span class="hljs-keyword">while</span>(j&lt;LB.length)
		LC-&gt;elem[k++] = LB.elem[j++];
}												<span class="hljs-comment">//O(m+n)</span>

<span class="hljs-comment">//去除重复元素</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">MergeSq</span><span class="hljs-params">(SqList LA, SqList LB, SqList *LC)</span>
</span>{
	<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>, k = <span class="hljs-number">0</span>;
	LC-&gt;length = LA.length + LB.length;
	<span class="hljs-keyword">while</span>(i&lt;LA.length &amp;&amp; j&lt;LB.length){		
		<span class="hljs-keyword">if</span>( LA.elem[i] &lt; LB.elem[j] ){
			<span class="hljs-keyword">if</span>(LC-&gt;elem[k]!=LA.elem[i])
				LC-&gt;elem[k++] = LA.elem[i++];
			<span class="hljs-keyword">else</span> i++;
		}
		<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(LA.elem[i]&gt;LB.elem[j]){
			<span class="hljs-keyword">if</span>(LC-&gt;elem[k]!=LB.elem[j])
				LC-&gt;elem[k++] = LB.elem[j++];	
			<span class="hljs-keyword">else</span> j++;
		}
	}
	<span class="hljs-keyword">while</span>(i&lt;LA.length)
		LC-&gt;elem[k++] = LA.elem[i++];
	<span class="hljs-keyword">while</span>(j&lt;LB.length)
		LC-&gt;elem[k++] = LB.elem[j++];
}

<span class="hljs-comment">//单链表</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">MergeLink</span><span class="hljs-params">(LinkList LA, LinkList LB)</span>
</span>{
	LinkList qa = LA, pa = LA-&gt;next;
	LinkList pb = LB-&gt;next, qb = pb-&gt;next;
	<span class="hljs-keyword">while</span>(pa&amp;&amp;pb){
		<span class="hljs-keyword">if</span>(pa-&gt;data &lt;= pb-&gt;data){			<span class="hljs-comment">//寻找插入位置</span>
			qa = pa;
			pa = pa-&gt;next;
		}
		<span class="hljs-keyword">else</span>{
			qa-&gt;next = pb;
			pb-&gt;next = pa;
			qa = pb;
			qb = pb-&gt;next;
		}
	}
	<span class="hljs-keyword">if</span>(!pa)				
		qa-&gt;next = pb;
		<span class="hljs-built_in">free</span>(LB);
}
</div></code></pre>
<h4 id="222-a-name-1a%E5%8D%95%E5%90%91%E5%BE%AA%E5%9D%8F%E9%93%BE%E8%A1%A8">2.2.2. <a name='-1'></a>单向循坏链表</h4>
<p>判断是否为空的条件为p是否等于头指针
<code>p!=L</code>or<code>p-&gt;next!=L</code>
尾指针表示：a~1~ = <code>R-&gt;next-&gt;next</code>;a~n~ = <code>R</code>.</p>
<h5 id="%E5%8D%95%E5%90%91%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8%E7%9A%84%E6%8F%92%E5%85%A5-int-cirinsertlinklinklist-l-int-i-elemtype-e">单向循环链表的插入	int CirInsertLink(LinkList L, int i, ElemType e)</h5>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">CirInsertLink</span><span class="hljs-params">(LinkList L, <span class="hljs-keyword">int</span> i, ElemType e)</span>
</span>{
	LinkList p = L;
	<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>;
	<span class="hljs-keyword">while</span>( p-&gt;next!=L &amp;&amp; j&lt;i<span class="hljs-number">-1</span> ){
		p = p-&gt;next;
		j++;
	}

	<span class="hljs-keyword">if</span>( j&lt;i<span class="hljs-number">-1</span> || j&gt;i<span class="hljs-number">-1</span> ){
		<span class="hljs-built_in">printf</span>(<span class="hljs-string">"位置异常！"</span>);
		<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>；
	}

	LinkList s = (LinkList)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(LNode));
	s-&gt;data = e;			<span class="hljs-comment">//伪代码</span>
	s-&gt;next = p-&gt;next;
	p-&gt;next = s;
	<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
		
}
</div></code></pre>
<h5 id="%E5%8D%95%E5%90%91%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8%E7%9A%84%E5%88%A0%E9%99%A4-int-cirdeletelinklinklist-l-int-i-elemtype-e">单向循环链表的删除	int CirDeleteLink(LinkList L, int i, ElemType e)</h5>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">CirDeleteLink</span><span class="hljs-params">(LinkList L, <span class="hljs-keyword">int</span> i, ElemType e)</span>
</span>{
	LinkList p = L;
	<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>;
	<span class="hljs-keyword">while</span>( p-&gt;next!=L &amp;&amp; j &lt; i<span class="hljs-number">-1</span> ){
		p = p-&gt;next;
		j++;
	}

	<span class="hljs-keyword">if</span>(j&lt;i<span class="hljs-number">-1</span> || j&gt;i<span class="hljs-number">-1</span>){
		<span class="hljs-built_in">printf</span>(<span class="hljs-string">"链表为空或位置异常！"</span>);
		<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
	}

	LinkList q = p-&gt;next;
	e = q-&gt;next;
	p-&gt;next = q-&gt;next;
	<span class="hljs-built_in">free</span>(q);
	<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
}
</div></code></pre>
<h5 id="%E5%8D%95%E5%90%91%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8%E7%9A%84%E5%90%88%E5%B9%B6-linklist-connectlinklist-talinklist-tb">单向循环链表的合并	LinkList Connect(LinkList Ta,LinkList Tb)</h5>
<p>这里是用尾指针表示的单向循环链表</p>
<pre class="hljs"><code><div><span class="hljs-function">LinkList <span class="hljs-title">Connect</span><span class="hljs-params">(LinkList Ta,LinkList Tb)</span>
</span>{
	LinkList p = Ta-&gt;next;			<span class="hljs-comment">//保存Ta表的头结点，便于Tb表接上</span>
	Ta-&gt;next = Tb-&gt;next-&gt;next;		<span class="hljs-comment">//Tb表尾接到Ta表头</span>
	<span class="hljs-built_in">free</span>(Tb-&gt;next);					<span class="hljs-comment">//释放Tb头结点</span>
	Tb-&gt;next = p;					<span class="hljs-comment">//Tb表尾接到Ta表头</span>
	<span class="hljs-keyword">return</span> Tb;						<span class="hljs-comment">//因为这里是用Tb的尾指针表示的</span>
}
</div></code></pre>
<h4 id="223-a-name-1a%E5%8F%8C%E5%90%91%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8">2.2.3. <a name='-1'></a>双向循环链表</h4>
<pre class="hljs"><code><div><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">DulNode</span>			//<span class="hljs-title">dual</span>
{</span>
	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">DulNode</span> *<span class="hljs-title">prior</span>;</span>		<span class="hljs-comment">//前驱</span>
	ElemType data;
	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">DulNode</span> *<span class="hljs-title">next</span>;</span>		<span class="hljs-comment">//后继</span>
}DulNode,*DuLinkLIst
</div></code></pre>
<h5 id="%E5%8F%8C%E5%90%91%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96-int-initdulinklistdulinklist-l">双向循环链表的初始化	int InitDuLinkList(DuLinkList *L)</h5>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">InitDuLinkList</span><span class="hljs-params">(DuLinkList *L)</span>
</span>{
	*L = (DuLinkList)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(DulNode));
	<span class="hljs-keyword">if</span>(*L == <span class="hljs-literal">NULL</span>){
		<span class="hljs-built_in">printf</span>(<span class="hljs-string">"申请空间失败！\n"</span>)；
		<span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);
	}
	(*L)-&gt;next = (*L)-&gt;prior = *L;
	<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
}
</div></code></pre>
<h5 id="%E5%8F%8C%E5%90%91%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8%E7%9A%84%E6%8F%92%E5%85%A5-int-duinsertdulinklist-l-int-i-elemtype-e">双向循环链表的插入	int DuInsert(DuLinkList *L, int i, ElemType e)</h5>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">DuInsert</span><span class="hljs-params">(DuLinkList *L, <span class="hljs-keyword">int</span> i, ElemType e)</span>
</span>{
	DuLinkList p = L;		<span class="hljs-comment">//临时指针，指向头结点</span>
	DuLinkList New_p;		<span class="hljs-comment">//用于指向新节点</span>
	<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>;
	
	<span class="hljs-keyword">while</span>(p-&gt;next!=L &amp;&amp; j &lt; i<span class="hljs-number">-1</span>){
		p = p-&gt;next;
		j++;
	}
	
	<span class="hljs-keyword">if</span>(j&lt;i<span class="hljs-number">-1</span> ||j&gt;i<span class="hljs-number">-1</span>){
		<span class="hljs-built_in">printf</span>(<span class="hljs-string">"位置不合理！\n"</span>);
		<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
	}

	s = (DuLinkList)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(DulNode));
	s-&gt;data = e;
	
	s-&gt;next = p-&gt;next;		<span class="hljs-comment">//后继</span>
	p-&gt;next = s;			
	
	s-&gt;prior = p;			<span class="hljs-comment">//前驱</span>
	p-&gt;next-&gt;prior = s;
}
</div></code></pre>
<h5 id="%E5%8F%8C%E5%90%91%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8%E7%9A%84%E5%88%A0%E9%99%A4-int-dudeletedulinklist-l-int-i-elemtype-e">双向循环链表的删除	int DuDelete(DuLinkList *L, int i, ElemType e)</h5>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">DuDelete</span><span class="hljs-params">(DuLinkList *L, <span class="hljs-keyword">int</span> i, ElemType e)</span>
</span>{
	DuLinkList p = L;
	<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>;
	<span class="hljs-keyword">while</span>(p-&gt;next != L &amp;&amp; j&lt;i<span class="hljs-number">-1</span> ){
		p = p-&gt;next;
	}

	<span class="hljs-keyword">if</span>( j&lt;i<span class="hljs-number">-1</span> || j &gt;i<span class="hljs-number">-1</span> ){
		<span class="hljs-built_in">printf</span>(<span class="hljs-string">"链表为空或位置不合理！\n"</span>);
		<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
	}

	DuLinkList q = p-&gt;next;
	e = q-&gt;next;
	p-&gt;next = q-&gt;next;
	q-&gt;next-&gt;prior = p;
	<span class="hljs-built_in">free</span>(q);
	<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
}	
</div></code></pre>
<pre><code class="language-mermaid"><div class="mermaid">	graph LR
	线性表 --- 顺序表
	线性表 --- 链表
	顺序表 --> 随机存取
	链表 --> 顺序存取
</div></code></pre>
<h2 id="3-a-name-1a%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97">3. <a name='-1'></a>栈与队列</h2>
<h3 id="31-a-namestacklastinfirstouta%E6%A0%88stacklast-in-first-out">3.1. <a name='stackLastInFirstOut'></a>栈(stack)Last In First Out</h3>
<p>栈是限定仅在表尾进行插入和删除操作的线性表。
栈顶：予许插入删除一段
栈底：另一端
LIFO结构</p>
<h4 id="311-a-name-1a%E6%A0%88%E7%9A%84%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8">3.1.1. <a name='-1'></a>栈的顺序存储</h4>
<h5 id="%E7%BB%93%E6%9E%84%E4%BB%A3%E7%A0%81">结构代码</h5>
<center>Method 1</center>
<pre class="hljs"><code><div><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MAX 100</span>
<span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">stack</span>
{</span>
	SElemType data[MAX];
	<span class="hljs-keyword">int</span> top;				<span class="hljs-comment">//栈顶位置</span>
	<span class="hljs-keyword">int</span> StackSize;			<span class="hljs-comment">//栈容量</span>
}SqStack;
</div></code></pre>
<center>Method 2</center>
<pre class="hljs"><code><div><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">stack</span>
{</span>
	SElemType *data;		<span class="hljs-comment">//指针</span>
	<span class="hljs-keyword">int</span> top;				<span class="hljs-comment">//栈顶位置</span>
	<span class="hljs-keyword">int</span> StackSize;			<span class="hljs-comment">//栈容量</span>
}SqStack;
</div></code></pre>
<h5 id="%E5%88%9D%E5%A7%8B%E5%8C%96%E6%93%8D%E4%BD%9C-initsqstacksqstack-s-int-max">初始化操作 InitSqStack(SqStack *S, int max)</h5>
<pre class="hljs"><code><div>InitSqStack(SqStack *S, <span class="hljs-keyword">int</span> <span class="hljs-built_in">max</span>)
{
	S-&gt;data = (SElemType*)<span class="hljs-built_in">malloc</span>(SElemType);
	<span class="hljs-keyword">if</span>(S-&gt;data == <span class="hljs-literal">NULL</span>){
		<span class="hljs-built_in">printf</span>(<span class="hljs-string">"空间申请失败！"</span>);
		<span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);
	}
	S-&gt;top = <span class="hljs-number">-1</span>;
	S-&gt;StackSize = <span class="hljs-built_in">max</span>;
	<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
}
</div></code></pre>
<h5 id="%E5%88%A4%E6%96%AD%E6%A0%88%E7%A9%BA-int-isstackemptysqstack-s">判断栈空 int IsStackEmpty(SqStack S)</h5>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">IsSqStackEmpty</span><span class="hljs-params">(SqStack S)</span>
</span>{
	<span class="hljs-keyword">if</span>(S.top == <span class="hljs-number">-1</span>)
		<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
	<span class="hljs-keyword">else</span> 
		<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</div></code></pre>
<h5 id="%E8%8E%B7%E5%8F%96%E6%A0%88%E9%A1%B6%E5%85%83%E7%B4%A0-int-getstacktopsqstack-s-int-e">获取栈顶元素 int GetStackTop(SqStack S, int *e)</h5>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">GetSqStackTop</span><span class="hljs-params">(SqStack S, <span class="hljs-keyword">int</span> *e)</span>
</span>{
	<span class="hljs-keyword">if</span>(S.top == <span class="hljs-number">-1</span>)
		<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
	*e = S.data[S.top];
		<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
}
</div></code></pre>
<h5 id="%E6%B1%82%E9%95%BF%E5%BA%A6-int-sqstacklengthsqstack-s">求长度 int SqStackLength(SqStack S)</h5>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">StackLength</span><span class="hljs-params">(SqStack S)</span>
</span>{
	<span class="hljs-keyword">if</span>(S.top == <span class="hljs-number">-1</span>)
		<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
	<span class="hljs-keyword">return</span> S.top+<span class="hljs-number">1</span>;
}
</div></code></pre>
<h5 id="%E8%BF%9B%E6%A0%88%E6%93%8D%E4%BD%9C-int-pushsqstacksqstack-s-int-e">进栈操作 int PushSqStack(SqStack *S, int e)</h5>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">PushSqStack</span><span class="hljs-params">(SqStack *S, <span class="hljs-keyword">int</span> e)</span>
</span>{
	<span class="hljs-keyword">if</span>(S-&gt;StackSize == S-&gt;top+<span class="hljs-number">1</span>)
		<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
	S-&gt;data[++S-&gt;top] = e;
	<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
}
</div></code></pre>
<h5 id="%E5%87%BA%E6%A0%88%E6%93%8D%E4%BD%9C-int-popsqstacksqstack-s-int-e">出栈操作 int PopSqStack(SqStack *S, int *e)</h5>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">PopSqStack</span><span class="hljs-params">(SqStack *S, <span class="hljs-keyword">int</span> *e)</span>
</span>{
	<span class="hljs-keyword">if</span>(S-&gt;top == <span class="hljs-number">-1</span>)
		<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
	*e = S-&gt;data[S-&gt;top--];
		<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
}
</div></code></pre>
<h5 id="%E9%81%8D%E5%8E%86%E6%93%8D%E4%BD%9C-int-traversqstackstack-s">遍历操作 int TraverSqStack(Stack S)</h5>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">TraverSqStack</span><span class="hljs-params">(Stack S)</span>
</span>{
	<span class="hljs-keyword">int</span> k;
	<span class="hljs-keyword">if</span>(s.top == <span class="hljs-number">-1</span>){
		<span class="hljs-built_in">printf</span>(<span class="hljs-string">"栈空！"</span>);
		<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
	}
	<span class="hljs-keyword">for</span>(k = S.top; k &gt;= <span class="hljs-number">0</span>; k--)
		<span class="hljs-built_in">printf</span>(<span class="hljs-string">"%-5d"</span>,S.data.data[k]);
	<span class="hljs-built_in">printf</span>(<span class="hljs-string">"/n"</span>);
}
</div></code></pre>
<h5 id="%E5%88%9B%E5%BB%BA%E9%A1%BA%E5%BA%8F%E6%A0%88-int-createsqstacksqstack-s-int-max">创建顺序栈 int CreateSqStack(SqStack *S, int max)</h5>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">CreateSqStack</span><span class="hljs-params">(SqStack *S, <span class="hljs-keyword">int</span> <span class="hljs-built_in">max</span>)</span>
</span>{
	<span class="hljs-keyword">int</span> x, YN;
	InitSqStack(S, <span class="hljs-built_in">max</span>);
	<span class="hljs-keyword">do</span>{
		<span class="hljs-built_in">printf</span>(<span class="hljs-string">"请输入进栈数据："</span>);
			<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>, &amp;x);
		<span class="hljs-built_in">printf</span>(<span class="hljs-string">"继续吗？yes = 1;no = 0"</span>);
			<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>, &amp;YN);
	}<span class="hljs-keyword">while</span>(YN == <span class="hljs-number">1</span>);
}
</div></code></pre>
<h4 id="312-a-name-1a%E6%A0%88%E7%9A%84%E9%93%BE%E5%BC%8F%E5%AD%98%E5%8F%96">3.1.2. <a name='-1'></a>栈的链式存取</h4>
<p>链栈不需要头节点！</p>
<h5 id="%E7%BB%93%E6%9E%84%E4%BB%A3%E7%A0%81">结构代码</h5>
<pre class="hljs"><code><div><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">StackNode</span>
{</span>
	SElemType data;
	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">StackNode</span> *<span class="hljs-title">next</span>;</span>
}SNode,*LinkStack;
</div></code></pre>
<h5 id="%E5%88%9D%E5%A7%8B%E5%8C%96-int-initlinkstacklinkstack-s">初始化 int InitLinkStack(LinkStack *S)</h5>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">InitLinkStack</span><span class="hljs-params">(LinkStack *S)</span>
</span>{
	*S = <span class="hljs-literal">NULL</span>;					<span class="hljs-comment">//只有一句，一般不用单独写函数</span>
}
</div></code></pre>
<h5 id="%E5%88%A4%E6%96%AD%E6%A0%88%E7%A9%BA-int-islinkstackemptylinkstack-s">判断栈空 int IsLinkStackEmpty(LinkStack S)</h5>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">IsLinkStackEmpty</span><span class="hljs-params">(LinkStack S)</span>
</span>{
	<span class="hljs-keyword">if</span>(S == <span class="hljs-literal">NULL</span>)
		<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
	<span class="hljs-keyword">else</span>
		<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</div></code></pre>
<h5 id="%E8%8E%B7%E5%8F%96%E6%A0%88%E9%A1%B6%E5%85%83%E7%B4%A0-int-getlinkstacktoplinkstack-s-int-e">获取栈顶元素 int GetLinkStackTop(LinkStack S, int *e)</h5>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">GetLinkStackTop</span><span class="hljs-params">(LinkStack S, <span class="hljs-keyword">int</span> *e)</span>
</span>{
	<span class="hljs-keyword">if</span>(S == <span class="hljs-literal">NULL</span>)
		<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
	*e = S-&gt;data;
		<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>
}
</div></code></pre>
<h5 id="%E6%B1%82%E9%95%BF%E5%BA%A6-int-linkstacklengthlinkstack-s">求长度 int LinkStackLength(LinkStack S)</h5>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">LinkStackLength</span><span class="hljs-params">(LinkStack S)</span>
</span>{
	<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>;
	LinkStack p = S;
	<span class="hljs-keyword">while</span> (p) {
		p = p-&gt;next;
		j++;
	}
	<span class="hljs-keyword">return</span> j;
}
</div></code></pre>
<h5 id="%E8%BF%9B%E6%A0%88%E6%93%8D%E4%BD%9C-int-pushlinkstacklinkstack-s">进栈操作 int PushLinkStack(LinkStack *S)</h5>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">PushLinkStack</span><span class="hljs-params">(LinkStack *S)</span>
</span>{
	LinkStack p = (LinkStack)<span class="hljs-built_in">malloc</span>(SNode);
	<span class="hljs-keyword">if</span> (p == <span class="hljs-literal">NULL</span>)
		<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
	p-&gt;data = e;
	p-&gt;next = *S;
	*S = p;
	<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
}
</div></code></pre>
<h5 id="%E5%87%BA%E6%A0%88%E6%93%8D%E4%BD%9C-int-poplinkstacklinkstack-s-int-e">出栈操作 int PopLinkStack(LinkStack *S， int *e)</h5>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">PopLinkStack</span><span class="hljs-params">(LinkStack *S, <span class="hljs-keyword">int</span> *e)</span>
</span>{
	LinkStack p = *S;
	<span class="hljs-keyword">if</span>(p == <span class="hljs-literal">NULL</span>)
		<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
	*S = p-&gt;next;
	*e = p-&gt;data;
	<span class="hljs-built_in">free</span>(p);
	<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
}
</div></code></pre>
<h5 id="%E9%81%8D%E5%8E%86%E6%93%8D%E4%BD%9C-int-traverslinkstacklinkstack-s">遍历操作 int TraversLinkStack(LinkStack S)</h5>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">TraversLinkStack</span><span class="hljs-params">(LinkStack S)</span>
</span>{
	<span class="hljs-keyword">if</span>(S == <span class="hljs-literal">NULL</span>){
		<span class="hljs-built_in">printf</span>(<span class="hljs-string">"栈空！"</span>);
		<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
	}
	<span class="hljs-keyword">while</span>(S){
		<span class="hljs-built_in">printf</span>(<span class="hljs-string">"%-5d"</span>,S-&gt;data);
		S = S-&gt;next;
	}
	<span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n"</span>);
	<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
}
</div></code></pre>
<h5 id="%E5%88%9B%E5%BB%BA%E9%93%BE%E6%A0%88-int-createlinkstacklinkstack-s">创建链栈 int CreateLinkStack(LinkStack S)</h5>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">CreateLinkStack</span><span class="hljs-params">(LinkStack S)</span>
</span>{
	<span class="hljs-keyword">int</span> x,YN;
	InitLinkStack(&amp;S);
	<span class="hljs-keyword">do</span>{
		<span class="hljs-built_in">printf</span>(<span class="hljs-string">"请输入链栈数据："</span>);
		<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;x);
		PushLinkStack(S,x);
		<span class="hljs-built_in">printf</span>(<span class="hljs-string">"继续吗？YES = 1; NO = 0."</span>);
		<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;YN);
	}<span class="hljs-keyword">while</span>(YN == <span class="hljs-number">1</span>);
	<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
}
</div></code></pre>
<h3 id="32-a-namequeuefirstinfirstouta%E9%98%9F%E5%88%97queuefirst-in-first-out">3.2. <a name='QueueFirstInFirstOut'></a>队列(Queue)First In First Out</h3>
<p>队头删除
队尾插入
FIFO结构</p>
<h4 id="321-a-name-1a%E9%93%BE%E9%98%9F%E5%88%97">3.2.1. <a name='-1'></a>链队列</h4>
<h5 id="%E9%93%BE%E9%98%9F%E5%88%97%E7%9A%84%E7%BB%93%E6%9E%84%E4%BB%A3%E7%A0%81">链队列的结构代码</h5>
<pre class="hljs"><code><div><span class="hljs-comment">//链队列的结点及指针类型</span>
<span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">QNode</span>
{</span>
	QElemType data;
	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">QNode</span> *<span class="hljs-title">next</span>;</span>
}QNode, *QueuePtr;

<span class="hljs-comment">//链队列类型</span>
<span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span>
{</span>
	QueuePtr front;
	QueuePtr rear;
}LinkQueue;
</div></code></pre>
<h5 id="%E9%93%BE%E9%98%9F%E5%88%97%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96-int-initqueuelinkqueue-q">链队列的初始化 int InitQueue(LinkQueue *Q)</h5>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">InitQueue</span><span class="hljs-params">(LinkQueue* Q)</span>
</span>{
	Q-&gt;front = Q-&gt;rear = (QueuePtr)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(QNode));
	<span class="hljs-keyword">if</span> (!Q-&gt;front)
		<span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);
	Q-&gt;front-&gt;next = <span class="hljs-literal">NULL</span>;
	<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
}
</div></code></pre>
<h5 id="%E9%93%BE%E9%98%9F%E5%88%97%E5%85%A5%E9%98%9F%E6%93%8D%E4%BD%9C-int-appendqueuelinkqueue-q">链队列入队操作 int AppendQueue(LinkQueue *Q)</h5>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">AppendQueue</span><span class="hljs-params">(LinkQueue *Q, QElemType e)</span>
</span>{
    QueuePtr p = (QueuePtr)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(QNode));
    <span class="hljs-keyword">if</span> (!p)
        <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);
    p-&gt;data = e;
    p-&gt;next = <span class="hljs-literal">NULL</span>;
    Q-&gt;rear-&gt;next = p;
    Q-&gt;rear = p;
    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
}
</div></code></pre>
<h5 id="%E9%93%BE%E9%98%9F%E5%88%97%E5%87%BA%E9%98%9F-int-dequeuelinkqueue-q-qelemtype-e">链队列出队 int DeQueue(LinkQueue *Q, QElemType &amp;e)</h5>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">DeQueue</span><span class="hljs-params">(LinkQueue* Q)</span>
</span>{
    <span class="hljs-keyword">if</span> (Q-&gt;front == Q-&gt;rear)
        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
    QueuePtr p = Q-&gt;front-&gt;next;
    Q-&gt;front-&gt;next = p-&gt;next;

    <span class="hljs-keyword">if</span> (Q-&gt;rear == p)
        Q-&gt;rear = Q-&gt;front;

    <span class="hljs-built_in">free</span>(p);
    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
}
</div></code></pre>
<h5 id="%E8%8E%B7%E5%8F%96%E9%93%BE%E9%98%9F%E5%88%97%E5%AF%B9%E5%A4%B4%E5%85%83%E7%B4%A0-int-getqueueheadlinkqueue-q-qelemtype-e">获取链队列对头元素 int GetQueueHead(LinkQueue Q, QElemType &amp;e)</h5>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">GetQueueHead</span><span class="hljs-params">(LinkQueue Q, QElemType &amp;e)</span>
</span>{
	<span class="hljs-keyword">if</span>(Q.front == Q.rear)
		<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
	e = Q.front-&gt;next-&gt;data;
	<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
}
</div></code></pre>
<h5 id="%E9%93%BE%E9%98%9F%E5%88%97%E7%9A%84%E9%94%80%E6%AF%81-int-destroyqueuelinkqueue-q">链队列的销毁 int DestroyQueue(LinkQueue *Q)</h5>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">DestroyQueue</span><span class="hljs-params">(LinkQueue *Q)</span>
</span>{
	<span class="hljs-keyword">while</span>(Q.front){
		p = Q.front-&gt;next;
		<span class="hljs-built_in">free</span>(Q.front);
		Q.front = p;
	}
	<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
}
</div></code></pre>
<h4 id="322-a-name-1a%E9%A1%BA%E5%BA%8F%E9%98%9F%E5%88%97%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97">3.2.2. <a name='-1'></a>顺序队列/循环队列</h4>
<h5 id="%E7%BB%93%E6%9E%84%E4%BB%A3%E7%A0%81">结构代码</h5>
<pre class="hljs"><code><div><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MAXQSIZE 100</span>
Typedef <span class="hljs-class"><span class="hljs-keyword">struct</span>{</span>
	QElemTyoe *base;
	<span class="hljs-keyword">int</span> front;			<span class="hljs-comment">//头指针</span>
	<span class="hljs-keyword">int</span> rear;			<span class="hljs-comment">//尾指针</span>
}SqQueue;
</div></code></pre>
<h5 id="%E5%88%9D%E5%A7%8B%E5%8C%96-int-initqueuesqqueue-q">初始化 int InitQueue(SqQueue *Q)</h5>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">InitQueue</span><span class="hljs-params">(SqQueue *Q)</span>
</span>{
	Q.base = <span class="hljs-keyword">new</span> QElemType[MAXSIZE];
	<span class="hljs-keyword">if</span>(!Q.base)
		<span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);
	Q.front = Q.rear = <span class="hljs-number">0</span>;
	<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
}
</div></code></pre>
<h5 id="%E6%B1%82%E9%95%BF%E5%BA%A6-int-queuelengthsqqueue-q">求长度 int QueueLength(SqQueue Q)</h5>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">QueueLength</span><span class="hljs-params">(SqQueue Q)</span>
</span>{
	<span class="hljs-keyword">return</span> (Q.rear-Q.front+MAXQSIZE)%MAXQSIZE;
}
</div></code></pre>
<h5 id="%E5%85%A5%E9%98%9F-int-enqueuesqqueue-q-qelemtype-e">入队 int EnQueue(SqQueue *Q, QElemType e)</h5>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">EnQueue</span><span class="hljs-params">(SqQueue *Q, QElemType e)</span>
</span>{
	<span class="hljs-keyword">if</span>((Q-&gt;rear+<span class="hljs-number">1</span>)%MAXQSIZE == Q-&gt;front)
		<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
	Q-&gt;data[Q-&gt;rear] = e;
	Q-&gt;rear = (Q-&gt;rear + <span class="hljs-number">1</span>)%MAXQSIZE;
	<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
}
</div></code></pre>
<h5 id="%E5%87%BA%E9%98%9F-int-dequeuesqqueue-q-qelemtype-e">出队 int DeQueue(SqQueue *Q, QElemType *e)</h5>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">DeQueue</span><span class="hljs-params">(SqQueue *Q, QElemType *e)</span>
</span>{
	<span class="hljs-keyword">if</span>(Q-&gt;front+<span class="hljs-number">1</span> == Q-&gt;rear)
		<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
	*e = Q-&gt;data[Q-&gt;front];
	Q-&gt;front = (Q-&gt;front + <span class="hljs-number">1</span>)%MAXQSIZE;
	<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
}
</div></code></pre>
<h5 id="%E5%8F%96%E5%AF%B9%E5%A4%B4%E5%85%83%E7%B4%A0-selemtype-getheadsqqueue-q">取对头元素 SElemType GetHead(SqQueue Q)</h5>
<pre class="hljs"><code><div><span class="hljs-function">SElemType <span class="hljs-title">GetHead</span><span class="hljs-params">(SqQueue Q)</span>
</span>{
	<span class="hljs-keyword">if</span>(Q-&gt;front+<span class="hljs-number">1</span> != Q-&gt;rear)
		<span class="hljs-keyword">return</span> Q.data[Q.front];
}

</div></code></pre>
<h2 id="4-a-name-1a%E4%B8%B2%E6%95%B0%E7%BB%84%E4%B8%8E%E5%B9%BF%E4%B9%89%E8%A1%A8">4. <a name='-1'></a>串、数组与广义表</h2>
<h3 id=""></h3>
<h2 id="5-a-name-1a%E6%A0%91%E5%92%8C%E4%BA%8C%E5%8F%89%E6%A0%91">5. <a name='-1'></a>树和二叉树</h2>
<h3 id="51-a-name-1a%E4%B8%80%E4%BA%9B%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5">5.1. <a name='-1'></a>一些基本概念</h3>
<pre><code class="language-mermaid"><div class="mermaid">	graph LR
	树---n个结点的有限集
	度/Degree---结点拥有的子树数
	树的度---树内各节点的度的最大值
	结点的分类---根结点
	结点的分类---叶结点/终端结点
	结点的分类---非终端结点/分支结点---度数不为0的结点
	结点的分类---内部节点---除根结点外的分支节点
	叶结点/终端结点---度数为0的结点

	结点间的关系---孩子Child---结点的子树
	结点间的关系---双亲Parent
	结点间的关系---兄弟Sibling---同一个双亲的孩子间的互称
	结点间的关系---堂兄弟---双亲在同一层的结点的互称
	结点间的关系---祖先
	结点间的关系---子孙

	其他概念---结点的层次---从根开始为第一层
	其他概念---树的深度/高度---树中结点的最大层次
	其他概念---有序树---从左至右有次序不可互换
	其他概念---无序树
	其他概念---森林Forest---m棵互不相交的树的集合
</div></code></pre>
<h3 id="52-a-name-1a%E4%BA%8C%E5%8F%89%E6%A0%91">5.2. <a name='-1'></a>二叉树</h3>
<pre><code class="language-mermaid"><div class="mermaid">	graph LR
	特殊二叉树---斜树---左斜树
	斜树---右斜树
	特殊二叉树---满二叉树
	特殊二叉树---完全二叉树---编号为i的结点与同深度的满二叉树编号为i的结点位置完全相同
	完全二叉树---特点---叶子节点只能出现在最下两层
	特点---最下层的叶子节点一定集中在左部连续位置
	特点---倒数第二层若有叶子节点一定集中在右部连续位置
	特点---如果结点度为1那么该节点只有左孩子
	特点---同样结点数的二叉树完全二叉树的深度最小
	特殊二叉树---二叉排序树/二叉查找树/二叉搜索树BinarySearchTree---若左子树不空则左子树上所有结点的值均小于它的根结点的值
	二叉排序树/二叉查找树/二叉搜索树BinarySearchTree---若右子树不空则右子树上所有结点的值均大于它的根结点的值
	二叉排序树/二叉查找树/二叉搜索树BinarySearchTree---左右子树也分别为二叉排序树
	二叉排序树/二叉查找树/二叉搜索树BinarySearchTree---没有键值相等的节点
	特殊二叉树---平衡二叉树BalancedBinaryTree
</div></code></pre>
<h4 id="521-a-name-1a%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%80%A7%E8%B4%A8">5.2.1. <a name='-1'></a>二叉树的性质</h4>
<ol>
<li>第$i$层至多有$2^{i-1}$个结点。</li>
<li>深度为$k$的二叉树至多有$2^{k-1}$个结点。</li>
<li>分支线总数为$n-1$.</li>
<li>记$n_0$为终端结点数，$n_1$为度数为$2$的结点数，$n_2$为度数为$2$的结点数，则
<ol>
<li>$分叉总数 = n_1+2n_2$</li>
<li>$n_0=n_2+1$</li>
</ol>
</li>
<li>具有$n$个结点的<strong>完全二叉树</strong>的深度是$[log_{2}n]+1$。</li>
<li>对于有$n$个结点的完全二叉树的结点按层序编号，对任一结点$i$有
<ol>
<li>如果$i=1$,则结点$i$是二叉树的根，无双亲；如果$i&gt;1$,则双亲结点是$[\frac{i}{2}]$。</li>
<li>如果$2i&gt;n$，则结点$i$无左孩子（结点$i$为叶子结点）；否则其左孩子是结点$2i$。</li>
<li>如果$2i+1&gt;n$，则结点$i$无右孩子；否则其右孩子为结点$2i+1$。</li>
</ol>
</li>
</ol>
<h4 id="522-a-name-1a%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84">5.2.2. <a name='-1'></a>二叉树的存储结构</h4>
<h5 id="%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8">顺序存储</h5>
<pre class="hljs"><code><div><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MAXNODE 100						<span class="hljs-comment">//最大结点数</span></span>
<span class="hljs-keyword">typedef</span> ElemType SqBiTree[MAXNODE+<span class="hljs-number">1</span>];	<span class="hljs-comment">//1号单元存放根结点</span>
</div></code></pre>
<h5 id="%E4%BA%8C%E5%8F%89%E9%93%BE%E8%A1%A8">二叉链表</h5>
<pre class="hljs"><code><div><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">BiTNode</span>
{</span>
	DataType data;
	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">BITNode</span> *<span class="hljs-title">Lchild</span>;</span>
	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">BITNode</span> *<span class="hljs-title">Rchild</span>;</span>
}BiTNode, *BiTree;
</div></code></pre>
<h5 id="%E4%B8%89%E5%8F%89%E9%93%BE%E8%A1%A8">三叉链表</h5>
<pre class="hljs"><code><div><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">TriTNode</span>
{</span>
	DataType data;
	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">TriTNode</span> *<span class="hljs-title">Lchild</span>;</span>
	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">TriTNode</span> *<span class="hljs-title">Rchild</span>;</span>
	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">TriTNode</span> *<span class="hljs-title">Rchild</span>;</span>
}TriTNode, *TriTree;
</div></code></pre>
<h4 id="523-a-name-1a%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86%E9%80%92%E5%BD%92%E7%AE%97%E6%B3%95">5.2.3. <a name='-1'></a>二叉树的遍历（递归算法）</h4>
<h5 id="dlr%E5%85%88%E5%BA%8F%E9%81%8D%E5%8E%86%E6%B3%95">DLR：先序遍历法</h5>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">PreOrderTraverse</span><span class="hljs-params">(BiTree T)</span>
</span>{
	<span class="hljs-keyword">if</span>(T == <span class="hljs-literal">NULL</span>)
		<span class="hljs-keyword">return</span> ;
	<span class="hljs-built_in">printf</span>(<span class="hljs-string">"%c"</span>,T-&gt;data);
	PreOrderTraverse(T-&gt;Lchild);
	PreOrderTraverse(T-&gt;Rchild);
}
</div></code></pre>
<h5 id="ldr%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E6%B3%95">LDR：中序遍历法</h5>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">InOrderTraverse</span><span class="hljs-params">(BiTree T)</span>
</span>{
	<span class="hljs-keyword">if</span>(T == <span class="hljs-literal">NULL</span>)
		<span class="hljs-keyword">return</span> ;
	InOrderTraverse(T-&gt;Lchild);
	<span class="hljs-built_in">printf</span>(<span class="hljs-string">"%c"</span>,T-&gt;data);
	InOrderTraverse(T-&gt;Rchild);
}
</div></code></pre>
<h5 id="lrd%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E6%B3%95">LRD：后序遍历法</h5>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">PostOrderTraverse</span><span class="hljs-params">(BiTree T)</span>
</span>{
	<span class="hljs-keyword">if</span>(T == <span class="hljs-literal">NULL</span>)
		<span class="hljs-keyword">return</span> ;
	PostOrderTraverse(T-&gt;Lchild);
	PostOrderTraverse(T-&gt;Rchild);
	<span class="hljs-built_in">printf</span>(<span class="hljs-string">"%c"</span>,T-&gt;data);
}
</div></code></pre>
<h5 id="%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86%E6%B3%95">层序遍历法</h5>
<p>借助队列</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">LeverOrderTraverse</span><span class="hljs-params">(BiTree)</span>
</span>{
	<span class="hljs-keyword">if</span>(root == <span class="hljs-literal">NULL</span>)				<span class="hljs-comment">//二叉树为空，结束遍历</span>
		<span class="hljs-keyword">return</span> ;
	Enqueue(root);					<span class="hljs-comment">//根指针入队</span>
	<span class="hljs-keyword">while</span>(!IsEmpty())				<span class="hljs-comment">//队列非空</span>
	{
		q = Dequeue();				<span class="hljs-comment">//出队并取出对头</span>
		visit(q-&gt;data);				<span class="hljs-comment">//访问（输出出队结点信息）</span>
		<span class="hljs-keyword">if</span>(q-&gt;Lchild != <span class="hljs-literal">NULL</span>)		<span class="hljs-comment">//左孩子入队</span>
			Enqueue(q-&gt;Lchild)
		<span class="hljs-keyword">if</span>(q-&gt;Rchild !=<span class="hljs-literal">NULL</span>)		<span class="hljs-comment">//右孩子入队</span>
			Eequeue(q-&gt;Rchild)
	}
}
</div></code></pre>
<h5 id="%E5%9F%BA%E4%BA%8E%E4%BB%BB%E5%8A%A1%E5%88%86%E6%9E%90%E6%B3%95">基于任务分析法</h5>
<pre class="hljs"><code><div><span class="hljs-comment">//任务分析法后续遍历</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Postorder_iter</span><span class="hljs-params">(BiTree T)</span>
</span>{
	LinkStack S;	
	InitLinkStack(&amp;S);		<span class="hljs-comment">//初始化栈</span>

	ET e;	
	BiTNode* p;
	e.ptr = T;				
	e.task = <span class="hljs-number">1</span>;
	PushLinkStack(&amp;S, e);

	<span class="hljs-keyword">while</span> (!IsLinkStackEmpty(S))
	{
		e = GetLinkStackTop(S);
		PopLinkStack(&amp;S, e);
		<span class="hljs-keyword">if</span> (e.task == <span class="hljs-number">0</span>)					<span class="hljs-comment">//访问</span>
		{
			<span class="hljs-built_in">printf</span>(<span class="hljs-string">"%s "</span>, e.ptr-&gt;Data.str);
		}
		<span class="hljs-keyword">else</span>                                <span class="hljs-comment">//遍历</span>
		{
			e.task = <span class="hljs-number">0</span>;
			PushLinkStack(&amp;S, e);			<span class="hljs-comment">//访问根节点</span>

			p = e.ptr;						<span class="hljs-comment">//维护当前指针</span>

			e.ptr = p-&gt;RightChild;			<span class="hljs-comment">//访问右子树</span>
								
			<span class="hljs-keyword">if</span> (e.ptr)
			{
				e.task = <span class="hljs-number">1</span>;					<span class="hljs-comment">//布置任务</span>
				PushLinkStack(&amp;S, e);
			}
					
			e.ptr = p-&gt;LeftChild;			<span class="hljs-comment">//访问左子树</span>
			<span class="hljs-keyword">if</span> (e.ptr)
			{
				e.task = <span class="hljs-number">1</span>;
				PushLinkStack(&amp;S, e);
			}		
		}
	}
}
</div></code></pre>
<p>注：给定了前序+中序就可以唯一确定二叉树
eg. 前序	<strong>A</strong> <em>B C</em> <em><strong>D E F G H I</strong></em>  根节点 左子树 右子树
中序	<em>B C</em> <strong>A</strong> <em><strong>E D G H F I</strong></em>  左子树 根节点 右子树</p>
<h4 id="524-a-name-1a%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86%E9%9D%9E%E9%80%92%E5%BD%92%E7%AE%97%E6%B3%95">5.2.4. <a name='-1'></a>二叉树的遍历（非递归算法）</h4>
<pre class="hljs"><code><div><span class="hljs-comment">//非递归先序遍历</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">preOrderIterative</span><span class="hljs-params">(BiTNode* root)</span>
</span>{
	<span class="hljs-keyword">if</span> (root == <span class="hljs-literal">NULL</span>)
		<span class="hljs-keyword">return</span>;
	LinkStack nodeStack;		<span class="hljs-comment">//创建一个栈保存结点</span>
	push(&amp;nodeStack, root);		<span class="hljs-comment">//根节点进栈</span>

	<span class="hljs-keyword">while</span> (!IsEmpty(nodeStack))	<span class="hljs-comment">//非空时迭代</span>
	{
		BiTNode* node = top(nodeStack);	<span class="hljs-comment">//保存栈顶结点</span>
		<span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d"</span>, node-&gt;data);			<span class="hljs-comment">//访问栈顶数据</span>
		pop(&amp;nodeStack);					<span class="hljs-comment">//栈顶结点出栈</span>
		
		<span class="hljs-comment">//子节点入栈</span>
		<span class="hljs-keyword">if</span> (node-&gt;RightChild)				<span class="hljs-comment">//考虑栈学先进后出的特点</span>
			push(node-&gt;RightChild);			<span class="hljs-comment">//所以是先右子树进栈</span>
		<span class="hljs-keyword">if</span> (node-&gt;LeftChild)				<span class="hljs-comment">//遍历时才能左子树先出栈</span>
			push(node-&gt;LeftChild);
	}
}
</div></code></pre>
<pre class="hljs"><code><div><span class="hljs-comment">//非递归中序遍历</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">InOrderIterative</span><span class="hljs-params">(BiTNode* root)</span>
</span>{
	<span class="hljs-keyword">if</span> (root == <span class="hljs-literal">NULL</span>)
		<span class="hljs-keyword">return</span>;
	LinkStack nodeStack;			<span class="hljs-comment">//创建一个栈保存结点</span>
	BiTNode* currentNode = root;	<span class="hljs-comment">//维护一个当前结点指针</span>

	<span class="hljs-keyword">while</span> (currentNode || !IsEmpty(nodeStack))
	{
		<span class="hljs-comment">//当前结点非空，或栈非空时迭代处理</span>
		<span class="hljs-keyword">while</span> (currentNode)				<span class="hljs-comment">//找到最深左子树</span>
		{
			push(nodeStack, currentNode);
			currentNode = currentNode-&gt;LeftChild;
		}
		<span class="hljs-comment">//左子树已经访问完</span>
		currentNode = top(nodeStack);			<span class="hljs-comment">//取栈顶结点</span>
		<span class="hljs-built_in">printf</span>(<span class="hljs-string">"%c"</span>, currentNode-&gt;data);		<span class="hljs-comment">//访问结点数据</span>
		pop(&amp;nodeStack);						<span class="hljs-comment">//出栈</span>
		currentNode = currentNode-&gt;RightChild;	<span class="hljs-comment">//将当前结点改为右子节点</span>
	}
}
</div></code></pre>
<pre class="hljs"><code><div><span class="hljs-comment">//非递归后序遍历</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">PostOrderIterative</span><span class="hljs-params">(BiTNode* root)</span>
</span>{
	<span class="hljs-keyword">if</span> (root == <span class="hljs-literal">NULL</span>)
		<span class="hljs-keyword">return</span>;
	LinkStack nodeStack;			<span class="hljs-comment">//创建一个栈保存结点</span>
	BiTNode* currentNode = root;	<span class="hljs-comment">//维护一个当前结点指针</span>
	BiTNode* visitedNode = root;	<span class="hljs-comment">//保存上一次访问的结点</span>
	
	<span class="hljs-comment">//当前结点非空，或栈非空时迭代处理</span>
	<span class="hljs-keyword">while</span> (currentNode  || !IsEmpty(nodeStack))
	{
		<span class="hljs-keyword">while</span> (currentNode)			<span class="hljs-comment">//沿左子树方向入栈</span>
		{
			push(&amp;nodeStack, currentNode);
			currentNode = currentNode-&gt;LeftChild;
		}
		currentNode = top(nodeStack);	<span class="hljs-comment">//取栈顶元素</span>

		<span class="hljs-comment">//栈顶元素有右子树且未被访问</span>
		<span class="hljs-keyword">if</span> (currentNode-&gt;RightChild &amp;&amp; currentNode-&gt;RightChild != visitedNode)
		{
			currentNode = currentNode-&gt;RightChild;
		}
		<span class="hljs-keyword">else</span>	<span class="hljs-comment">//右子树为空或被访问过</span>
		{
			<span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d"</span>, currentNode-&gt;data);	<span class="hljs-comment">//访问结点数据</span>
			visitedNode = currentNode;			<span class="hljs-comment">//记录当前访问的结点</span>
			currentNode = <span class="hljs-literal">NULL</span>;					<span class="hljs-comment">//当前结点设置为空，防止重复访问左子树</span>
			pop(&amp;nodeStack);					<span class="hljs-comment">//出栈</span>
		}
	}
}
</div></code></pre>
<h4 id="525-a-name-1a%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%BB%BA%E7%AB%8B">5.2.5. <a name='-1'></a>二叉树的建立</h4>
<h5 id="%E5%9F%BA%E4%BA%8E%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86%E9%80%92%E5%BD%92%E7%AE%97%E6%B3%95">基于前序遍历递归算法</h5>
<pre class="hljs"><code><div><span class="hljs-comment">//基于前序遍历</span>
<span class="hljs-comment">//BiTNode root = Create(&amp;root);</span>
<span class="hljs-function">BiTNode* <span class="hljs-title">Create</span><span class="hljs-params">(BiTNode* bt)</span>
</span>{
	<span class="hljs-keyword">char</span> ch[MAXSIZE];
	<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%s"</span>, ch);		<span class="hljs-comment">//gets(ch)??</span>
	Input(bt, ch);
	<span class="hljs-keyword">if</span> (<span class="hljs-built_in">strcmp</span>(ch,<span class="hljs-string">"#"</span>) == <span class="hljs-number">1</span>)
		bt = <span class="hljs-literal">NULL</span>;
	<span class="hljs-keyword">else</span>
	{
		bt = (BiTree)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(BiTNode));
		<span class="hljs-built_in">strcpy</span>(bt-&gt;data.str, ch);
		bt-&gt;LeftChild = Create(bt-&gt;LeftChild);		<span class="hljs-comment">//切记要将返回赋值</span>
		bt-&gt;RightChild = Create(bt-&gt;RightChild);
	}
	<span class="hljs-keyword">return</span> bt;
}
</div></code></pre>
<h5 id="%E5%9F%BA%E4%BA%8E%E8%AF%BB%E8%BE%B9%E6%B3%95">基于读边法</h5>
<pre class="hljs"><code><div><span class="hljs-comment">//依次输入父节点，子节点，数字0代表创建左子树，1代表创建右子树</span>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">ReadEdgeCreate</span><span class="hljs-params">(BiTree* bt)</span>
</span>{
	LinkQueue Q;
	InitQueue(&amp;Q);
	*bt = <span class="hljs-literal">NULL</span>;
	<span class="hljs-keyword">char</span> father, child;
	<span class="hljs-keyword">int</span> flag;
	<span class="hljs-built_in">printf</span>(<span class="hljs-string">"\t"</span>);
	<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%c,%c,%d"</span>, &amp;father, &amp;child, &amp;flag);
	getchar();
	<span class="hljs-keyword">while</span> ( child != <span class="hljs-string">'#'</span> )
	{
		BiTree p = (BiTree)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(BiTNode));
		p-&gt;Data.dt = (<span class="hljs-keyword">int</span>)(child-<span class="hljs-string">'0'</span>);
		p-&gt;LeftChild = p-&gt;RightChild = <span class="hljs-literal">NULL</span>;
		EnQueue(&amp;Q, p);
		<span class="hljs-keyword">if</span> ( father == <span class="hljs-string">'#'</span>)
			*bt = p;
		<span class="hljs-keyword">else</span>
		{
			BiTree s = GetHead(Q);
			<span class="hljs-keyword">while</span> (s-&gt;Data.dt != (<span class="hljs-keyword">int</span>)(father-<span class="hljs-string">'0'</span>))
			{
				DeQueue(&amp;Q);
				s = GetHead(Q);
			}
			<span class="hljs-keyword">if</span> (flag == <span class="hljs-number">0</span>)
				s-&gt;LeftChild = p;
			<span class="hljs-keyword">else</span> s-&gt;RightChild = p;
		}
		<span class="hljs-built_in">printf</span>(<span class="hljs-string">"\t"</span>);
		<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%c,%c,%d"</span>, &amp;father, &amp;child, &amp;flag);
		getchar();
	}
	<span class="hljs-keyword">return</span> OK;
}
</div></code></pre>
<h4 id="526-a-name-1a%E6%B1%82%E6%9C%80%E5%A4%A7%E7%BB%93%E7%82%B9">5.2.6. <a name='-1'></a>求最大结点</h4>
<pre class="hljs"><code><div><span class="hljs-comment">//结点类型为整形</span>
<span class="hljs-function"><span class="hljs-keyword">int</span>* <span class="hljs-title">PreFindMaxInt</span><span class="hljs-params">(BiTree bt, <span class="hljs-keyword">int</span>* <span class="hljs-built_in">max</span>)</span>
</span>{
	<span class="hljs-keyword">if</span> (bt)
	{
		<span class="hljs-keyword">if</span> (*<span class="hljs-built_in">max</span>&lt;=bt-&gt;Data.dt)
			*<span class="hljs-built_in">max</span> = bt-&gt;Data.dt;
		<span class="hljs-built_in">max</span> = PreFindMaxInt(bt-&gt;LeftChild, <span class="hljs-built_in">max</span>);
		<span class="hljs-built_in">max</span> = PreFindMaxInt(bt-&gt;RightChild, <span class="hljs-built_in">max</span>);
	}
	<span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>;
}

<span class="hljs-comment">//结点类型为字符串</span>
<span class="hljs-function"><span class="hljs-keyword">char</span>* <span class="hljs-title">PreFindMaxStr</span><span class="hljs-params">(BiTree bt, <span class="hljs-keyword">char</span> *<span class="hljs-built_in">max</span>)</span>		
</span>{
	<span class="hljs-keyword">if</span> (bt)
	{
		<span class="hljs-keyword">if</span> (<span class="hljs-built_in">strcmp</span>(<span class="hljs-built_in">max</span>, bt-&gt;Data.str) &lt;= <span class="hljs-number">0</span>)
			<span class="hljs-built_in">max</span> = bt-&gt;Data.str;
		<span class="hljs-built_in">max</span> = PreFindMaxStr(bt-&gt;LeftChild, <span class="hljs-built_in">max</span>);
		<span class="hljs-built_in">max</span> = PreFindMaxStr(bt-&gt;RightChild, <span class="hljs-built_in">max</span>);
	}
	<span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>;
}
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">PreFindMaxStr2</span><span class="hljs-params">(BiTree bt, <span class="hljs-keyword">char</span>** <span class="hljs-built_in">max</span>)</span>		<span class="hljs-comment">//利用二级指针</span>
</span>{
	<span class="hljs-keyword">if</span> (bt)
	{
		<span class="hljs-keyword">if</span> (<span class="hljs-built_in">strcmp</span>(*<span class="hljs-built_in">max</span>, bt-&gt;Data.str) &lt;= <span class="hljs-number">0</span>)
			*<span class="hljs-built_in">max</span> = bt-&gt;Data.str;
		PreFindMaxStr2(bt-&gt;LeftChild, <span class="hljs-built_in">max</span>);
		PreFindMaxStr2(bt-&gt;RightChild, <span class="hljs-built_in">max</span>);
	}
}
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">PreFindMaxStr3</span><span class="hljs-params">(BiTree bt, <span class="hljs-keyword">char</span>* <span class="hljs-built_in">max</span>)</span>
</span>{
	<span class="hljs-keyword">if</span> (bt)
	{
		<span class="hljs-keyword">if</span> (<span class="hljs-built_in">strcmp</span>(<span class="hljs-built_in">max</span>, bt-&gt;Data.str) &lt;= <span class="hljs-number">0</span>)
			<span class="hljs-built_in">strcpy</span>(<span class="hljs-built_in">max</span>, bt-&gt;Data.str);			<span class="hljs-comment">//借助strcpy，注意区别于方法一</span>
		PreFindMaxStr3(bt-&gt;LeftChild, <span class="hljs-built_in">max</span>);
		PreFindMaxStr3(bt-&gt;RightChild, <span class="hljs-built_in">max</span>);
	}
}

</div></code></pre>
<h4 id="527-a-name-1a%E6%9F%A5%E6%89%BE%E6%8C%87%E5%AE%9A%E7%BB%93%E7%82%B9">5.2.7. <a name='-1'></a>查找指定结点</h4>
<p>指定结点只有一个</p>
<pre class="hljs"><code><div><span class="hljs-function">BiTree <span class="hljs-title">Find</span><span class="hljs-params">(BiTree bt, <span class="hljs-keyword">char</span> *<span class="hljs-built_in">find</span>)</span>
</span>{
	<span class="hljs-keyword">if</span> (!bt)
		<span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;
	<span class="hljs-keyword">if</span> (<span class="hljs-built_in">strcmp</span>(<span class="hljs-built_in">find</span>, bt-&gt;Data.str) == <span class="hljs-number">0</span>)
		<span class="hljs-keyword">return</span> bt;
	<span class="hljs-keyword">if</span> (Find(bt-&gt;LeftChild, <span class="hljs-built_in">find</span>))
		<span class="hljs-keyword">return</span> Find(bt-&gt;LeftChild, <span class="hljs-built_in">find</span>);
	<span class="hljs-keyword">else</span> 
		<span class="hljs-keyword">return</span> Find(bt-&gt;RightChild, <span class="hljs-built_in">find</span>);
}
</div></code></pre>
<p>指定结点不止一个则需要借助数组等进行保存再输出</p>
<pre class="hljs"><code><div><span class="hljs-function">BiTree <span class="hljs-title">Find</span><span class="hljs-params">(BiTree bt, <span class="hljs-keyword">int</span> e, BiTree p[], <span class="hljs-keyword">int</span> *n)</span>
</span>{
	<span class="hljs-keyword">if</span>(bt)
	{
		<span class="hljs-keyword">if</span>(bt-&gt;data == e)
			p[(*n)++] = bt;
		Find(bt-&gt;leftChild, e, p, n);
		Find(bt-&gt;RightChild, e, p, n);
	}
}
</div></code></pre>
<h4 id="528-a-name-1a%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%94%80%E6%AF%81">5.2.8. <a name='-1'></a>二叉树的销毁</h4>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">DeleteTree</span><span class="hljs-params">(BiTree&amp; bt)</span>
</span>{
	<span class="hljs-keyword">if</span> (bt-&gt;LeftChild)
	{
		DeleteTree(bt-&gt;LeftChild);
	}
	<span class="hljs-keyword">if</span> (!(bt-&gt;LeftChild &amp;&amp; bt-&gt;RightChild))
	{
		<span class="hljs-built_in">free</span>(bt);
		bt = <span class="hljs-literal">NULL</span>;
		<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
	}<span class="hljs-keyword">if</span> (bt-&gt;RightChild)
	{
		DeleteTree(bt-&gt;RightChild);
	}
}
</div></code></pre>
<h4 id="529-a-name-1a%E5%90%84%E7%A7%8D%E6%95%B0%E9%87%8F">5.2.9. <a name='-1'></a>各种数量</h4>
<h5 id="%E6%B1%82%E5%8F%B6%E5%AD%90%E8%8A%82%E7%82%B9%E4%B8%AA%E6%95%B0">求叶子节点个数</h5>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">LeafCount</span><span class="hljs-params">(BiTree bt, <span class="hljs-keyword">int</span> *count)</span>
</span>{
	<span class="hljs-keyword">if</span> (!bt)
		<span class="hljs-keyword">return</span>;
	<span class="hljs-keyword">if</span> (!bt-&gt;LeftChild &amp;&amp; !bt-&gt;RightChild)		<span class="hljs-comment">//叶子结点判断标志</span>
		(*count)++;
	LeafCount(bt-&gt;LeftChild, count);			<span class="hljs-comment">//先数左子树</span>
	LeafCount(bt-&gt;RightChild, count);			<span class="hljs-comment">//再数右子树</span>
}
</div></code></pre>
<h5 id="%E6%B1%82%E6%80%BB%E7%9A%84%E7%BB%93%E7%82%B9%E4%B8%AA%E6%95%B0">求总的结点个数</h5>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">SumNode</span><span class="hljs-params">(BiTree bt)</span>
</span>{
	<span class="hljs-keyword">if</span> (!bt)
		<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
	<span class="hljs-keyword">else</span>
	{
		<span class="hljs-keyword">int</span> left = SumNode(bt-&gt;LeftChild);
		<span class="hljs-keyword">int</span> right = SumNode(bt-&gt;RightChild);
		<span class="hljs-keyword">return</span> left + right + <span class="hljs-number">1</span>;		<span class="hljs-comment">//写成return SumNode(bt-&gt;LeftChild)+SumNode(bt-&gt;RightChild)；即可</span>
	}
}
</div></code></pre>
<h5 id="%E6%B1%82%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%B7%B1%E5%BA%A6">求二叉树的深度</h5>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">Depth</span><span class="hljs-params">(BiTree bt)</span>
</span>{
	<span class="hljs-keyword">if</span> (!bt)
		<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
	<span class="hljs-keyword">else</span>
	{
		<span class="hljs-keyword">int</span> DepLeft = Depth(bt-&gt;LeftChild);		<span class="hljs-comment">//左边的深度</span>
		<span class="hljs-keyword">int</span> DepRight = Depth(bt-&gt;RightChild);	<span class="hljs-comment">//右边的深度</span>
		<span class="hljs-keyword">if</span> (DepLeft &gt;= DepRight)				<span class="hljs-comment">//取最大的数作为深度</span>
			<span class="hljs-keyword">return</span> DepLeft + <span class="hljs-number">1</span>;					<span class="hljs-comment">//加1是加上根结点	</span>
		<span class="hljs-keyword">else</span> 
			<span class="hljs-keyword">return</span> DepRight + <span class="hljs-number">1</span>;
	}
}
</div></code></pre>
<h5 id="%E6%B1%82%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%AE%BD%E5%BA%A6">求二叉树的宽度</h5>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">Width</span><span class="hljs-params">(BiTree bt)</span>
</span>{
	<span class="hljs-keyword">int</span> <span class="hljs-built_in">width</span> = <span class="hljs-number">0</span>;			<span class="hljs-comment">//更新最大宽度</span>
	<span class="hljs-keyword">int</span> len = <span class="hljs-number">0</span>;			<span class="hljs-comment">//记录每一层的宽度</span>
	<span class="hljs-keyword">int</span> i;					<span class="hljs-comment">//遍历每一层的结点</span>

	LinkQueue Q;			<span class="hljs-comment">//基于层次遍历，故用队列</span>
	InitQueue(&amp;Q);
	
	BiTree p;
	<span class="hljs-keyword">if</span> (!bt)
		<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;

	EnQueue(&amp;Q, bt);		<span class="hljs-comment">//根结点入队</span>
	<span class="hljs-keyword">while</span> (!IsEmpty(Q))
	{
		len = GetLengthQueue(Q);	<span class="hljs-comment">//每一层入队后队列的长度即为该层的宽度</span>
		<span class="hljs-built_in">width</span> = len &gt; <span class="hljs-built_in">width</span> ? len : <span class="hljs-built_in">width</span>;	<span class="hljs-comment">//更新最大宽度</span>
		<span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; len; i++)
		{
			p = DeQueue(&amp;Q);		<span class="hljs-comment">//出队并记录出队结点便于访问该结点的孩子结点</span>
			<span class="hljs-keyword">if</span> (p-&gt;LeftChild)				<span class="hljs-comment">//先左孩子入队</span>
				EnQueue(&amp;Q, p-&gt;LeftChild);
			<span class="hljs-keyword">if</span> (p-&gt;RightChild)				<span class="hljs-comment">//再右孩子入队</span>
				EnQueue(&amp;Q, p-&gt;RightChild);
		}
	}
	<span class="hljs-keyword">return</span> <span class="hljs-built_in">width</span>;
}
</div></code></pre>
<h3 id="53-a-nametreea%E6%A0%91%E4%B8%8E%E6%A3%AE%E6%9E%97tree">5.3. <a name='Tree'></a>树与森林（Tree）</h3>
<h4 id="531-a-name-1a%E6%A0%91%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84">5.3.1. <a name='-1'></a>树的存储结构</h4>
<h5 id="%E5%8F%8C%E4%BA%B2%E8%A1%A8%E7%A4%BA%E6%B3%95">双亲表示法</h5>
<pre class="hljs"><code><div><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MAXSIZE 100</span>

<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">int</span> TElemType;

<span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">PTNode</span>	//结点结构
{</span>
	ElemType data;
	<span class="hljs-keyword">int</span> parent;			<span class="hljs-comment">//双亲位置</span>
	<span class="hljs-comment">//int FirstChild;		//长子位置</span>
	<span class="hljs-comment">//int RightSib;		//右兄弟位置</span>
}PTNode;

<span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span>
{</span>
	PTNode nodes[MAXSIZE];
	<span class="hljs-keyword">int</span> r,n;			<span class="hljs-comment">//根位置和结点数</span>
}PTree;
</div></code></pre>
<h5 id="%E5%AD%A9%E5%AD%90%E8%A1%A8%E7%A4%BA%E6%B3%95">孩子表示法</h5>
<pre class="hljs"><code><div><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MAXSIZE 100</span>

<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">int</span> TElemType;

<span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">CTNode</span>			//孩子结点
{</span>
	<span class="hljs-keyword">int</span> child;
	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">CTNode</span>* <span class="hljs-title">next</span>;</span>
}CTNode, *ChildPtr;

<span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span>					//双亲结点
{</span>
	TElemType data;
	ChildPtr firstchild;
}CTBox;

<span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span>					//树结构
{</span>
	CTBox nodes[MAXSIZE];
	<span class="hljs-keyword">int</span> r, n;					<span class="hljs-comment">//结点数和根节点位置</span>
}CTree;
</div></code></pre>
<h5 id="%E5%8F%8C%E4%BA%B2%E5%AD%A9%E5%AD%90%E8%A1%A8%E7%A4%BA%E6%B3%95">双亲孩子表示法</h5>
<pre class="hljs"><code><div><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">CTNode</span>			//孩子结点
{</span>
	<span class="hljs-keyword">int</span> child;
	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">CTNode</span>* <span class="hljs-title">next</span>;</span>
}CTNode, * ChildPtr;

<span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span>					//双亲结点
{</span>
	TElemType data;
	<span class="hljs-keyword">int</span> parent;
	ChildPtr firstchild;		<span class="hljs-comment">//孩子链头指针</span>
}CTBox;

<span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span>					//树类型
{</span>
	CTBox nodes[MAXSIZE];
	<span class="hljs-keyword">int</span> r, n;					<span class="hljs-comment">//结点数和根节点位置</span>
}CPTree;

</div></code></pre>
<h5 id="%E5%AD%A9%E5%AD%90%E5%85%84%E5%BC%9F%E8%A1%A8%E7%A4%BA%E6%B3%95%E9%93%BE%E8%A1%A8">孩子兄弟表示法（链表）</h5>
<pre class="hljs"><code><div><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">CSNode</span>
{</span>
	TElemType data;
	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">CSNode</span> *<span class="hljs-title">firstchild</span>, *<span class="hljs-title">nextsibling</span>;</span>
}CSNode, *CSTree;
</div></code></pre>
<h4 id="532-a-name-1a%E6%A0%91%E7%9A%84%E5%88%9B%E5%BB%BA">5.3.2. <a name='-1'></a>树的创建</h4>
<h5 id="%E5%AD%A9%E5%AD%90%E9%93%BE%E8%A1%A8%E5%88%9B%E5%BB%BA">孩子链表创建</h5>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">CreateChildLink</span><span class="hljs-params">(CTree* T)</span>
</span>{
	<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>, &amp;T-&gt;n);		<span class="hljs-comment">//读入结点数</span>
	T-&gt;r = <span class="hljs-number">0</span>;				<span class="hljs-comment">//根位置</span>
	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; T-&gt;n; i++)
	{
		<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>, &amp;T-&gt;nodes[i].data);
		T-&gt;nodes[i].firstchild = <span class="hljs-literal">NULL</span>;
		<span class="hljs-keyword">int</span> f, c;
		<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d"</span>, &amp;f, &amp;c);
		<span class="hljs-keyword">while</span> (c != <span class="hljs-number">-1</span>)		<span class="hljs-comment">//循环读边</span>
		{
			ChildPtr s = (ChildPtr)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(CTNode));	
			s-&gt;child = c;		<span class="hljs-comment">//单链表的头插法</span>
			s-&gt;next = <span class="hljs-literal">NULL</span>;
			s-&gt;next = T-&gt;nodes[f].firstchild;
			T-&gt;nodes[f].firstchild = s;
			<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d"</span>, &amp;f, &amp;c);
		}
	}
}
</div></code></pre>
<h5 id="%E8%AF%BB%E8%BE%B9%E6%B3%95%E5%88%9B%E5%BB%BA%E5%AD%A9%E5%AD%90%E5%85%84%E5%BC%9F%E9%93%BE%E8%A1%A8">读边法创建孩子兄弟链表</h5>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">CreateCSTree</span><span class="hljs-params">(CSTree* T)</span>		<span class="hljs-comment">//读边法创建孩子兄弟链表</span>
</span>{
	*T = <span class="hljs-literal">NULL</span>;
	<span class="hljs-keyword">char</span> fa, ch;
	<span class="hljs-keyword">for</span> (<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%c%c"</span>, &amp;fa, &amp;ch); ch != <span class="hljs-string">'#'</span>; <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%c%c"</span>, &amp;fa, &amp;ch))
	{
		CSTree p = (CSTree)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(CSNode));
		CSTree s, r;	<span class="hljs-comment">//s用来保存队头元素；r用来保存上一次的链接点</span>

		p-&gt;data = ch;
		p-&gt;firstchild = <span class="hljs-literal">NULL</span>;
		p-&gt;nextsibling = <span class="hljs-literal">NULL</span>;		<span class="hljs-comment">//创建结点</span>

		EnQueue(Q, p);				<span class="hljs-comment">//指针入队</span>

		<span class="hljs-keyword">if</span> (fa == <span class="hljs-string">'#'</span>)		<span class="hljs-comment">//所建为根节点</span>
			*T = p;
		<span class="hljs-keyword">else</span>				<span class="hljs-comment">//非根节点的情况</span>
		{

			GetHead(Q, s);

			<span class="hljs-keyword">while</span> (s-&gt;data != fa)		<span class="hljs-comment">//找父节点</span>
			{
				DeQueue(Q, s);
				GetHead(Q, s);
			}
			
			<span class="hljs-keyword">if</span> ((s-&gt;data == fa))		<span class="hljs-comment">//链接第一个孩子结点</span>
			{
				s-&gt;firstchild = p;
				r = p;
			}
			<span class="hljs-keyword">else</span>						<span class="hljs-comment">//链接其他孩子结点</span>
			{
				r-&gt;nextsibling = p;
				r = p;
			}

		}
	}
}
</div></code></pre>
<h4 id="533-a-name-1a%E6%A0%91%E5%92%8C%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%BD%AC%E6%8D%A2">5.3.3. <a name='-1'></a>树和二叉树的转换</h4>
<h5 id="%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86">树的遍历</h5>
<h6 id="%E5%85%88%E6%A0%B9%E9%81%8D%E5%8E%86">先根遍历</h6>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">PreOrderTree</span><span class="hljs-params">(CSTree T)</span>
</span>{
	<span class="hljs-keyword">if</span>(T)
	{
		<span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d"</span>, T-&gt;data);
		PreOrderTree(T-&gt;firstchild);
		PreOrderTree(T-&gt;nextsibling);
	}
}

或者
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">PreOrderTree</span><span class="hljs-params">(CSTree T)</span>
</span>{
	<span class="hljs-keyword">if</span>(T)
	{
		<span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d"</span>, T-&gt;data);
		CSTree p;
		<span class="hljs-keyword">for</span>(p = T-&gt;firstchild; p; p = p-&gt;nextsibling)
			PreOrderTree(p);
	}
}
</div></code></pre>
<p>注意：树的<strong>先根</strong>遍历等价于二叉树的<strong>先序</strong>遍历！！！</p>
<h6 id="%E5%90%8E%E6%A0%B9%E9%81%8D%E5%8E%86">后根遍历</h6>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">PostOrderTree</span><span class="hljs-params">(CSTree T)</span>
</span>{
	<span class="hljs-keyword">if</span>(T)
	{
		PreOrderTree(T-&gt;firstchild);
		<span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d"</span>, T-&gt;data);
		PreOrderTree(T-&gt;nextsibling);
	}
}
或者
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">PostOrderTree</span><span class="hljs-params">(CSTree T)</span>
</span>{
	<span class="hljs-keyword">if</span>(T)
	{
		CSTree p;
		<span class="hljs-keyword">for</span>(p = T-&gt;firstchild; p; p = p-&gt;nextsibling)
			PreOrderTree(p);
		<span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d"</span>, T-&gt;data);
	}
}
</div></code></pre>
<p>注意：树的<strong>后根</strong>遍历等价于二叉树的<strong>中序</strong>遍历！！！</p>
<h6 id="%E5%B1%82%E6%AC%A1%E9%81%8D%E5%8E%86">层次遍历</h6>
<h4 id="534-a-name-1a%E6%A0%91%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C">5.3.4. <a name='-1'></a>树的基本操作</h4>
<h5 id="%E6%8C%89%E5%80%BC%E6%9F%A5%E6%89%BE">按值查找</h5>
<h6 id="%E7%BB%93%E7%82%B9%E5%80%BC%E4%B8%8D%E7%9B%B8%E5%90%8C">结点值不相同</h6>
<pre class="hljs"><code><div><span class="hljs-function">CSTree <span class="hljs-title">PreSearchBiT</span><span class="hljs-params">(CSTree T,ElemType e)</span>
</span>{					<span class="hljs-comment">// T是树根的地址，e是要找的结点值</span>
	<span class="hljs-keyword">if</span>(!T) 
		<span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;
	<span class="hljs-keyword">else</span>
	{
		<span class="hljs-keyword">if</span>(T-&gt;data == e)
			<span class="hljs-keyword">return</span> T;
		<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(T-&gt;firstchild)
			<span class="hljs-keyword">return</span> PreSearchBiT(T-&gt;firstchild, e);
		<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(T-&gt;nextsibling)
			<span class="hljs-keyword">return</span> PreSearchBiT(T-&gt;nextsibling, e);
	}
}
</div></code></pre>
<h6 id="%E7%BB%93%E7%82%B9%E5%80%BC%E4%BA%88%E8%AE%B8%E7%9B%B8%E5%90%8C">结点值予许相同</h6>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">PreSearchBiT</span><span class="hljs-params">(CSTree T, ElemType e, CSTree p[], <span class="hljs-keyword">int</span> *n)</span>
</span>{	<span class="hljs-comment">//T是根指针，e是要找的结点值，数组p存放的是查找结果，*n是个数</span>
	<span class="hljs-keyword">if</span>(T) 
	{	
		<span class="hljs-keyword">if</span>(T-&gt;data == e)
			p[(*n)++] = T;
		PreSearchBiT(T-&gt;firstchild, e, p, n);
		PreSearchBiT(T-&gt;nextsibling, e, p, n); 
	}
}
</div></code></pre>
<h5 id="%E6%B1%82%E6%A0%91%E7%9A%84%E6%B7%B1%E5%BA%A6">求树的深度</h5>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">Depth</span><span class="hljs-params">(CSTree T)</span>
</span>{
	<span class="hljs-keyword">int</span> d1, d2;
	<span class="hljs-keyword">if</span> (T == <span class="hljs-literal">NULL</span>)
		<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
	<span class="hljs-keyword">else</span>
	{
		d1 = Depth(T-&gt;firstchild);
		d2 = Depth(T-&gt;nextsibling);
		<span class="hljs-keyword">return</span> d1+<span class="hljs-number">1</span> &gt; d2? d1+<span class="hljs-number">1</span> : d2;
	}
}
</div></code></pre>
<h5 id="%E6%A0%91%E7%9A%84%E6%8F%92%E5%85%A5">树的插入</h5>
<pre class="hljs"><code><div>
<span class="hljs-function">CSTree <span class="hljs-title">InsertCSTree</span><span class="hljs-params">(CSTree* T, <span class="hljs-keyword">char</span> fa, <span class="hljs-keyword">char</span> ch)</span>	<span class="hljs-comment">//树的插入算法</span>
</span>{
	CSTree s, p;		<span class="hljs-comment">//s用来保存插入结点；</span>
	<span class="hljs-keyword">if</span> (*T == <span class="hljs-literal">NULL</span>)
		<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
	<span class="hljs-keyword">else</span>
	{
		<span class="hljs-keyword">if</span> (fa == (*T)-&gt;data)		<span class="hljs-comment">//找到父节点</span>
			<span class="hljs-keyword">return</span> InsertNode(T, ch);
		<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (p = InsertCSTree(&amp;((*T)-&gt;firstchild), fa, ch))
			<span class="hljs-keyword">return</span> p;
		<span class="hljs-keyword">else</span> 
			<span class="hljs-keyword">return</span> InsertCSTree(&amp;((*T)-&gt;nextsibling), fa, ch));
	}
}

<span class="hljs-function">CSTree <span class="hljs-title">InsertNode</span><span class="hljs-params">(CSTree* T, <span class="hljs-keyword">char</span> ch)</span>			<span class="hljs-comment">//寻找插入位置</span>
</span>{
	CSTree s = (CSTree)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(CSNode));
	CSTree p, q;		<span class="hljs-comment">//p，q用来寻找插入位置</span>
	s-&gt;data = ch;
	s-&gt;firstchild = s-&gt;nextsibling = <span class="hljs-literal">NULL</span>;		<span class="hljs-comment">//创建结点</span>
	
	<span class="hljs-keyword">if</span> ((*T)-&gt;firstchild == <span class="hljs-literal">NULL</span>)		<span class="hljs-comment">//插入位置恰好为第一个孩子</span>
		(*T)-&gt;firstchild = s;
	<span class="hljs-keyword">else</span>								<span class="hljs-comment">//插入不为第一个孩子</span>
	{
		p = (*T)-&gt;firstchild;
		q = p-&gt;nextsibling;
		<span class="hljs-keyword">while</span> (q)				<span class="hljs-comment">//寻找插入位置</span>
		{
			p = q;
			q = q-&gt;nextsibling;
		}	
		
		p-&gt;nextsibling = s;
		
	}
	<span class="hljs-keyword">return</span> *T;
}
</div></code></pre>
<h5 id="%E6%A0%91%E7%9A%84%E5%88%A0%E9%99%A4">树的删除</h5>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">DelNode</span><span class="hljs-params">(CSTree T)</span>
</span>{
	<span class="hljs-keyword">if</span> (T)
	{
		DelNode(T-&gt;firstchild);
		DelNode(T-&gt;nextsibling);
		<span class="hljs-built_in">free</span>(T);
	}
}

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">DelCSTree</span><span class="hljs-params">(CSTree* T, <span class="hljs-keyword">char</span> e)</span>		<span class="hljs-comment">//树的删除（删除指定结点）</span>
</span>{
	CSTree q;
	<span class="hljs-keyword">if</span> (!(*T))
		<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
	<span class="hljs-keyword">else</span>
	{
		<span class="hljs-keyword">if</span> (e == (*T)-&gt;data)
		{
			q = *T;
			*T = (*T)-&gt;nextsibling;
			q-&gt;nextsibling = <span class="hljs-literal">NULL</span>;
			DelNode(q);
			<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
		}
		DelCSTree(&amp;((*T)-&gt;firstchild), e);
		DelCSTree(&amp;((*T)-&gt;nextsibling), e);
	}
}
</div></code></pre>
<h5 id="%E8%BE%93%E5%87%BA%E6%A0%91%E4%B8%AD%E6%89%80%E6%9C%89%E4%BB%8E%E6%A0%B9%E5%88%B0%E5%8F%B6%E5%AD%90%E7%9A%84%E8%B7%AF%E5%BE%84">输出树中所有从根到叶子的路径</h5>
<pre class="hljs"><code><div><span class="hljs-comment">//求根到叶子节点路径的算法</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">LeavePath</span><span class="hljs-params">(CSTree T, LinkStack S)</span>
</span>{
	<span class="hljs-keyword">if</span> (T)
	{
		PushLinkStack(&amp;S, T-&gt;data);
		<span class="hljs-keyword">if</span> (!T-&gt;firstchild)
			PrintStack(&amp;S);				<span class="hljs-comment">//输出路径</span>
		<span class="hljs-keyword">else</span>
			<span class="hljs-keyword">for</span> (CSTree p = T-&gt;firstchild; p; p = p-&gt;nextsibling)
				LeavePath(p, S);
		PopLinkStack(&amp;S);				<span class="hljs-comment">//删除路径最后一个结点</span>
	}
}
</div></code></pre>
<h5 id="%E8%BE%93%E5%87%BA%E6%A0%91%E4%B8%AD%E4%BB%8E%E6%A0%B9%E5%88%B0%E6%8C%87%E5%AE%9A%E5%8F%B6%E5%AD%90%E7%9A%84%E8%B7%AF%E5%BE%84%E6%97%A0%E9%87%8D%E5%A4%8D">输出树中从根到指定叶子的路径（无重复）</h5>
<pre class="hljs"><code><div>
</div></code></pre>
<h5 id="%E5%87%B9%E5%85%A5%E6%B3%95%E8%BE%93%E5%87%BA">凹入法输出</h5>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dispTree</span><span class="hljs-params">(CSTree T, <span class="hljs-keyword">int</span> level)</span>
</span>{
	<span class="hljs-keyword">int</span> i, j;
	<span class="hljs-keyword">if</span> (!T)
		<span class="hljs-keyword">return</span>;
	<span class="hljs-keyword">for</span> (i = <span class="hljs-number">1</span>; i &lt; level; i++)
		<span class="hljs-built_in">putchar</span>(<span class="hljs-string">' '</span>);
	<span class="hljs-built_in">printf</span>(<span class="hljs-string">"%s+"</span>, T-&gt;CSTdata);
	<span class="hljs-keyword">for</span> (j = i + <span class="hljs-number">1</span>; j &lt; <span class="hljs-number">40</span>; j++)			<span class="hljs-comment">//j小于多少可自定义</span>
		<span class="hljs-built_in">putchar</span>(<span class="hljs-string">'-'</span>);
	<span class="hljs-built_in">putchar</span>(<span class="hljs-string">'\n'</span>);
	dispTree(T-&gt;firstchild, level + <span class="hljs-number">3</span>);		<span class="hljs-comment">// level加多少可自定义</span>
	dispTree(T-&gt;nextsibling, level);		<span class="hljs-comment">//因为兄弟结点与第一个孩子是同一层的，所以level不用变。</span>
}
</div></code></pre>
<h2 id="6-a-name-1a%E5%9B%BE">6. <a name='-1'></a>图</h2>
<h3 id="61-a-name-1a%E5%9B%BE%E7%9A%84%E4%B8%80%E4%BA%9B%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E4%B8%8E%E6%9C%AF%E8%AF%AD">6.1. <a name='-1'></a>图的一些基本概念与术语</h3>
<p>图：顶点集V+弧集E构成Graph&lt;V,E&gt;
&lt;v,w&gt;：从v到w的一条弧
P(v,w):附加到&lt;v,w&gt;的信息，一般称为权重</p>
<pre><code class="language-mermaid"><div class="mermaid">	graph LR
	图---方向
	图---完全图
	图---边分类
	图---简单图
	图---顶点
	图---网
	图---路径
	图---子图

	方向---无向图/双向图---1[顶点]
	无向图/双向图---边
	无向图/双向图---度
	无向图/双向图---生成树
	
	方向---有向图---2[顶点]
	2[顶点]---出度
	2[顶点]---入度
	有向图---弧
	有向图---生成森林
	
	完全图---wxwq[无向完全图]-->任意两个顶点之间都存在边
	完全图---yxwq[有向完全图]-->任意两个顶点之间存在方向相反的两条弧

	边分类---11[稀疏图]
	边分类---12[稠密图]
	11[稀疏图]---nlogn
	12[稠密图]---无向完全图
	12[稠密图]---有向完全图

	简单图-->无重复的边或顶点到自身的边

	顶点---邻接点
	顶点---相关联
	顶点---依附

	网-->弧或边带权的图
	弧或边带权的图---有向网
	弧或边带权的图---无向网
	

	路径---简单路径-->无重复
	路径---路径长度
	路径---回路/环
	回路/环---简单回路-->无重复
	路径---连通
	连通图-->有//极大顶点数//的//连通//子图_并且包含依附于这些顶点的所有边
	连通---连通图---强连通图
	连通---连通分量---强连通分量
	
	连通分量-->各个极大连通子图
	强连通图-->对有向图_任意两个顶点间存在*有向*路径
	强连通分量-->对有向图_其各个极大强连通子图
	
	生成树-->对连通图_n-1条边和n个顶点构成的极小连通子图
	生成森林-->对非连通图_各个连通分量的生成树集合
	
	子图-->顶点包含+边包含
	子图---连通子图
	连通子图---极小连通子图
	极小连通子图-->包含边最少且包含全部顶点的连通子图
	极小连通子图-->删除一条边就无法构成生成树
	连通子图---极大连通子图-->包含边最多且包含全部顶点的连通子图_也叫连通分量
</div></code></pre>
<h3 id="62-a-name-1a%E5%9B%BE%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84">6.2. <a name='-1'></a>图的存储结构</h3>
<h4 id="621-a-nameadjacencymatrixa%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5%E5%AD%98%E5%82%A8-adjacency-matrix">6.2.1. <a name='AdjacencyMatrix'></a>邻接矩阵存储 <strong>Adjacency Matrix</strong></h4>
<p>图的邻接矩阵：数组表示法
$$
arcs[i][j]=\begin{cases}
1\quad if(v_i,V_j)\in E\ or\  &lt;&gt;	&lt;v_i,V_j&gt;\in E\
0\quad 其他
\end{cases}
$$
网的邻接矩阵
$$
arcs[i][j]=\begin{cases}
w_{ij}\quad if(v_i,V_j)\in E\ or\ 	&lt;v_i,V_j&gt;\in E\
0\quad\ \ \  if\ \ i=j\
\infin/-1\quad 其他
\end{cases}
$$
<strong>$空间复杂度为O(n^2)$ 适用于稠密图</strong></p>
<pre><code class="language-mermaid"><div class="mermaid">	graph LR
	无向图的邻接矩阵---主对角线为0
	无向图的邻接矩阵---一定为对称矩阵
	有向图的邻接矩阵---不一定不对称_如有向完全图的邻接矩阵是对称的
	有向图的邻接矩阵---顶点i的出度---第i行元素之和
	有向图的邻接矩阵---顶点i的入度---第i列元素之和
</div></code></pre>
<h5 id="%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5%E7%9A%84%E5%AD%98%E5%82%A8%E4%BB%A3%E7%A0%81">邻接矩阵的存储代码</h5>
<pre class="hljs"><code><div><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">char</span> GElemType
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MAXSIZE 20</span>
<span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span>
{</span>
	GElemTyoe vertex[MAXSIZE];		<span class="hljs-comment">//顶点数据类型。存放顶点信息</span>
	EdgeType Edges[MAXSIZE][MAXSIZE];	<span class="hljs-comment">//边/弧的数据类型，存放顶点间的关系	</span>
	<span class="hljs-keyword">int</span> vertexNum, EdgeNum;			<span class="hljs-comment">//存放顶点和边数</span>
}MGraph;
</div></code></pre>
<h5 id="%E5%9F%BA%E4%BA%8E%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5%E5%88%9B%E5%BB%BA%E5%87%BD%E6%95%B0">基于邻接矩阵——创建函数</h5>
<h6 id="%E6%97%A0%E5%90%91%E5%9B%BE">无向图</h6>
<pre class="hljs"><code><div><span class="hljs-comment">//无向图</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">creatMGraph</span><span class="hljs-params">(MGraph *G)</span>
</span>{
	<span class="hljs-keyword">int</span> i, j, k;
	<span class="hljs-built_in">printf</span>(<span class="hljs-string">"请输入顶点数和边数:"</span>);
	<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d"</span>, &amp;G-&gt;vertexNum, &amp;G-&gt;EdgeNum);
	<span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; G-&gt;vertexNum; i++)
	{
		<span class="hljs-built_in">printf</span>(<span class="hljs-string">"请输入第%d个顶点的值: "</span>, i+<span class="hljs-number">1</span>);
		<span class="hljs-built_in">scanf</span>(&amp;G-&gt;vertex[i]);
	}
	
	<span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; G-&gt;vertexNum; i++)	<span class="hljs-comment">//初始化邻接矩阵</span>
		<span class="hljs-keyword">for</span> (j = <span class="hljs-number">0</span>; j &lt; G-&gt;vertexNum;j++)
			G-&gt;arcs[i][j] = O;
	
	<span class="hljs-keyword">for</span> (k = <span class="hljs-number">0</span>; k &lt; G-&gt;EdgeNum; k++)		<span class="hljs-comment">//依次输入每一条边</span>
	{
		<span class="hljs-built_in">printf</span>(<span class="hljs-string">"请输入第%d条边依附的两个顶点的序号: "</span>, k+<span class="hljs-number">1</span>);
		<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d"</span>, &amp;i, &amp;j);			<span class="hljs-comment">//边依附的两个顶点的序号</span>
			G-&gt;arcs[i][j] = <span class="hljs-number">1</span>; 
			G-&gt;arcs[j][i] = <span class="hljs-number">1</span>;			<span class="hljs-comment">//置有边标志</span>
	}
}
</div></code></pre>
<h6 id="%E6%97%A0%E5%90%91%E5%9B%BE">无向图</h6>
<pre class="hljs"><code><div><span class="hljs-comment">//有向图</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">creatMGraph</span><span class="hljs-params">(MGraph *G)</span>
</span>{
	<span class="hljs-keyword">int</span> i, j, k;
	<span class="hljs-built_in">printf</span>(<span class="hljs-string">"请输入顶点数和边数:"</span>);
	<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d"</span>, &amp;G-&gt;vertexNum, &amp;G-&gt;EdgeNum);
	<span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; G-&gt;vertexNum; i++)
	{
		<span class="hljs-built_in">printf</span>(<span class="hljs-string">"请输入第%d个顶点的值: "</span>, i+<span class="hljs-number">1</span>);
		<span class="hljs-built_in">scanf</span>(&amp;G-&gt;vertex[i]);
	}
	
	<span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; G-&gt;vertexNum; i++)	<span class="hljs-comment">//初始化邻接矩阵</span>
		<span class="hljs-keyword">for</span> (j = <span class="hljs-number">0</span>; j &lt; G-&gt;vertexNum;j++)
			G-&gt;arcs[i][j] = O;
	
	<span class="hljs-keyword">for</span> (k = <span class="hljs-number">0</span>; k &lt; G-&gt;EdgeNum; k++)		<span class="hljs-comment">//依次输入每一条边</span>
	{
		<span class="hljs-built_in">printf</span>(<span class="hljs-string">"请输入第%d条边依附的两个顶点的序号: "</span>, k+<span class="hljs-number">1</span>);
		<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d"</span>, &amp;i, &amp;j);			<span class="hljs-comment">//边依附的两个顶点的序号</span>
			G-&gt;arcs[i][j] = <span class="hljs-number">1</span>; 			<span class="hljs-comment">//置有边标志</span>
	}
}
</div></code></pre>
<h6 id="%E6%97%A0%E5%90%91%E7%BD%91">无向网</h6>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">creatMGraph</span><span class="hljs-params">(MGraph *G)</span>
</span>{
	<span class="hljs-keyword">int</span> i, j, k;
	<span class="hljs-keyword">int</span> w;		<span class="hljs-comment">//权值</span>
	<span class="hljs-built_in">printf</span>(<span class="hljs-string">"请输入顶点数和边数:"</span>);
	<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d"</span>, &amp;G-&gt;vertexNum, &amp;G-&gt;EdgeNum);
	<span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; G-&gt;vertexNum; i++)
	{
		<span class="hljs-built_in">printf</span>(<span class="hljs-string">"请输入第%d个顶点的值: "</span>, i+<span class="hljs-number">1</span>);
		<span class="hljs-built_in">scanf</span>(&amp;G-&gt;vertex[i]);
	}
	
	<span class="hljs-built_in">printf</span>(<span class="hljs-string">"请输入边不存在的标志："</span>);
	<span class="hljs-keyword">int</span> flag;
	<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>, &amp;flag);

	<span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; G-&gt;vertexNum; i++)	<span class="hljs-comment">//初始化邻接矩阵</span>
		<span class="hljs-keyword">for</span> (j = <span class="hljs-number">0</span>; j &lt; G-&gt;vertexNum;j++)
			<span class="hljs-keyword">if</span>(i == j) 
				G-&gt;arcs[i][j] = O;
			<span class="hljs-keyword">else</span>
				G-&gt; arcs[i][j] = flag;
	
	<span class="hljs-keyword">for</span> (k = <span class="hljs-number">0</span>; k &lt; G-&gt;EdgeNum; k++)		<span class="hljs-comment">//依次输入每一条边</span>
	{
		<span class="hljs-built_in">printf</span>(<span class="hljs-string">"请输入第%d条边的弧尾、弧头、序号和权值: "</span>, k+<span class="hljs-number">1</span>);
		<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d%d"</span>, &amp;i, &amp;j, &amp;w);	<span class="hljs-comment">//边依附的两个顶点的序号</span>
			G-&gt;arcs[i][j] = <span class="hljs-number">1</span>; 
			G-&gt;arcs[j][i] = <span class="hljs-number">1</span>;			<span class="hljs-comment">//置有边标志</span>
	}
}
</div></code></pre>
<h6 id="%E6%9C%89%E5%90%91%E7%BD%91">有向网</h6>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">creatMGraph</span><span class="hljs-params">(MGraph *G)</span>
</span>{
	<span class="hljs-keyword">int</span> i, j, k;
	<span class="hljs-keyword">int</span> w;		<span class="hljs-comment">//权值</span>
	<span class="hljs-built_in">printf</span>(<span class="hljs-string">"请输入顶点数和边数:"</span>);
	<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d"</span>, &amp;G-&gt;vertexNum, &amp;G-&gt;EdgeNum);
	<span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; G-&gt;vertexNum; i++)
	{
		<span class="hljs-built_in">printf</span>(<span class="hljs-string">"请输入第%d个顶点的值: "</span>, i+<span class="hljs-number">1</span>);
		<span class="hljs-built_in">scanf</span>(&amp;G-&gt;vertex[i]);
	}
	
	<span class="hljs-built_in">printf</span>(<span class="hljs-string">"请输入边不存在的标志："</span>);
	<span class="hljs-keyword">int</span> flag;
	<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>, &amp;flag);

	<span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; G-&gt;vertexNum; i++)	<span class="hljs-comment">//初始化邻接矩阵</span>
		<span class="hljs-keyword">for</span> (j = <span class="hljs-number">0</span>; j &lt; G-&gt;vertexNum;j++)
			<span class="hljs-keyword">if</span>(i == j) 
				G-&gt;arcs[i][j] = O;
			<span class="hljs-keyword">else</span>
				G-&gt; arcs[i][j] = flag;
	
	<span class="hljs-keyword">for</span> (k = <span class="hljs-number">0</span>; k &lt; G-&gt;EdgeNum; k++)		<span class="hljs-comment">//依次输入每一条边</span>
	{
		<span class="hljs-built_in">printf</span>(<span class="hljs-string">"请输入第%d条边的弧尾、弧头、序号和权值: "</span>, k+<span class="hljs-number">1</span>);
		<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d%d"</span>, &amp;i, &amp;j, &amp;w);	<span class="hljs-comment">//边依附的两个顶点的序号</span>
			G-&gt;arcs[i][j] = <span class="hljs-number">1</span>; 			<span class="hljs-comment">//置有边标志</span>
	}
}
</div></code></pre>
<h4 id="622-a-nameadjacencyclista%E9%82%BB%E6%8E%A5%E8%A1%A8%E5%AD%98%E5%82%A8-adjacencyc-list">6.2.2. <a name='AdjacencycList'></a>邻接表存储 <strong>Adjacencyc List</strong></h4>
<p>$$
邻接表存储=顶点表+边表\
边表：邻接于v_i的顶点链成的单链表\
顶点表：由所有边表的头指针和存储顶点信息的一维数组构成
$$
邻接表不唯一！！！
有向图邻接表：按出度建立
有向图逆邻接表：按入度建立</p>
<pre><code class="language-mermaid"><div class="mermaid">	graph LR
	无向图的邻接表---顶点i的度---顶点i的边表中结点的个数
	无向图的邻接表---顶点i的邻接点---在顶点i的边表中找/遍历
	有向图的邻接表---顶点i的出度---顶点i的边表结点的个数
	有向图的邻接表---顶点i的邻接点
	有向图的邻接表---不便于求顶点i的入度
	有向图的逆邻接表---不便于求顶点i的出度
</div></code></pre>
<p><strong>$空间复杂度为O(n+e)$适用于稀疏图</strong></p>
<h5 id="%E9%82%BB%E6%8E%A5%E8%A1%A8%E5%AD%98%E5%82%A8%E4%BB%A3%E7%A0%81">邻接表存储代码</h5>
<pre class="hljs"><code><div><span class="hljs-comment">//图的邻接表存储代码</span>
<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">char</span> GElemType
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MSXSIZE 20</span>
<span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">EdgeNode</span>
{</span>
	<span class="hljs-keyword">int</span> adjvex;		<span class="hljs-comment">//存放顶点编号</span>
	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">EdgeNode</span> *<span class="hljs-title">next</span>;</span>	<span class="hljs-comment">//链域</span>
}EdgeNode;	<span class="hljs-comment">//边表结点数据类型</span>

<span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">vertexNode</span>
{</span>
	GElemType vertex;	<span class="hljs-comment">//存放顶点值</span>
	EdgeNode *FirstEdge;	<span class="hljs-comment">//存放边表的头指针</span>
}VertexNode;		<span class="hljs-comment">//顶点表结点的数据类型</span>

<span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">algraph</span>
{</span>
	VertexNode AdjList[MAXSIZE];
	<span class="hljs-keyword">int</span> vertexNum, EdgeNum;		<span class="hljs-comment">//顶点数和边数</span>
}ALGraph;	<span class="hljs-comment">//邻接表数据类型</span>
</div></code></pre>
<pre class="hljs"><code><div><span class="hljs-comment">//网的邻接表存储代码</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MSXSIZE 20</span>
<span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">EdgeNode</span>
{</span>
	<span class="hljs-keyword">int</span> adjvex;		<span class="hljs-comment">//存放顶点编号</span>
	<span class="hljs-keyword">int</span> weight;		<span class="hljs-comment">//存放边上的权值</span>
	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">EdgeNode</span> *<span class="hljs-title">next</span>;</span>
}EdgeNode;	<span class="hljs-comment">//边表结点数据类型</span>

<span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">vertexNode</span>
{</span>
	GElemType vertex;	<span class="hljs-comment">//存放顶点值</span>
	EdgeNode *FirstEdge;	<span class="hljs-comment">//存放边表的头指针</span>
}VertexNode;		<span class="hljs-comment">//顶点表结点的数据类型</span>

<span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">algraph</span>
{</span>
	VertexNode AdjList[MAXSIZE];
	<span class="hljs-keyword">int</span> vertexNum, EdgeNum;
}ALGraph;	<span class="hljs-comment">//邻接表数据类型</span>
</div></code></pre>
<h5 id="%E5%9F%BA%E4%BA%8E%E9%82%BB%E6%8E%A5%E8%A1%A8%E5%88%9B%E5%BB%BA%E5%87%BD%E6%95%B0">基于邻接表——创建函数</h5>
<h6 id="%E6%97%A0%E5%90%91%E5%9B%BE">无向图</h6>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">CreateAlGraph</span><span class="hljs-params">(AlGraph *G)</span>
</span>{
	<span class="hljs-keyword">int</span> i, k;
	<span class="hljs-built_in">printf</span>(<span class="hljs-string">"请输入顶点数和边数："</span>);
	<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d,%d"</span>, G-&gt;vertexNum, G-&gt;EdgeNum);
	<span class="hljs-comment">//输入顶点信息，初始化边表</span>
	<span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; G-&gt;vertexNum; i++)	<span class="hljs-comment">//创建顶点表</span>
	{
		<span class="hljs-built_in">printf</span>(<span class="hljs-string">"请输入第%d个顶点信息："</span>, i+<span class="hljs-number">1</span>);
		<span class="hljs-built_in">scanf</span>(<span class="hljs-string">" "</span>,&amp;G-&gt;adjList[i].vertex);
		G-&gt;adjList[i].FirstEdge = <span class="hljs-literal">NULL</span>;
	}
	<span class="hljs-comment">//创建边表</span>
	<span class="hljs-comment">//依次输入边的信息存储在边表中</span>
	<span class="hljs-keyword">for</span>(k = <span class="hljs-number">0</span>; k &lt; G-&gt;EdgeNum; k++)
	{
		<span class="hljs-built_in">printf</span>(<span class="hljs-string">"请输入第%d条边依附的顶点编号i、j："</span>, k+<span class="hljs-number">1</span>);
		<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d"</span>, &amp;i, &amp;j);
		s = (EdgeNode*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(EdgeNode));
		s-&gt;adjvex = j;
		<span class="hljs-comment">//头插法</span>
		s-&gt;next = G-&gt;adjList[i].FirstEdge;
		G-&gt;adjList[i].FirstEdge = s;
		
		s = (EdgeNode*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(EdgeNode));
		s-&gt;adjvex = i;
		<span class="hljs-comment">//头插法</span>
		s-&gt;next = G-&gt;adjList[j].FirstEdge;
		G-&gt;adjList[j].FirstEdge = s;
	}
}
</div></code></pre>
<h6 id="%E6%9C%89%E5%90%91%E5%9B%BE">有向图</h6>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">CreateAlGraph</span><span class="hljs-params">(AlGraph *G)</span>
</span>{
	<span class="hljs-keyword">int</span> i, k;
	<span class="hljs-built_in">printf</span>(<span class="hljs-string">"请输入顶点数和边数："</span>);
	<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d,%d"</span>, G-&gt;vertexNum, G-&gt;EdgeNum);
	<span class="hljs-comment">//输入顶点信息，初始化边表</span>
	<span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; G-&gt;vertexNum; i++)	<span class="hljs-comment">//创建顶点表</span>
	{
		<span class="hljs-built_in">printf</span>(<span class="hljs-string">"请输入第%d个顶点信息："</span>, i+<span class="hljs-number">1</span>);
		<span class="hljs-built_in">scanf</span>(<span class="hljs-string">" "</span>,&amp;G-&gt;adjList[i].vertex);
		G-&gt;adjList[i].FirstEdge = <span class="hljs-literal">NULL</span>;
	}
	<span class="hljs-comment">//创建边表</span>
	<span class="hljs-comment">//依次输入边的信息存储在边表中</span>
	<span class="hljs-keyword">for</span>(k = <span class="hljs-number">0</span>; k &lt; G-&gt;EdgeNum; k++)
	{
		<span class="hljs-built_in">printf</span>(<span class="hljs-string">"请输入第%d条边依附的顶点编号i、j："</span>, k+<span class="hljs-number">1</span>);
		<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d"</span>, &amp;i, &amp;j);
		s = (EdgeNode*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(EdgeNode));
		s-&gt;adjvex = j;
		<span class="hljs-comment">//头插法</span>
		s-&gt;next = G-&gt;adjList[i].FirstEdge;
		G-&gt;adjList[i].FirstEdge = s;
	}
}
</div></code></pre>
<h6 id="%E6%97%A0%E5%90%91%E7%BD%91">无向网</h6>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">CreateAlGraph</span><span class="hljs-params">(AlGraph *G)</span>
</span>{
	<span class="hljs-keyword">int</span> i, k;
	<span class="hljs-keyword">int</span> w;
	<span class="hljs-built_in">printf</span>(<span class="hljs-string">"请输入顶点数和边数："</span>);
	<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d,%d"</span>, G-&gt;vertexNum, G-&gt;EdgeNum);
	<span class="hljs-comment">//输入顶点信息，初始化边表</span>
	<span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; G-&gt;vertexNum; i++)	<span class="hljs-comment">//创建顶点表</span>
	{
		<span class="hljs-built_in">printf</span>(<span class="hljs-string">"请输入第%d个顶点信息："</span>, i+<span class="hljs-number">1</span>);
		<span class="hljs-built_in">scanf</span>(<span class="hljs-string">" "</span>,&amp;G-&gt;adjList[i].vertex);
		G-&gt;adjList[i].FirstEdge = <span class="hljs-literal">NULL</span>;
	}
	<span class="hljs-comment">//创建边表</span>
	<span class="hljs-comment">//依次输入边的信息存储在边表中</span>
	<span class="hljs-keyword">for</span>(k = <span class="hljs-number">0</span>; k &lt; G-&gt;EdgeNum; k++)
	{
		<span class="hljs-built_in">printf</span>(<span class="hljs-string">"请输入第%d条边的弧尾、弧头、序号和权值: "</span>, k+<span class="hljs-number">1</span>);
		<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d"</span>, &amp;i, &amp;j, &amp;w);
		s = (EdgeNode*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(EdgeNode));
		s-&gt;adjvex = j;
		s-&gt;weight = w;
		<span class="hljs-comment">//头插法</span>
		s-&gt;next = G-&gt;adjList[i].FirstEdge;
		G-&gt;adjList[i].FirstEdge = s;
		
		s = (EdgeNode*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(EdgeNode));
		s-&gt;adjvex = i;
		s-&gt;weight = w;
		<span class="hljs-comment">//头插法</span>
		s-&gt;next = G-&gt;adjList[j].FirstEdge;
		G-&gt;adjList[j].FirstEdge = s;
	}
}
</div></code></pre>
<h6 id="%E6%9C%89%E5%90%91%E5%9B%BE">有向图</h6>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">CreateAlGraph</span><span class="hljs-params">(AlGraph *G)</span>
</span>{
	<span class="hljs-keyword">int</span> i, k;
	<span class="hljs-keyword">int</span> w;
	<span class="hljs-built_in">printf</span>(<span class="hljs-string">"请输入顶点数和边数："</span>);
	<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d,%d"</span>, G-&gt;vertexNum, G-&gt;EdgeNum);
	<span class="hljs-comment">//输入顶点信息，初始化边表</span>
	<span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; G-&gt;vertexNum; i++)	<span class="hljs-comment">//创建顶点表</span>
	{
		<span class="hljs-built_in">printf</span>(<span class="hljs-string">"请输入第%d个顶点信息："</span>, i+<span class="hljs-number">1</span>);
		<span class="hljs-built_in">scanf</span>(<span class="hljs-string">" "</span>,&amp;G-&gt;adjList[i].vertex);
		G-&gt;adjList[i].FirstEdge = <span class="hljs-literal">NULL</span>;
	}
	<span class="hljs-comment">//创建边表</span>
	<span class="hljs-comment">//依次输入边的信息存储在边表中</span>
	<span class="hljs-keyword">for</span>(k = <span class="hljs-number">0</span>; k &lt; G-&gt;EdgeNum; k++)
	{
		<span class="hljs-built_in">printf</span>(<span class="hljs-string">"请输入第%d条边的弧尾、弧头、序号和权值: "</span>, k+<span class="hljs-number">1</span>);
		<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d"</span>, &amp;i, &amp;j, &amp;w);
		s = (EdgeNode*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(EdgeNode));
		s-&gt;adjvex = j;
		s-&gt;weight = w;
		<span class="hljs-comment">//头插法</span>
		s-&gt;next = G-&gt;adjList[i].FirstEdge;
		G-&gt;adjList[i].FirstEdge = s;
	}
}
</div></code></pre>
<h4 id="623-a-name-1a%E5%8D%81%E5%AD%97%E9%93%BE%E8%A1%A8">6.2.3. <a name='-1'></a>十字链表</h4>
<p>整合了邻接表和逆邻接表，用于有向图。</p>
<h4 id="624-a-name-1a%E9%82%BB%E6%8E%A5%E5%A4%9A%E9%87%8D%E8%A1%A8">6.2.4. <a name='-1'></a>邻接多重表</h4>
<p>方便对边操作（删除）。</p>
<h4 id="625-a-name-1a%E8%BE%B9%E9%9B%86%E6%95%B0%E7%BB%84">6.2.5. <a name='-1'></a>边集数组</h4>
<p>$$
边集数组 \begin{cases}
顶点信息数组\
边信息数组 \begin{cases}
起点下标 \ 	begin \
终点下标 \ end \
权值 \ weight
\end{cases}
\end{cases}
$$</p>
<p>$其应用详见克鲁斯卡尔（Kruskal）算法。$</p>
<h3 id="63-a-nametraversinggrapha%E5%9B%BE%E7%9A%84%E9%81%8D%E5%8E%86-traversing-graph">6.3. <a name='TraversingGraph'></a>图的遍历 Traversing Graph</h3>
<h4 id="631-a-namedepth-firstsearchdfsa%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2depth-first-search-dfs">6.3.1. <a name='Depth-FirstSearchDFS'></a>深度优先搜索(Depth-First Search, DFS)</h4>
<h5 id="%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5%E7%9A%84%E6%B7%B1%E5%BA%A6%E9%81%8D%E5%8E%86%E7%AE%97%E6%B3%95">邻接矩阵的深度遍历算法</h5>
<pre class="hljs"><code><div><span class="hljs-comment">//邻接矩阵DFS</span>
define MAXSIZE <span class="hljs-number">9</span>
<span class="hljs-keyword">int</span> visited[MAXSIZE];	<span class="hljs-comment">//访问标志数组</span>

<span class="hljs-comment">//深度优先递归算法</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">DFS_MGraph</span><span class="hljs-params">(MGraph G, <span class="hljs-keyword">int</span> i)</span>
</span>{
	<span class="hljs-keyword">int</span> j;
	visited[i] = <span class="hljs-number">0</span>;
	<span class="hljs-built_in">printf</span>(<span class="hljs-string">"%c"</span>, G.vertex[i]);		<span class="hljs-comment">//打印顶点</span>
	<span class="hljs-keyword">for</span> (j = <span class="hljs-number">0</span>; j &lt; G.vertexNum; j++)
		<span class="hljs-keyword">if</span> (G.Edges[i][j] == <span class="hljs-number">1</span> &amp;&amp; visited[j] == <span class="hljs-number">0</span> )
			DFS_MGrapf(G, j);
}

<span class="hljs-comment">//深度遍历操作</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">DFS_Traverse</span><span class="hljs-params">(MGraph G)</span>
</span>{
	<span class="hljs-keyword">int</span> i;
	<span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; G.vertexNum; i++)
		visited[i] == <span class="hljs-number">1</span>;
	<span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; G.vertexNum; i++)
		<span class="hljs-keyword">if</span>(!visited[i])
			DFS_MGraph(G, i);
}
</div></code></pre>
<h5 id="%E9%82%BB%E6%8E%A5%E8%A1%A8%E7%9A%84%E6%B7%B1%E5%BA%A6%E9%81%8D%E5%8E%86%E7%AE%97%E6%B3%95">邻接表的深度遍历算法</h5>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">DFS_Traver</span> <span class="hljs-params">(ALGraph G, <span class="hljs-keyword">int</span> v)</span>
</span>{
	<span class="hljs-built_in">printf</span>(<span class="hljs-string">" "</span>, G.AList[v].vertex);		<span class="hljs-comment">//访问出发点</span>
	visit[v] = <span class="hljs-number">1</span>;		<span class="hljs-comment">//做标志，1为已经访问过</span>
	
	EdgeNode* p = G.AdjList[v].FirstEdge;
	<span class="hljs-keyword">while</span> (p)
	{
		<span class="hljs-keyword">if</span> (visited[p-&gt;adjvex] == <span class="hljs-number">0</span>)
			DFS_Traver (G, p-&gt;adjvex);
		p = p-&gt;next;	
	}
}	<span class="hljs-comment">//O(n+e)</span>

<span class="hljs-comment">//or</span>
	<span class="hljs-comment">//邻接表深度优先递归算法</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">DFS</span><span class="hljs-params">(ALGraph GL, <span class="hljs-keyword">int</span> i)</span>
</span>{
	EdgeNode* p;
	visited[i] = <span class="hljs-number">0</span>;
	<span class="hljs-built_in">printf</span>(<span class="hljs-string">"%c"</span>, GL.AdjList[i].vertex);
	p = GL.AdjList[i].FirstEdge;
	<span class="hljs-keyword">while</span> (p)
	{
		<span class="hljs-keyword">if</span> (visited[p-&gt;adjvex] == <span class="hljs-number">0</span>)
			DFS(GL, p-&gt;adjvex)
		p = p-&gt;next;
	}
}
	<span class="hljs-comment">//深度优先遍历操作</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">DFS_Traverse</span><span class="hljs-params">(ALGraph Gl)</span>
</span>{
	<span class="hljs-keyword">int</span> i;
	<span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; GL.vertexNum; i++)
		visited[i] = <span class="hljs-number">1</span>;
	<span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; GL.vertexNum; i++)
		<span class="hljs-keyword">if</span> (visited[i] ==<span class="hljs-number">0</span>)
			DFS(GL, i);
}
</div></code></pre>
<h4 id="632-a-namebreadth-firstsearchbfsa%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2breadth-first-search-bfs">6.3.2. <a name='Breadth-FirstSearchBFS'></a>广度优先搜索(Breadth-First Search, BFS)</h4>
<p>类似于<em>树的层次遍历</em>，需要借助<strong>队列</strong>。</p>
<h5 id="%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5%E7%9A%84%E5%B9%BF%E5%BA%A6%E9%81%8D%E5%8E%86%E7%AE%97%E6%B3%95">邻接矩阵的广度遍历算法</h5>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">BFS_Traver</span> <span class="hljs-params">(MGraph G)</span>
</span>{
	<span class="hljs-keyword">int</span> i, j;		<span class="hljs-comment">//i为行，j为列</span>
	Queue Q;
	InitQueue(&amp;Q);
	<span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; G.vertexNum; i++)
	{
		<span class="hljs-keyword">if</span> (visited[i] == <span class="hljs-number">0</span>)	<span class="hljs-comment">//顶点未被访问</span>
		{
			visited[i] = <span class="hljs-number">1</span>;		<span class="hljs-comment">//标记访问</span>
			<span class="hljs-built_in">printf</span>(<span class="hljs-string">"%c "</span>, &amp;G.vertex[i]);	<span class="hljs-comment">//打印顶点</span>
			EnQueue(&amp;Q, i);		<span class="hljs-comment">//顶点入队</span>
			<span class="hljs-keyword">while</span> (!IsQueueEmpty(Q))
			{
				i = DeQueue(&amp;Q);	<span class="hljs-comment">//取对头后出队</span>
				<span class="hljs-keyword">for</span> (j = <span class="hljs-number">0</span>; j &lt; G.vertexNum; j++)	<span class="hljs-comment">//判断其他顶点与当前顶点是否存在边；</span>
													<span class="hljs-comment">//并且未被访问过</span>
					<span class="hljs-keyword">if</span> (G.Edges[i][j] == <span class="hljs-number">1</span> &amp;&amp; visited[j] ==<span class="hljs-number">0</span>)	
					{
						visited[j] = <span class="hljs-number">1</span>;			<span class="hljs-comment">//标记访问</span>
						<span class="hljs-built_in">printf</span>(<span class="hljs-string">"%c "</span>, &amp;G.vertex[j]);	<span class="hljs-comment">//打印顶点</span>
						EnQueue(&amp;Q, j);		<span class="hljs-comment">//顶点入队</span>
					}
			}
		}
	}
}
</div></code></pre>
<h5 id="%E9%82%BB%E6%8E%A5%E8%A1%A8%E7%9A%84%E5%B9%BF%E5%BA%A6%E9%81%8D%E5%8E%86%E7%AE%97%E6%B3%95">邻接表的广度遍历算法</h5>
<pre class="hljs"><code><div><span class="hljs-comment">//邻接表的广度遍历算法</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">BFS_Traver</span> <span class="hljs-params">(AdjGraph G, <span class="hljs-keyword">int</span> v)</span>
</span>{
	Queue Q;
	InitQueue(&amp;Q);
	<span class="hljs-built_in">printf</span>(<span class="hljs-string">" "</span>, G.AdjList[v].vertex);			<span class="hljs-comment">//打印顶点</span>
	visited[v] = <span class="hljs-number">1</span>;
	EnQueue(&amp;Q, v);
	whlie(!IsQueueEmpty(Q))
	{
		v = DeQueue(&amp;Q);
		EdgeNode* p = G.AdjList[v].FirstEdge;	<span class="hljs-comment">//取v的邻接点</span>
		<span class="hljs-keyword">while</span> (p)
		{
			<span class="hljs-keyword">if</span> (visit[p-&gt;adjvex] == <span class="hljs-number">0</span>)			<span class="hljs-comment">//若此顶点未被访问</span>
			{
				<span class="hljs-built_in">printf</span>(<span class="hljs-string">" "</span>, G.AdjList[p-&gt;adjvex].vextex);
				visited[p-&gt;adjvex] = <span class="hljs-number">1</span>;			<span class="hljs-comment">//标记已访问</span>
				EnQueue(&amp;Q, p-&gt;adjvex);			<span class="hljs-comment">//将该顶点入队</span>
			}
			p = p-&gt;next;						<span class="hljs-comment">//指针指向下一个邻接点</span>
		}
	}
}
</div></code></pre>
<h3 id="64-a-nameminimumcostspanningtreea%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91-minimum-cost-spanning-tree">6.4. <a name='MinimumCostSpanningTree'></a>最小生成树 Minimum Cost Spanning Tree</h3>
<p>最小生成树:构造连通网的最小代价生成树</p>
<h4 id="641-a-nameprimsalgorithma%E6%99%AE%E9%87%8C%E5%A7%86%E7%AE%97%E6%B3%95-prims-algorithm">6.4.1. <a name='PrimsAlgorithm'></a>普里姆算法 Prim's Algorithm</h4>
<p>借助网的邻接矩阵</p>
<pre class="hljs"><code><div><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> INFINITY 66666</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MAXVEX 10	<span class="hljs-comment">//顶点个数最大值</span></span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">MiniSpanTree_Prim</span><span class="hljs-params">(MGrapf)</span>
</span>{
	<span class="hljs-keyword">int</span> min, i, j, k;
	<span class="hljs-keyword">int</span> adjvex[MAXVEX];		<span class="hljs-comment">//保存起点下标</span>
	<span class="hljs-keyword">int</span> lowcost[MAXVEX];	<span class="hljs-comment">//保存下标为起点到终点间的权值</span>
	adjvex[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;			<span class="hljs-comment">//初始化第一个顶点下标为0</span>
	lowcost[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;			<span class="hljs-comment">//初始化第一个权值为0,即v0加入生成树</span>

	<span class="hljs-keyword">for</span> (i = <span class="hljs-number">1</span>; i &lt; G.vertexNum; i++)		<span class="hljs-comment">//遍历除下标为0以外的全部顶点</span>
	{
		adjvex[i] = <span class="hljs-number">0</span>;				<span class="hljs-comment">//初始化默认v0为起点</span>
		lowcost[i] = G.Edges[<span class="hljs-number">0</span>][i];	<span class="hljs-comment">//将v0顶点与之有边的权值存入数组</span>
	}

	<span class="hljs-keyword">for</span> (i = <span class="hljs-number">1</span>; i &lt; G.vertexNum; i++)	<span class="hljs-comment">//循环全部顶点,找最小的权值边</span>
	{
		min = INFINITY;		<span class="hljs-comment">//初始化最小权值为INFINITY</span>
		j = <span class="hljs-number">1</span>;				<span class="hljs-comment">//j用来循环自增</span>
		k = <span class="hljs-number">0</span>;				<span class="hljs-comment">//k用来标记最小权值终点的位置</span>
		<span class="hljs-keyword">while</span> (j &lt; G.vertexNum)
		{
			<span class="hljs-keyword">if</span> (lowcost[j] != <span class="hljs-number">0</span> &amp;&amp; lowcost[j] &lt; min)
			{		<span class="hljs-comment">//如果权值为0并且还小于min</span>
				min = lowcost[j];	<span class="hljs-comment">//更新最小权值</span>
				k = j;				<span class="hljs-comment">//标记最小权值终点位置,以便下一个循环遍历邻接矩阵第k行</span>
			}
			j++;
		}
		
		<span class="hljs-built_in">printf</span>(<span class="hljs-string">"(%d,%d)\n"</span>, adjvex[k], k);		<span class="hljs-comment">//打印边(起点,终点)</span>
		lowcost[k] = <span class="hljs-number">0</span>;							<span class="hljs-comment">//将当前最小权值起点的权值置为0,表示该顶点已放入最小生成树中,后续不再对该顶点进行操作</span>

		<span class="hljs-keyword">for</span> (j = <span class="hljs-number">0</span>; j &lt; G.vertexNum; j++)		<span class="hljs-comment">//从上一次的顶点开始,循环全部顶点,更新权值数组</span>
		{
			<span class="hljs-keyword">if</span> (lowcost[j] != <span class="hljs-number">0</span> &amp;&amp; G.Edges[k][j] &lt; lowcost[j])		<span class="hljs-comment">//如果顶点未放入生成树 并且 各边权值小于未被加入生成树的顶点权值</span>
			{
				lowcost[j] = G.Edges[k][j];		<span class="hljs-comment">//将较小的权值存入权值数组</span>
				adjvex[j] = k;					<span class="hljs-comment">//更新起点下标</span>
			}
		}	<span class="hljs-comment">//这里的lowcost[]数组保存了上一次起点各未加入边的最小权值以及当前顶点各未遍历边的最小权值</span>
	}
}	<span class="hljs-comment">//O(n^2)</span>
</div></code></pre>
<p>$算法的基本思想为:G(V,E)为连通网,假设U是V的一个非空子集,TE为最小生成树中边的集合,(u,v)是一条最小权值的边, \
如果u\in U,v\in U-V,那么必有(u,v)在最下生成树里.$$从U=\left{u_0\right}开始,TE=\left{\right}开始,重复一下操作:\
在所有{u}\in {U},\ {v}\in {U-V} \ 里找一条权值最小的边\left{u_0,v_0\right}并入TE,同时v_0并入U,
直至U = V为止.此时U中必有n-1条边.最后T = \left(V,\left{TE\right}\right)为最小生成树.$</p>
<p>Step:</p>
<ol>
<li>记录当前U集合的状态</li>
<li>选择最小边以及权值加入到U集合中</li>
</ol>
<p>$$完整代码$$</p>
<pre class="hljs"><code><div><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span>

<span class="hljs-comment">/**
 * 图顶点之前不通，那么邻接矩阵的值为MAX
 * 如果顶点是自己本身，那么值为0
 */</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MAX 32767</span>

<span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Graph</span> {</span>
    <span class="hljs-keyword">char</span>* vexs;		<span class="hljs-comment">//</span>
    <span class="hljs-keyword">int</span>** arcs;		<span class="hljs-comment">//二维数组</span>
    <span class="hljs-keyword">int</span> vexNum;
    <span class="hljs-keyword">int</span> arcNum;
}Graph;

<span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Edge</span> {</span>		
    <span class="hljs-keyword">char</span> vex;		<span class="hljs-comment">//记录U集合到最小边的起始节点</span>
    <span class="hljs-keyword">int</span> weight;		<span class="hljs-comment">//记录最小边</span>
}Edge;

<span class="hljs-comment">/**
 * 当edge.weight = 0时，代表顶点加入到U集合中
 */</span> 
<span class="hljs-function">Edge* <span class="hljs-title">initEdeg</span><span class="hljs-params">(Graph* G, <span class="hljs-keyword">int</span> index)</span> </span>{
    Edge* edge = (Edge*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(Edge) * G -&gt; vexNum);
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; G -&gt;vexNum; i++) {
        edge[i].vex = G -&gt; vexs[index]; 
        edge[i].weight = G -&gt; arcs[index][i];
    }
    <span class="hljs-keyword">return</span> edge;
}

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getMinEdge</span><span class="hljs-params">(Edge* edge, Graph* G)</span> </span>{		<span class="hljs-comment">//返回最小边的终点点位置下标</span>
    <span class="hljs-keyword">int</span> index;
    <span class="hljs-keyword">int</span> min = MAX;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; G -&gt; vexNum; i++) {
        <span class="hljs-keyword">if</span> (edge[i].weight != <span class="hljs-number">0</span> &amp;&amp; edge[i].weight &lt; min ) {
            min = edge[i].weight;
            index = i;
        }
    }
    <span class="hljs-keyword">return</span> index;
}

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">prim</span><span class="hljs-params">(Graph* G, <span class="hljs-keyword">int</span> index)</span> </span>{		<span class="hljs-comment">//Prim算法的实现  index表示从哪个结点开始</span>
    <span class="hljs-keyword">int</span> min;		<span class="hljs-comment">//记录最小权值</span>
	<span class="hljs-keyword">int</span> seleted[MAXSIZE] = { <span class="hljs-number">0</span> };	<span class="hljs-comment">//标记已经加入集合U的顶点,避免重复加入相同的边</span>
	seleted[index] = <span class="hljs-number">1</span>;		<span class="hljs-comment">//源点已加入集合U</span>
    Edge* edge = initEdeg(G, index);	<span class="hljs-comment">//初始化边数组</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; G -&gt; vexNum - <span class="hljs-number">1</span>; i++) {		<span class="hljs-comment">//已经加入一个顶点,所以只需要遍历n-1次</span>
        min = getMinEdge(edge, G);		<span class="hljs-comment">//取最小</span>
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"v%c --&gt; v%c, weight = %d\n"</span>, edge[min].vex, G -&gt; vexs[min], edge[min].weight);		<span class="hljs-comment">//打印最小生成树结点信息</span>
        edge[min].weight = <span class="hljs-number">0</span>;		<span class="hljs-comment">//权值为0表示加入到U集合</span>
		seleted[min] = <span class="hljs-number">1</span>;		<span class="hljs-comment">//标志终点已经加入集合U</span>
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; G -&gt; vexNum; j++) {		<span class="hljs-comment">//更新权值信息,再循环一次</span>
            <span class="hljs-keyword">if</span> (G -&gt; arcs[min][j] &lt; edge[j].weight) {	<span class="hljs-comment">//仅对权值更小的边起点作更新</span>
                edge[j].weight = G -&gt; arcs[min][j];		<span class="hljs-comment">//更新权值</span>
                edge[j].vex = G -&gt; vexs[min];			<span class="hljs-comment">//更新起点</span>
            }
        }
    }
} 

<span class="hljs-function">Graph* <span class="hljs-title">initGraph</span><span class="hljs-params">(<span class="hljs-keyword">int</span> vexNum)</span> </span>{
    Graph* G = (Graph*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(Graph));
    G -&gt; vexs = (<span class="hljs-keyword">char</span>*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">char</span>) * vexNum);
    G -&gt; arcs = (<span class="hljs-keyword">int</span>**)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>*) * vexNum);
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span> ; i &lt; vexNum; i++) {
        G -&gt; arcs[i] = (<span class="hljs-keyword">int</span>*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>) * vexNum);
    }
    G -&gt; vexNum = vexNum;
    G -&gt; arcNum = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">return</span> G;
}

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">createGraph</span><span class="hljs-params">(Graph* G, <span class="hljs-keyword">char</span>* vexs, <span class="hljs-keyword">int</span>* arcs)</span> </span>{
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span> ; i &lt; G -&gt; vexNum; i++) {
        G -&gt; vexs[i] = vexs[i];
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; G -&gt; vexNum; j++) {
            G -&gt; arcs[i][j] = *(arcs + i * G -&gt; vexNum + j);
            <span class="hljs-keyword">if</span> (G -&gt; arcs[i][j] != <span class="hljs-number">0</span> &amp;&amp; G -&gt; arcs[i][j] != MAX)  
                G -&gt; arcNum ++;
        }
    }
    G -&gt; arcNum /= <span class="hljs-number">2</span>;
}

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">DFS</span><span class="hljs-params">(Graph* G, <span class="hljs-keyword">int</span>* visited, <span class="hljs-keyword">int</span> index)</span> </span>{
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%c\t"</span>, G -&gt; vexs[index]);
    visited[index] = <span class="hljs-number">1</span>;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; G -&gt;vexNum; i++) {
        <span class="hljs-keyword">if</span> (G -&gt; arcs[index][i] &gt; <span class="hljs-number">0</span> &amp;&amp; G -&gt; arcs[index][i] != MAX &amp;&amp; !visited[i]) {
            DFS(G, visited, i);
        }
    }
}

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
    Graph* G = initGraph(<span class="hljs-number">6</span>);
    <span class="hljs-keyword">int</span>* visited = (<span class="hljs-keyword">int</span>*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>) * G -&gt; vexNum);
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; G -&gt; vexNum; i++)
        visited[i] = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">int</span> arcs[<span class="hljs-number">6</span>][<span class="hljs-number">6</span>] = {
        <span class="hljs-number">0</span>, <span class="hljs-number">6</span>, <span class="hljs-number">1</span>, <span class="hljs-number">5</span>, MAX, MAX,
        <span class="hljs-number">6</span>, <span class="hljs-number">0</span>, <span class="hljs-number">5</span>, MAX, <span class="hljs-number">3</span>, MAX,
        <span class="hljs-number">1</span>, <span class="hljs-number">5</span>, <span class="hljs-number">0</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">4</span>,
        <span class="hljs-number">5</span>, MAX, <span class="hljs-number">5</span>, <span class="hljs-number">0</span>, MAX, <span class="hljs-number">2</span>,
        MAX, <span class="hljs-number">3</span>, <span class="hljs-number">6</span>, MAX, <span class="hljs-number">0</span>, <span class="hljs-number">6</span>,
        MAX, MAX, <span class="hljs-number">4</span>, <span class="hljs-number">2</span>, <span class="hljs-number">6</span>, <span class="hljs-number">0</span>
    };
    createGraph(G, <span class="hljs-string">"123456"</span>, (<span class="hljs-keyword">int</span>*)arcs);
    DFS(G, visited, <span class="hljs-number">0</span>);
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n"</span>);
    prim(G, <span class="hljs-number">0</span>);
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</div></code></pre>
<h4 id="642-a-namekruskalsalgorithma%E5%85%8B%E9%B2%81%E6%96%AF%E5%8D%A1%E5%B0%94%E7%AE%97%E6%B3%95-kruskals-algorithm">6.4.2. <a name='KruskalsAlgorithm'></a>克鲁斯卡尔算法 Kruskal's Algorithm</h4>
<p>以边为目标去构建最小生成树
首先需要一个边集数组</p>
<pre class="hljs"><code><div><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Edge</span>
{</span>
	<span class="hljs-keyword">int</span> begin;	<span class="hljs-comment">//起点</span>
	<span class="hljs-keyword">int</span> end;	<span class="hljs-comment">//终点</span>
	<span class="hljs-keyword">int</span> weight;	<span class="hljs-comment">//权值</span>
}Edge;
<span class="hljs-comment">//初始化边集数组</span>
<span class="hljs-function">Edge* <span class="hljs-title">initEdge</span><span class="hljs-params">(MGraph *G)</span>
</span>{
	<span class="hljs-keyword">int</span> i, j;
	<span class="hljs-keyword">int</span> index;
	Edge* edges = (Edge*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(Edge) * G-&gt;vertexNum);
	<span class="hljs-keyword">for</span> ( i = <span class="hljs-number">0</span>; i &lt; G.numVertexes<span class="hljs-number">-1</span>; i++)			<span class="hljs-comment">//只有n-1条边</span>
	{
		<span class="hljs-keyword">for</span> (j = i + <span class="hljs-number">1</span>; j &lt; G.numVertexes; j++)		<span class="hljs-comment">//从i+1开始,避免了同一条边重复加入边集数组</span>
		{
			<span class="hljs-keyword">if</span> (G.arc[i][j] &lt; GRAPH_INFINITY)		<span class="hljs-comment">//vi,vj之间存在边,将信息存入边集数组</span>
			{
				edges[index].begin = i;
				edges[index].end = j;
				edges[index].weight = G.arc[i][j];
				index++;
			}
		}
	}
	<span class="hljs-keyword">return</span> edges;
}
</div></code></pre>
<p>然后要对边集数组中应该按权值从小到大的顺序排列</p>
<pre class="hljs"><code><div><span class="hljs-comment">/* 对权值进行排序 */</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">sort</span><span class="hljs-params">(Edge *edges,MGraph *G)</span>
</span>{
	Edge temp;	<span class="hljs-comment">//结构体也可以直接复制</span>
	<span class="hljs-keyword">int</span> i, j;
	<span class="hljs-keyword">for</span> ( i = <span class="hljs-number">0</span>; i &lt; G-&gt;numEdges; i++)
	{
		<span class="hljs-keyword">for</span> ( j = i + <span class="hljs-number">1</span>; j &lt; G-&gt;numEdges; j++)
		{
			<span class="hljs-keyword">if</span> (edges[i].weight &gt; edges[j].weight)
			{
				temp = edge[i];
				edge[i] = edge[j];
				edge[j] = tmep;
			}
		}
	}
	<span class="hljs-built_in">printf</span>(<span class="hljs-string">"权排序之后的为:\n"</span>);
	<span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; G-&gt;numEdges; i++)
	{
		<span class="hljs-built_in">printf</span>(<span class="hljs-string">"(%d, %d) %d\n"</span>, edges[i].begin, edges[i].end, edges[i].weight);
	}
}
</div></code></pre>
<p>最后是Kruskal算法的实现
在加边的过程中,要判断图是否连通
此时需要一个辅助数组,来记录当前索引结点属于哪个连通分量
这里规定将第一个结点作为后续加入结点的连通分量,即后续加结点进来的时候,连通分量都统一为始节点</p>
<pre class="hljs"><code><div><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MAXEDGE 20</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MAXVEX 20</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> GRAPH_INFINITY 65535</span>

<span class="hljs-comment">/* 查找连线顶点的尾部下标 */</span>
<span class="hljs-comment">//规定当parent[i]=0时表示在已经加入最小生成树的顶点集中vi为尾部,即只有一个邻接点</span>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">Find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *parent, <span class="hljs-keyword">int</span> f)</span>
</span>{
	<span class="hljs-keyword">while</span> ( parent[f] &gt; <span class="hljs-number">0</span>)		<span class="hljs-comment">//这个循环的作用在于找出尾部顶点</span>
	{
		f = parent[f];
	}
	<span class="hljs-keyword">return</span> f;
}

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">MST_Kruskal</span><span class="hljs-params">(MGraph G)</span>
</span>{
	<span class="hljs-keyword">int</span> i, j, n, m;
	<span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>;
	<span class="hljs-keyword">int</span> parent[MAXVEX];<span class="hljs-comment">/* 定义一数组用来判断边与边是否形成环路 */</span>
	
	<span class="hljs-comment">/* 用来构建边集数组并排序********************* */</span>
	Edge *edges = initEdge(G);<span class="hljs-comment">/* 定义边集数组,edge的结构为begin,end,weight,均为整型 */</span>
	sort(edges, &amp;G);	<span class="hljs-comment">//对边集数组进行排序</span>
	<span class="hljs-comment">/* ******************************************* */</span>

	<span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; G.numVertexes; i++)		<span class="hljs-comment">//一开始最小生成树顶点集中还没有度为2的结点</span>
		parent[i] = <span class="hljs-number">0</span>;	<span class="hljs-comment">/* 初始化数组值为0 */</span>

	<span class="hljs-built_in">printf</span>(<span class="hljs-string">"打印最小生成树：\n"</span>);
	<span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; G.numEdges; i++)	<span class="hljs-comment">/* 循环每一条边 */</span>
	{
		n = Find(parent,edges[i].begin);	<span class="hljs-comment">//找到顶点集中的尾部顶点</span>
		m = Find(parent,edges[i].end);		<span class="hljs-comment">//若end恰为尾部顶点,则说明形成回路</span>
		<span class="hljs-keyword">if</span> (n != m) <span class="hljs-comment">/* 假如n与m不等，说明此边没有与现有的生成树形成环路 */</span>
		{
			parent[n] = m;	<span class="hljs-comment">/* 将此边的结尾顶点放入下标为起点的parent中。 */</span>
							<span class="hljs-comment">/* 表示此顶点已经在生成树集合中 */</span>
			<span class="hljs-built_in">printf</span>(<span class="hljs-string">"(%d, %d) %d\n"</span>, edges[i].begin, edges[i].end, edges[i].weight);
		}
	}
}
</div></code></pre>
<p>$$完整程序$$</p>
<pre class="hljs"><code><div><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span>

<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MAX 32767</span>

<span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Graph</span> {</span>
    <span class="hljs-keyword">char</span>* vexs;
    <span class="hljs-keyword">int</span>** arcs;
    <span class="hljs-keyword">int</span> vexNum;
    <span class="hljs-keyword">int</span> arcNum;
}Graph;

<span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Edge</span> {</span>
    <span class="hljs-keyword">int</span> start;
    <span class="hljs-keyword">int</span> end;
    <span class="hljs-keyword">int</span> weight;
}Edge;

<span class="hljs-function">Edge* <span class="hljs-title">initEdge</span><span class="hljs-params">(Graph* G)</span> </span>{
    <span class="hljs-keyword">int</span> index = <span class="hljs-number">0</span>;
    Edge* edge = (Edge*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(Edge) * G -&gt; arcNum);
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; G -&gt; vexNum; i++) {
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = i + <span class="hljs-number">1</span>; j &lt; G -&gt; vexNum; j++) {
            <span class="hljs-keyword">if</span> (G -&gt; arcs[i][j] != MAX) {
                edge[index].start = i;
                edge[index].end = j;
                edge[index].weight = G -&gt; arcs[i][j];
                index++;
            }
        }
    }
    <span class="hljs-keyword">return</span> edge;
}

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">sortEdge</span><span class="hljs-params">(Edge* edge, Graph* G)</span> </span>{
    Edge temp;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; G -&gt; arcNum - <span class="hljs-number">1</span>; i++) {
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; G -&gt; arcNum - i - <span class="hljs-number">1</span>; j++) {
            <span class="hljs-keyword">if</span> (edge[j].weight &gt; edge[j + <span class="hljs-number">1</span>].weight) {
                temp = edge[j];
                edge[j] = edge[j + <span class="hljs-number">1</span>];
                edge[j + <span class="hljs-number">1</span>] = temp;
            }
        }
    }
}

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">kruskal</span><span class="hljs-params">(Graph* G)</span> </span>{
    <span class="hljs-keyword">int</span>* connected = (<span class="hljs-keyword">int</span>*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>) * G -&gt; vexNum);
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span> ; i &lt; G -&gt; vexNum; i++) {
        connected[i] = i;		<span class="hljs-comment">//规定一开始的连通分量是自己</span>
    }
    Edge* edge = initEdge(G);
    sortEdge(edge, G);
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; G -&gt; arcNum; i++) {
        <span class="hljs-keyword">int</span> start = connected[edge[i].start];
        <span class="hljs-keyword">int</span> end = connected[edge[i].end];
        <span class="hljs-keyword">if</span> (start != end) {
            <span class="hljs-built_in">printf</span>(<span class="hljs-string">"v%c --&gt; v%c weight = %d\n"</span>, G -&gt; vexs[edge[i].start], G -&gt; vexs[edge[i].end], edge[i].weight);
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; G -&gt; vexNum; j++) {
                <span class="hljs-keyword">if</span> (connected[j] == end) {
                    connected[j] = start;
                }
            }
        }
    }
}

<span class="hljs-function">Graph* <span class="hljs-title">initGraph</span><span class="hljs-params">(<span class="hljs-keyword">int</span> vexNum)</span> </span>{
    Graph* G = (Graph*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(Graph));
    G -&gt; vexs = (<span class="hljs-keyword">char</span>*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">char</span>) * vexNum);
    G -&gt; arcs = (<span class="hljs-keyword">int</span>**)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>*) * vexNum);
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span> ; i &lt; vexNum; i++) {
        G -&gt; arcs[i] = (<span class="hljs-keyword">int</span>*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>) * vexNum);
    }
    G -&gt; vexNum = vexNum;
    G -&gt; arcNum = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">return</span> G;
}

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">createGraph</span><span class="hljs-params">(Graph* G, <span class="hljs-keyword">char</span>* vexs, <span class="hljs-keyword">int</span>* arcs)</span> </span>{
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span> ; i &lt; G -&gt; vexNum; i++) {
        G -&gt; vexs[i] = vexs[i];
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; G -&gt; vexNum; j++) {
            G -&gt; arcs[i][j] = *(arcs + i * G -&gt; vexNum + j);
            <span class="hljs-keyword">if</span> (G -&gt; arcs[i][j] != <span class="hljs-number">0</span> &amp;&amp; G -&gt; arcs[i][j] != MAX)
                G -&gt; arcNum ++;
        }
    }
    G -&gt; arcNum /= <span class="hljs-number">2</span>;
}

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">DFS</span><span class="hljs-params">(Graph* G, <span class="hljs-keyword">int</span>* visited, <span class="hljs-keyword">int</span> index)</span> </span>{
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%c\t"</span>, G -&gt; vexs[index]);
    visited[index] = <span class="hljs-number">1</span>;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; G -&gt;vexNum; i++) {
        <span class="hljs-keyword">if</span> (G -&gt; arcs[index][i] &gt; <span class="hljs-number">0</span> &amp;&amp; G -&gt; arcs[index][i] != MAX &amp;&amp; !visited[i]) {
            DFS(G, visited, i);
        }
    }
}

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
    Graph* G = initGraph(<span class="hljs-number">6</span>);
    <span class="hljs-keyword">int</span>* visited = (<span class="hljs-keyword">int</span>*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>) * G -&gt; vexNum);
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; G -&gt; vexNum; i++)
        visited[i] = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">int</span> arcs[<span class="hljs-number">6</span>][<span class="hljs-number">6</span>] = {
        <span class="hljs-number">0</span>, <span class="hljs-number">6</span>, <span class="hljs-number">1</span>, <span class="hljs-number">5</span>, MAX, MAX,
        <span class="hljs-number">6</span>, <span class="hljs-number">0</span>, <span class="hljs-number">5</span>, MAX, <span class="hljs-number">3</span>, MAX,
        <span class="hljs-number">1</span>, <span class="hljs-number">5</span>, <span class="hljs-number">0</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">4</span>,
        <span class="hljs-number">5</span>, MAX, <span class="hljs-number">5</span>, <span class="hljs-number">0</span>, MAX, <span class="hljs-number">2</span>,
        MAX, <span class="hljs-number">3</span>, <span class="hljs-number">6</span>, MAX, <span class="hljs-number">0</span>, <span class="hljs-number">6</span>,
        MAX, MAX, <span class="hljs-number">4</span>, <span class="hljs-number">2</span>, <span class="hljs-number">6</span>, <span class="hljs-number">0</span>
    };
    createGraph(G, <span class="hljs-string">"123456"</span>, (<span class="hljs-keyword">int</span>*)arcs);
    DFS(G, visited, <span class="hljs-number">0</span>);
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n"</span>);
    kruskal(G);
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</div></code></pre>
<p>$$
总结:最小生成树 \begin{cases}
普里姆(Prim)算法
\begin{cases}
O(n^2)\
适用于稠密图\
\end{cases} \
克鲁斯卡尔(Kruskal)算法
\begin{cases}
O(eloge),\ e为边数\
适用于稀疏图\
\end{cases} \
\end{cases}
$$</p>
<h3 id="65-a-name-1a%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84">6.5. <a name='-1'></a>最短路径</h3>
<h4 id="651-a-namedijkstrasalgorithma%E8%BF%AA%E6%9D%B0%E6%96%AF%E7%89%B9%E6%8B%89%E7%AE%97%E6%B3%95-dijkstras-algorithm">6.5.1. <a name='DijkstrasAlgorithm'></a>迪杰斯特拉算法 Dijkstra's Algorithm</h4>
<pre class="hljs"><code><div><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MAXEDGE 20</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MAXVEX 20</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> GRAPH_INFINITY 65535</span>
<span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span>
{</span>
	<span class="hljs-keyword">int</span> vexs[MAXVEX];
	<span class="hljs-keyword">int</span> arc[MAXVEX][MAXVEX];
	<span class="hljs-keyword">int</span> numVertexes, numEdges;
}MGraph;

<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">int</span> Patharc[MAXVEX];    <span class="hljs-comment">/* 用于存储最短路径下标的数组 */</span>
<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">int</span> ShortPathTable[MAXVEX];<span class="hljs-comment">/* 用于存储到各点最短路径的权值和 */</span> 
<span class="hljs-comment">/*  Dijkstra算法，求有向网G的v0顶点到其余顶点v的最短路径P[v]及带权长度D[v] */</span>    
<span class="hljs-comment">/*  P[v]的值为前驱顶点下标,D[v]表示v0到v的最短路径长度和 */</span>  
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">ShortestPath_Dijkstra</span><span class="hljs-params">(MGraph G, <span class="hljs-keyword">int</span> v0, Patharc *P, ShortPathTable *D)</span>
</span>{    
	<span class="hljs-keyword">int</span> v,w,k,min;    
	<span class="hljs-keyword">int</span> <span class="hljs-keyword">final</span>[MAXVEX];<span class="hljs-comment">/* final[w]=1表示求得顶点v0至vw的最短路径 */</span>
	<span class="hljs-keyword">for</span>(v=<span class="hljs-number">0</span>; v&lt;G.numVertexes; v++)    <span class="hljs-comment">/* 初始化数据 */</span>
	{        
		<span class="hljs-keyword">final</span>[v] = <span class="hljs-number">0</span>;			<span class="hljs-comment">/* 全部顶点初始化为未知最短路径状态 */</span>
		(*D)[v] = G.arc[v0][v];<span class="hljs-comment">/* 将与v0点有连线的顶点加上权值 */</span>
		(*P)[v] = <span class="hljs-number">-1</span>;				<span class="hljs-comment">/* 初始化路径数组P为-1  */</span>       
	}

	(*D)[v0] = <span class="hljs-number">0</span>;  <span class="hljs-comment">/* v0至v0路径为0 */</span>  
	<span class="hljs-keyword">final</span>[v0] = <span class="hljs-number">1</span>;    <span class="hljs-comment">/* v0至v0不需要求路径 */</span>        
	<span class="hljs-comment">/* 开始主循环，每次求得v0到某个v顶点的最短路径 */</span>   
	<span class="hljs-keyword">for</span>(v=<span class="hljs-number">1</span>; v&lt;G.numVertexes; v++)   
	{
		min=GRAPH_INFINITY;    <span class="hljs-comment">/* 当前所知离v0顶点的最近距离 */</span>        
		<span class="hljs-keyword">for</span>(w=<span class="hljs-number">0</span>; w&lt;G.numVertexes; w++) <span class="hljs-comment">/* 寻找离v0最近的顶点 */</span>    
		{            
			<span class="hljs-keyword">if</span>(!<span class="hljs-keyword">final</span>[w] &amp;&amp; (*D)[w]&lt;min)             
			{                   
				k=w;                    
				min = (*D)[w];    <span class="hljs-comment">/* w顶点离v0顶点更近 */</span>            
			}        
		}        
		<span class="hljs-keyword">final</span>[k] = <span class="hljs-number">1</span>;    <span class="hljs-comment">/* 将目前找到的最近的顶点置为1 */</span>
		<span class="hljs-keyword">for</span>(w=<span class="hljs-number">0</span>; w&lt;G.numVertexes; w++) <span class="hljs-comment">/* 修正当前最短路径及距离 */</span>
		{
			<span class="hljs-comment">/* 如果经过v顶点的路径比现在这条路径的长度短的话 */</span>
			<span class="hljs-keyword">if</span>(!<span class="hljs-keyword">final</span>[w] &amp;&amp; (min+G.arc[k][w]&lt;(*D)[w]))   
			{ <span class="hljs-comment">/*  说明找到了更短的路径，修改D[w]和P[w] */</span>
				(*D)[w] = min + G.arc[k][w];  <span class="hljs-comment">/* 修改当前路径长度 */</span>               
				(*P)[w]=k;        
			}       
		}   
	}
}
</div></code></pre>
<p>$迪杰斯特拉算法本质是一种广义贪心算法, 先找到局部最优解, 再找到全局最优解$
$迪杰斯特拉算法需要三个辅助数组\
① S数组:记录目标顶点到其他顶点的最短路径是否求得(\ 0 \ or \ 1)\
② P数组:记录了目标结点到其他结点最短路径的前驱结点\
\ \ \ \ 例如:v_0到v_5的最短距离为v_0-&gt;v_3-&gt;v_5, 则前驱节点为v_3 \
③ D数组:记录了目标顶点到其他顶点最短路径的长度\
设集合X表示已经加入最短路径的顶点集 \
$</p>
<pre><code class="language-mermaid"><div class="mermaid">	graph LR
	
	1((1))-.12.-2((2))
	1((1))-.16.-6((6))
	1((1))-.14.-7((7))

	2((2))-.10.-3((3))
	2((2))-.7.-6((6))

	7((7))-.9.-6((6))
	7((7))-.8.-5((5))

	6((6))-.6.-3((3))
	6((6))-.2.-5((5))
	
	3((3))-.3.-4((4))
	3((3))-.5.-5((5))

	5((5))-.4.-4((4))
</div></code></pre>
<p>$如图,开始时数组S, P, D值如表$</p>
<p><strong>$phase \ 1$</strong></p>
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">$v_1$</th>
<th style="text-align:center">$v_2$</th>
<th style="text-align:center">$v_3$</th>
<th style="text-align:center">$v_4$</th>
<th style="text-align:center">$v_5$</th>
<th style="text-align:center">$v_6$</th>
<th style="text-align:center">$v_7$</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
<td style="text-align:center">2</td>
<td style="text-align:center">3</td>
<td style="text-align:center">4</td>
<td style="text-align:center">5</td>
<td style="text-align:center">6</td>
</tr>
<tr>
<td style="text-align:center"><strong>S</strong></td>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td style="text-align:center"><strong>P</strong></td>
<td style="text-align:center">-1</td>
<td style="text-align:center">0</td>
<td style="text-align:center">-1</td>
<td style="text-align:center">-1</td>
<td style="text-align:center">-1</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td style="text-align:center"><strong>D</strong></td>
<td style="text-align:center">0</td>
<td style="text-align:center">12</td>
<td style="text-align:center">$\infty$</td>
<td style="text-align:center">$\infty$</td>
<td style="text-align:center">$\infty$</td>
<td style="text-align:center">16</td>
<td style="text-align:center">14</td>
</tr>
</tbody>
</table>
<p>$$X=\left{v_1\right}$$</p>
<p>$①顶点到自身最短路径默认找到且为0 \
②没有前驱记为-1 \
③如果一个顶点到期邻接点有弧,那么暂定这条弧为最短路径 \
$
$在D数组中找到最短的边12,把这条边的终点v_2加入X集合当中$
<strong>$phase \ 2$</strong></p>
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">$v_1$</th>
<th style="text-align:center">$v_2$</th>
<th style="text-align:center">$v_3$</th>
<th style="text-align:center">$v_4$</th>
<th style="text-align:center">$v_5$</th>
<th style="text-align:center">$v_6$</th>
<th style="text-align:center">$v_7$</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
<td style="text-align:center">2</td>
<td style="text-align:center">3</td>
<td style="text-align:center">4</td>
<td style="text-align:center">5</td>
<td style="text-align:center">6</td>
</tr>
<tr>
<td style="text-align:center"><strong>S</strong></td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td style="text-align:center"><strong>P</strong></td>
<td style="text-align:center">-1</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
<td style="text-align:center">-1</td>
<td style="text-align:center">-1</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td style="text-align:center"><strong>D</strong></td>
<td style="text-align:center">0</td>
<td style="text-align:center">12</td>
<td style="text-align:center">22</td>
<td style="text-align:center">$\infty$</td>
<td style="text-align:center">$\infty$</td>
<td style="text-align:center">16</td>
<td style="text-align:center">14</td>
</tr>
</tbody>
</table>
<p>$$X=\left{v_1,v_2\right}$$</p>
<p>$在D数组中找到最短的边14,把这条边的终点v_7加入X集合当中$
<strong>$phase \ 3$</strong></p>
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">$v_1$</th>
<th style="text-align:center">$v_2$</th>
<th style="text-align:center">$v_3$</th>
<th style="text-align:center">$v_4$</th>
<th style="text-align:center">$v_5$</th>
<th style="text-align:center">$v_6$</th>
<th style="text-align:center">$v_7$</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
<td style="text-align:center">2</td>
<td style="text-align:center">3</td>
<td style="text-align:center">4</td>
<td style="text-align:center">5</td>
<td style="text-align:center">6</td>
</tr>
<tr>
<td style="text-align:center"><strong>S</strong></td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:center"><strong>P</strong></td>
<td style="text-align:center">-1</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
<td style="text-align:center">-1</td>
<td style="text-align:center">6</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td style="text-align:center"><strong>D</strong></td>
<td style="text-align:center">0</td>
<td style="text-align:center">12</td>
<td style="text-align:center">22</td>
<td style="text-align:center">$\infty$</td>
<td style="text-align:center">22</td>
<td style="text-align:center">16</td>
<td style="text-align:center">14</td>
</tr>
</tbody>
</table>
<p>$$X=\left{v_1,v_2,v_7\right}$$</p>
<p>$在D数组中找到最短的边16,把这条边的终点v_6加入X集合当中$
<strong>$phase \ 4$</strong></p>
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">$v_1$</th>
<th style="text-align:center">$v_2$</th>
<th style="text-align:center">$v_3$</th>
<th style="text-align:center">$v_4$</th>
<th style="text-align:center">$v_5$</th>
<th style="text-align:center">$v_6$</th>
<th style="text-align:center">$v_7$</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
<td style="text-align:center">2</td>
<td style="text-align:center">3</td>
<td style="text-align:center">4</td>
<td style="text-align:center">5</td>
<td style="text-align:center">6</td>
</tr>
<tr>
<td style="text-align:center"><strong>S</strong></td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:center"><strong>P</strong></td>
<td style="text-align:center">-1</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
<td style="text-align:center">-1</td>
<td style="text-align:center">5</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td style="text-align:center"><strong>D</strong></td>
<td style="text-align:center">0</td>
<td style="text-align:center">12</td>
<td style="text-align:center">22</td>
<td style="text-align:center">$\infty$</td>
<td style="text-align:center">18</td>
<td style="text-align:center">16</td>
<td style="text-align:center">14</td>
</tr>
</tbody>
</table>
<p>$$X=\left{v_1,v_2,v_7,v_6\right}$$</p>
<p>$在D数组中找到最短的边18,把这条边的终点v_5加入X集合当中$
<strong>$phase \ 5$</strong></p>
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">$v_1$</th>
<th style="text-align:center">$v_2$</th>
<th style="text-align:center">$v_3$</th>
<th style="text-align:center">$v_4$</th>
<th style="text-align:center">$v_5$</th>
<th style="text-align:center">$v_6$</th>
<th style="text-align:center">$v_7$</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
<td style="text-align:center">2</td>
<td style="text-align:center">3</td>
<td style="text-align:center">4</td>
<td style="text-align:center">5</td>
<td style="text-align:center">6</td>
</tr>
<tr>
<td style="text-align:center"><strong>S</strong></td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:center"><strong>P</strong></td>
<td style="text-align:center">-1</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
<td style="text-align:center">4</td>
<td style="text-align:center">5</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td style="text-align:center"><strong>D</strong></td>
<td style="text-align:center">0</td>
<td style="text-align:center">12</td>
<td style="text-align:center">22</td>
<td style="text-align:center">22</td>
<td style="text-align:center">18</td>
<td style="text-align:center">16</td>
<td style="text-align:center">14</td>
</tr>
</tbody>
</table>
<p>$$X=\left{v_1,v_2,v_7,v_6,v_5\right}$$</p>
<p>$在D数组中找到最短的边22,把这条边的终点v_3加入X集合当中$
<strong>$phase \ 6$</strong></p>
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">$v_1$</th>
<th style="text-align:center">$v_2$</th>
<th style="text-align:center">$v_3$</th>
<th style="text-align:center">$v_4$</th>
<th style="text-align:center">$v_5$</th>
<th style="text-align:center">$v_6$</th>
<th style="text-align:center">$v_7$</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
<td style="text-align:center">2</td>
<td style="text-align:center">3</td>
<td style="text-align:center">4</td>
<td style="text-align:center">5</td>
<td style="text-align:center">6</td>
</tr>
<tr>
<td style="text-align:center"><strong>S</strong></td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:center"><strong>P</strong></td>
<td style="text-align:center">-1</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
<td style="text-align:center">4</td>
<td style="text-align:center">5</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td style="text-align:center"><strong>D</strong></td>
<td style="text-align:center">0</td>
<td style="text-align:center">12</td>
<td style="text-align:center">22</td>
<td style="text-align:center">22</td>
<td style="text-align:center">18</td>
<td style="text-align:center">16</td>
<td style="text-align:center">14</td>
</tr>
</tbody>
</table>
<p>$$X=\left{v_1,v_2,v_7,v_6,v_5,v_3\right}$$</p>
<p>$在D数组中找到最短的边22,把这条边的终点v_4加入X集合当中$
<strong>$phase \ 7$</strong></p>
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">$v_1$</th>
<th style="text-align:center">$v_2$</th>
<th style="text-align:center">$v_3$</th>
<th style="text-align:center">$v_4$</th>
<th style="text-align:center">$v_5$</th>
<th style="text-align:center">$v_6$</th>
<th style="text-align:center">$v_7$</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
<td style="text-align:center">2</td>
<td style="text-align:center">3</td>
<td style="text-align:center">4</td>
<td style="text-align:center">5</td>
<td style="text-align:center">6</td>
</tr>
<tr>
<td style="text-align:center"><strong>S</strong></td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:center"><strong>P</strong></td>
<td style="text-align:center">-1</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
<td style="text-align:center">4</td>
<td style="text-align:center">5</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td style="text-align:center"><strong>D</strong></td>
<td style="text-align:center">0</td>
<td style="text-align:center">12</td>
<td style="text-align:center">22</td>
<td style="text-align:center">22</td>
<td style="text-align:center">18</td>
<td style="text-align:center">16</td>
<td style="text-align:center">14</td>
</tr>
</tbody>
</table>
<p>$$X=\left{v_1,v_2,v_7,v_6,v_5,v_3,v_4\right}$$</p>
<p>$至此,迪杰斯特拉算法的整个流程已经结束了\
现在只需要根据目标顶点在P中找前驱即可得到最短路径\
例如,目标顶点为v_4,\
则$
$$v_4在P中前驱为4即v_5\
v_5在P中前驱为5即v_6 \
v_6在P中前驱为0即v_1
$$</p>
<p>$这样就得到v_1到v_4的最短路径为$</p>
<p>$$v_1-&gt;v_6-&gt;v_5-&gt;v_4$$</p>
<p><strong>$$完整代码$$</strong></p>
<pre class="hljs"><code><div><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span>

<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MAX 32767</span>

<span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Graph</span> {</span>
    <span class="hljs-keyword">char</span>* vexs;
    <span class="hljs-keyword">int</span>** arcs;
    <span class="hljs-keyword">int</span> vexNum;
    <span class="hljs-keyword">int</span> arcNum;
}Graph;

<span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Edge</span> {</span>
    <span class="hljs-keyword">int</span> start;
    <span class="hljs-keyword">int</span> <span class="hljs-built_in">end</span>;
    <span class="hljs-keyword">int</span> weight;
}Edge;

<span class="hljs-function">Edge* <span class="hljs-title">initEdge</span><span class="hljs-params">(Graph* G)</span> </span>{
    <span class="hljs-keyword">int</span> index = <span class="hljs-number">0</span>;
    Edge* edge = (Edge*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(Edge) * G -&gt; arcNum);
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; G -&gt; vexNum; i++) {
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = i + <span class="hljs-number">1</span>; j &lt; G -&gt; vexNum; j++) {
            <span class="hljs-keyword">if</span> (G -&gt; arcs[i][j] != MAX) {
                edge[index].start = i;
                edge[index].<span class="hljs-built_in">end</span> = j;
                edge[index].weight = G -&gt; arcs[i][j];
                index++;
            }
        }
    }
    <span class="hljs-keyword">return</span> edge;
}

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">sortEdge</span><span class="hljs-params">(Edge* edge, Graph* G)</span> </span>{
    Edge temp;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; G -&gt; arcNum - <span class="hljs-number">1</span>; i++) {
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; G -&gt; arcNum - i - <span class="hljs-number">1</span>; j++) {
            <span class="hljs-keyword">if</span> (edge[j].weight &gt; edge[j + <span class="hljs-number">1</span>].weight) {
                temp = edge[j];
                edge[j] = edge[j + <span class="hljs-number">1</span>];
                edge[j + <span class="hljs-number">1</span>] = temp;
            }
        }
    }
}

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">kruskal</span><span class="hljs-params">(Graph* G)</span> </span>{
    <span class="hljs-keyword">int</span>* <span class="hljs-built_in">connected</span> = (<span class="hljs-keyword">int</span>*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>) * G -&gt; vexNum);
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span> ; i &lt; G -&gt; vexNum; i++) {
        <span class="hljs-built_in">connected</span>[i] = i;
    }
    Edge* edge = initEdge(G);
    sortEdge(edge, G);
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; G -&gt; arcNum; i++) {
        <span class="hljs-keyword">int</span> start = <span class="hljs-built_in">connected</span>[edge[i].start];
        <span class="hljs-keyword">int</span> <span class="hljs-built_in">end</span> = <span class="hljs-built_in">connected</span>[edge[i].<span class="hljs-built_in">end</span>];
        <span class="hljs-keyword">if</span> (start != <span class="hljs-built_in">end</span>) {
            <span class="hljs-built_in">printf</span>(<span class="hljs-string">"v%c --&gt; v%c weight = %d\n"</span>, G -&gt; vexs[edge[i].start], G -&gt; vexs[edge[i].<span class="hljs-built_in">end</span>], edge[i].weight);
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; G -&gt; vexNum; j++) {
                <span class="hljs-keyword">if</span> (<span class="hljs-built_in">connected</span>[j] == <span class="hljs-built_in">end</span>) {
                    <span class="hljs-built_in">connected</span>[j] = start;
                }
            }
        }
    }
}

<span class="hljs-function">Graph* <span class="hljs-title">initGraph</span><span class="hljs-params">(<span class="hljs-keyword">int</span> vexNum)</span> </span>{
    Graph* G = (Graph*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(Graph));
    G -&gt; vexs = (<span class="hljs-keyword">char</span>*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">char</span>) * vexNum);
    G -&gt; arcs = (<span class="hljs-keyword">int</span>**)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>*) * vexNum);
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span> ; i &lt; vexNum; i++) {
        G -&gt; arcs[i] = (<span class="hljs-keyword">int</span>*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>) * vexNum);
    }
    G -&gt; vexNum = vexNum;
    G -&gt; arcNum = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">return</span> G;
}

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">createGraph</span><span class="hljs-params">(Graph* G, <span class="hljs-keyword">char</span>* vexs, <span class="hljs-keyword">int</span>* arcs)</span> </span>{
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span> ; i &lt; G -&gt; vexNum; i++) {
        G -&gt; vexs[i] = vexs[i];
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; G -&gt; vexNum; j++) {
            G -&gt; arcs[i][j] = *(arcs + i * G -&gt; vexNum + j);
            <span class="hljs-keyword">if</span> (G -&gt; arcs[i][j] != <span class="hljs-number">0</span> &amp;&amp; G -&gt; arcs[i][j] != MAX)
                G -&gt; arcNum ++;
        }
    }
    G -&gt; arcNum /= <span class="hljs-number">2</span>;
}

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">DFS</span><span class="hljs-params">(Graph* G, <span class="hljs-keyword">int</span>* visited, <span class="hljs-keyword">int</span> index)</span> </span>{
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%c\t"</span>, G -&gt; vexs[index]);
    visited[index] = <span class="hljs-number">1</span>;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; G -&gt;vexNum; i++) {
        <span class="hljs-keyword">if</span> (G -&gt; arcs[index][i] &gt; <span class="hljs-number">0</span> &amp;&amp; G -&gt; arcs[index][i] != MAX &amp;&amp; !visited[i]) {
            DFS(G, visited, i);
        }
    }
}

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
    Graph* G = initGraph(<span class="hljs-number">6</span>);
    <span class="hljs-keyword">int</span>* visited = (<span class="hljs-keyword">int</span>*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>) * G -&gt; vexNum);
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; G -&gt; vexNum; i++)
        visited[i] = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">int</span> arcs[<span class="hljs-number">6</span>][<span class="hljs-number">6</span>] = {
        <span class="hljs-number">0</span>, <span class="hljs-number">6</span>, <span class="hljs-number">1</span>, <span class="hljs-number">5</span>, MAX, MAX,
        <span class="hljs-number">6</span>, <span class="hljs-number">0</span>, <span class="hljs-number">5</span>, MAX, <span class="hljs-number">3</span>, MAX,
        <span class="hljs-number">1</span>, <span class="hljs-number">5</span>, <span class="hljs-number">0</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">4</span>,
        <span class="hljs-number">5</span>, MAX, <span class="hljs-number">5</span>, <span class="hljs-number">0</span>, MAX, <span class="hljs-number">2</span>,
        MAX, <span class="hljs-number">3</span>, <span class="hljs-number">6</span>, MAX, <span class="hljs-number">0</span>, <span class="hljs-number">6</span>,
        MAX, MAX, <span class="hljs-number">4</span>, <span class="hljs-number">2</span>, <span class="hljs-number">6</span>, <span class="hljs-number">0</span>
    };
    createGraph(G, <span class="hljs-string">"123456"</span>, (<span class="hljs-keyword">int</span>*)arcs);
    DFS(G, visited, <span class="hljs-number">0</span>);
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n"</span>);
    kruskal(G);
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</div></code></pre>
<h4 id="652-a-namefloydwarshallalgorithma%E5%BC%97%E6%B4%9B%E4%BC%8A%E5%BE%B7%E7%AE%97%E6%B3%95-floyd%E2%80%93warshall-algorithm">6.5.2. <a name='FloydWarshallAlgorithm'></a>弗洛伊德算法 Floyd–Warshall Algorithm</h4>
<pre class="hljs"><code><div><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">int</span> Patharc[MAXVEX][MAXVEX];
<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">int</span> ShortPathTable[MAXVEX][MAXVEX];
<span class="hljs-comment">/* Floyd算法，求网图G中各顶点v到其余顶点w的最短路径P[v][w]及带权长度D[v][w]。 */</span>    
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">ShortestPath_Floyd</span><span class="hljs-params">(MGraph G, Patharc *P, ShortPathTable *D)</span>
</span>{    
	<span class="hljs-keyword">int</span> v,w,k;    
	<span class="hljs-keyword">for</span>(v=<span class="hljs-number">0</span>; v&lt;G.numVertexes; ++v) <span class="hljs-comment">/* 初始化D与P */</span>  
	{        
		<span class="hljs-keyword">for</span>(w=<span class="hljs-number">0</span>; w&lt;G.numVertexes; ++w)  
		{
			(*D)[v][w]=G.arc[v][w];	<span class="hljs-comment">/* D[v][w]值即为对应点间的权值 */</span>
			(*P)[v][w]=w;				<span class="hljs-comment">/* 初始化P */</span>
		}
	}
	<span class="hljs-keyword">for</span>(k=<span class="hljs-number">0</span>; k&lt;G.numVertexes; ++k)   
	{
		<span class="hljs-keyword">for</span>(v=<span class="hljs-number">0</span>; v&lt;G.numVertexes; ++v)  
		{        
			<span class="hljs-keyword">for</span>(w=<span class="hljs-number">0</span>; w&lt;G.numVertexes; ++w)    
			{
				<span class="hljs-keyword">if</span> ((*D)[v][w]&gt;(*D)[v][k]+(*D)[k][w])
				{<span class="hljs-comment">/* 如果经过下标为k顶点路径比原两点间路径更短 */</span>
					(*D)[v][w]=(*D)[v][k]+(*D)[k][w];<span class="hljs-comment">/* 将当前两点间权值设为更小的一个 */</span>
					(*P)[v][w]=(*P)[v][k];<span class="hljs-comment">/* 路径设置为经过下标为k的顶点 */</span>
				}
			}
		}
	}
}
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">PrintShortestPath</span><span class="hljs-params">(MGraph G)</span>
</span>{
	<span class="hljs-built_in">printf</span>(<span class="hljs-string">"各顶点间最短路径如下:\n"</span>);    
	<span class="hljs-keyword">for</span>(v=<span class="hljs-number">0</span>; v&lt;G.numVertexes; ++v)   
	{        
		<span class="hljs-keyword">for</span>(w=v+<span class="hljs-number">1</span>; w&lt;G.numVertexes; w++)  
		{
			<span class="hljs-built_in">printf</span>(<span class="hljs-string">"v%d-v%d weight: %d "</span>,v,w,D[v][w]);
			k=P[v][w];				<span class="hljs-comment">/* 获得第一个路径顶点下标 */</span>
			<span class="hljs-built_in">printf</span>(<span class="hljs-string">" path: %d"</span>,v);	<span class="hljs-comment">/* 打印源点 */</span>
			<span class="hljs-keyword">while</span>(k!=w)				<span class="hljs-comment">/* 如果路径顶点下标不是终点 */</span>
			{
				<span class="hljs-built_in">printf</span>(<span class="hljs-string">" -&gt; %d"</span>,k);	<span class="hljs-comment">/* 打印路径顶点 */</span>
				k=P[k][w];			<span class="hljs-comment">/* 获得下一个路径顶点下标 */</span>
			}
			<span class="hljs-built_in">printf</span>(<span class="hljs-string">" -&gt; %d\n"</span>,w);	<span class="hljs-comment">/* 打印终点 */</span>
		}
		<span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n"</span>);
	}
	<span class="hljs-keyword">return</span> ;
}
</div></code></pre>
<p>$弗洛伊德算法 \
核心:\
\qquad 试探法,通过加入不同的点进行中转，选择出最优解 \
该算法需要两个辅助数组:\
\qquad ①D数组:保存两点间最短路径长度 \
\qquad ②P数组:保存两点之间最短路径的前驱\
step:\
\qquad ①从目标顶点v_1开始进行中转比较 \
\qquad ②到v_i顶点时,矩阵的对角线以及以v_i为行和列的元素忽略 \
\qquad ③如果{D(v_n-&gt;v_m)&gt;D(v_n-&gt;v_i-&gt;v_m)},则修改D[n][m]的值为D[n][i]+D[i][m],同时修改P数组中的前驱,即P[n][m]的值修改为P[n][i]的值 \
\qquad ④最后根据前驱寻找最短路径即可
$</p>
<p><strong>$$完整代码$$</strong></p>
<pre class="hljs"><code><div><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span>

<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MAX 32767</span>

<span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Graph</span> {</span>
    <span class="hljs-keyword">char</span>* vexs;
    <span class="hljs-keyword">int</span>** arcs;
    <span class="hljs-keyword">int</span> vexNum;
    <span class="hljs-keyword">int</span> arcNum;
}Graph;

<span class="hljs-function">Graph* <span class="hljs-title">initGraph</span><span class="hljs-params">(<span class="hljs-keyword">int</span> vexNum)</span> </span>{
    Graph* G = (Graph*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(Graph));
    G -&gt; vexs = (<span class="hljs-keyword">char</span>*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">char</span>) * vexNum);
    G -&gt; arcs = (<span class="hljs-keyword">int</span>**)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>*) * vexNum);
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span> ; i &lt; vexNum; i++) {
        G -&gt; arcs[i] = (<span class="hljs-keyword">int</span>*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>) * vexNum);
    }
    G -&gt; vexNum = vexNum;
    G -&gt; arcNum = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">return</span> G;
}

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">createGraph</span><span class="hljs-params">(Graph* G, <span class="hljs-keyword">char</span>* vexs, <span class="hljs-keyword">int</span>* arcs)</span> </span>{
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span> ; i	 &lt; G -&gt; vexNum; i++) {
        G -&gt; vexs[i] = vexs[i];
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; G -&gt; vexNum; j++) {
            G -&gt; arcs[i][j] = *(arcs + i * G -&gt; vexNum + j);
            <span class="hljs-keyword">if</span> (G -&gt; arcs[i][j] != <span class="hljs-number">0</span> &amp;&amp; G -&gt; arcs[i][j] != MAX) 
                G -&gt; arcNum ++;
        }
    }
    G -&gt; arcNum /= <span class="hljs-number">2</span>;
}

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">DFS</span><span class="hljs-params">(Graph* G, <span class="hljs-keyword">int</span>* visited, <span class="hljs-keyword">int</span> index)</span> </span>{
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%c\t"</span>, G -&gt; vexs[index]);
    visited[index] = <span class="hljs-number">1</span>;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; G -&gt;vexNum; i++) {
        <span class="hljs-keyword">if</span> (G -&gt; arcs[index][i] &gt; <span class="hljs-number">0</span> &amp;&amp; G -&gt; arcs[index][i] != MAX &amp;&amp; !visited[i]) {
            DFS(G, visited, i);
        }
    }
}

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">floyd</span><span class="hljs-params">(Graph* G)</span> </span>{
    <span class="hljs-keyword">int</span> d[G -&gt; vexNum][G -&gt; vexNum];
    <span class="hljs-keyword">int</span> p[G -&gt; vexNum][G -&gt; vexNum];
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; G -&gt; vexNum; i++) {
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; G -&gt; vexNum; j++) {
            d[i][j] = G -&gt; arcs[i][j];
            <span class="hljs-keyword">if</span> (G -&gt; arcs[i][j] &gt; <span class="hljs-number">0</span> &amp;&amp; G -&gt; arcs[i][j] != MAX) {
                p[i][j] = i;
            }
            <span class="hljs-keyword">else</span>
                p[i][j] = <span class="hljs-number">-1</span>;
        }
    }

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; G -&gt; vexNum; i++) {
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; G -&gt; vexNum; j++) {
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>; k &lt; G -&gt; vexNum; k++) {
                <span class="hljs-keyword">if</span> (d[j][i] + d[i][k] &lt; d[j][k]) {
                    d[j][k] = d[j][i] + d[i][k];
                    p[j][k] = p[i][k];
                }
            }
        }
    }

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; G -&gt; vexNum; i++) {
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; G -&gt; vexNum; j++) {
            <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d "</span>, d[i][j]);
        }
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n"</span>);
    }
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n"</span>);
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; G -&gt; vexNum; i++) {
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; G -&gt; vexNum; j++) {
            <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d "</span>, p[i][j]);
        }
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n"</span>);
    }
}

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
    Graph* G = initGraph(<span class="hljs-number">4</span>);
    <span class="hljs-keyword">int</span>* visited = (<span class="hljs-keyword">int</span>*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>) * G -&gt; vexNum);
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; G -&gt; vexNum; i++)
        visited[i] = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">int</span> arcs[<span class="hljs-number">4</span>][<span class="hljs-number">4</span>] = {
        <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, MAX, <span class="hljs-number">3</span>,
        <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>,
        MAX, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>, <span class="hljs-number">8</span>,
        <span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">8</span>, <span class="hljs-number">0</span>
    };
    createGraph(G, <span class="hljs-string">"1234"</span>, (<span class="hljs-keyword">int</span>*)arcs);
    DFS(G, visited, <span class="hljs-number">0</span>);
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n"</span>);
    floyd(G);
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</div></code></pre>
<h3 id="66-a-name-1a%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F">6.6. <a name='-1'></a>拓扑排序</h3>
<h4 id="661-a-name-1a%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5">6.6.1. <a name='-1'></a>基本概念</h4>
<h5 id="%E6%9C%89%E5%90%91%E6%97%A0%E7%8E%AF%E5%9B%BE-dagdirected-acyclic-graph">有向无环图 DAG(Directed Acyclic Graph)</h5>
<h5 id="aov%E7%BD%91-activity-on-vertex-network">AOV网 Activity On Vertex Network</h5>
<ol>
<li>表示工程</li>
<li><strong>无环</strong></li>
<li><strong>有向图</strong></li>
<li>顶点表示活动(任务)</li>
<li>弧表示活动之间的优先关系(先后依赖关系)</li>
</ol>
<h5 id="%E6%8B%93%E6%89%91%E5%BA%8F%E5%88%97">拓扑序列</h5>
<p>$顶点序列v_1,v_2,v_1...v_n满足从顶点v_i到v_j有路劲,则顶点序列中v_i必在v_j之前$</p>
<h5 id="%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F">拓扑排序</h5>
<p>$对一个有向图构造拓扑序列的过程$</p>
<h4 id="662-a-name-1a%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95">6.6.2. <a name='-1'></a>拓扑排序算法</h4>
<h5 id="%E5%9F%BA%E6%9C%AC%E6%80%9D%E8%B7%AF">基本思路:</h5>
<ol>
<li>从AOV网中选择入度为0的顶点输出,并删除次顶点和以此顶点为尾的弧.</li>
<li>重复上述步骤,直至输出全部顶点或者AOV网中不存在入度为0的顶点为止</li>
</ol>
<h5 id="%E5%9F%BA%E4%BA%8E%E9%82%BB%E6%8E%A5%E8%A1%A8%E7%9A%84%E4%BB%A3%E7%A0%81">基于邻接表的代码</h5>
<p>使用邻接表,并在顶点表中增加入度域in</p>
<pre class="hljs"><code><div><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">arcNode</span>		//边链表
{</span>
	<span class="hljs-keyword">int</span> vex_num;
	<span class="hljs-keyword">int</span> weight;
	arcNode* next;
}arcNode;

<span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">vexNode</span>		//顶点表数据类型
{</span>
	<span class="hljs-keyword">int</span> in;		<span class="hljs-comment">//入度域</span>
	<span class="hljs-keyword">char</span> vex;
	arcNode* First;
}vexNode;

<span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ALGraph</span>		//邻接表数据类型
{</span>
	vexNode List[MAXSIZE];
	<span class="hljs-keyword">int</span> vexNum;
	<span class="hljs-keyword">int</span>	arcsNum;
}ALGraph;		
</div></code></pre>
<p>使用栈,存储处理过程中入度为0的顶点,避免多次遍历顶点表
这里使用顺序栈即可,栈的基本操作直接写在算法里</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">ToologicalSort</span><span class="hljs-params">(ALGraph* GL)</span>
</span>{
	<span class="hljs-built_in">printf</span>(<span class="hljs-string">"拓扑序列为：\n\n\t"</span>);

	<span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;		<span class="hljs-comment">//记录已经输出的顶点数量</span>

	<span class="hljs-keyword">int</span>* <span class="hljs-built_in">stack</span> = (<span class="hljs-keyword">int</span>*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>) * GL-&gt;vexNum);	<span class="hljs-comment">//顺序栈</span>
	<span class="hljs-keyword">int</span> top = <span class="hljs-number">-1</span>;		<span class="hljs-comment">//规定为-1,方便后续操作</span>
	<span class="hljs-keyword">int</span> getTop;			<span class="hljs-comment">//取栈顶值</span>
	<span class="hljs-comment">//栈里的值为顶点对应的序号</span>

	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; GL-&gt;vexNum; i++)
		<span class="hljs-keyword">if</span> (GL-&gt;List[i].in == <span class="hljs-number">0</span>)		<span class="hljs-comment">//将入度为0的顶点入栈</span>
			<span class="hljs-built_in">stack</span>[++top] = i;			<span class="hljs-comment">//top记得++</span>
		
	arcNode* e;			<span class="hljs-comment">//用来遍历顶点对应的边表</span>
	<span class="hljs-keyword">int</span> flag = <span class="hljs-number">0</span>;		<span class="hljs-comment">//控制"-&gt;"的输出数量</span>
	<span class="hljs-keyword">while</span> (top != <span class="hljs-number">-1</span>)	<span class="hljs-comment">//栈非空</span>
	{
		getTop = <span class="hljs-built_in">stack</span>[top--];		<span class="hljs-comment">//取栈顶值并出栈</span>
		<span class="hljs-built_in">printf</span>(<span class="hljs-string">"V%d"</span>, (<span class="hljs-keyword">int</span>)(GL-&gt;List[getTop].vex-<span class="hljs-string">'a'</span>)+<span class="hljs-number">1</span>);	<span class="hljs-comment">//输出序列</span>
		<span class="hljs-keyword">if</span> (flag != GL-&gt;vexNum - <span class="hljs-number">1</span>)		<span class="hljs-comment">//n个顶点应该有n-1个"-&gt;"</span>
		{
			<span class="hljs-built_in">printf</span>(<span class="hljs-string">" -&gt; "</span>);
			flag++;
		}
		count++;	<span class="hljs-comment">//已输出顶点数++</span>

		<span class="hljs-keyword">for</span> (e = GL-&gt;List[getTop].First; e; e = e-&gt;next)	<span class="hljs-comment">//遍历边表</span>
		{
			<span class="hljs-keyword">int</span> k = e-&gt;vex_num;		<span class="hljs-comment">//k记录当前顶点序号</span>
			GL-&gt;List[k].in--;		<span class="hljs-comment">//由于上个顶点以删除,故入度-1</span>
			<span class="hljs-keyword">if</span> (GL-&gt;List[k].in == <span class="hljs-number">0</span>)	<span class="hljs-comment">//将入度为0的顶点入栈</span>
				<span class="hljs-built_in">stack</span>[++top] = k;	
		}
	}
	<span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n"</span>);

	<span class="hljs-keyword">if</span> (count &lt; GL-&gt;vexNum)		<span class="hljs-comment">//输出顶点数量小于总顶点数说明存在环路</span>
	{
		<span class="hljs-built_in">printf</span>(<span class="hljs-string">"\t有环！\n"</span>);
		<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
	}		
	<span class="hljs-keyword">else</span>
		<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
}
</div></code></pre>
<p>$$完整代码$$</p>
<pre class="hljs"><code><div><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MAXSIZE 20</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> _CRT_SECURE_NO_WARNINGS</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;windows.h&gt;</span></span>

<span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">arcNode</span>		//边链表
{</span>
	<span class="hljs-keyword">int</span> vex_num;
	<span class="hljs-keyword">int</span> weight;
	arcNode* next;
}arcNode;

<span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">vexNode</span>		//顶点表数据类型
{</span>
	<span class="hljs-keyword">int</span> in;		<span class="hljs-comment">//入度域</span>
	<span class="hljs-keyword">char</span> vex;
	arcNode* First;
}vexNode;

<span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ALGraph</span>		//邻接表数据类型
{</span>
	vexNode List[MAXSIZE];
	<span class="hljs-keyword">int</span> vexNum;
	<span class="hljs-keyword">int</span>	arcsNum;
}ALGraph;

<span class="hljs-function">ALGraph* <span class="hljs-title">CreateALGraph</span><span class="hljs-params">()</span>
</span>{
	ALGraph* G = (ALGraph*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(ALGraph));
	<span class="hljs-built_in">printf</span>(<span class="hljs-string">"请输入顶点数和边数："</span>);
	<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d %d"</span>, &amp;G-&gt;vexNum, &amp;G-&gt;arcsNum);

	<span class="hljs-built_in">printf</span>(<span class="hljs-string">"请依次输入各顶点的值：\n"</span>);
	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> v = <span class="hljs-number">0</span>; v &lt; G-&gt;vexNum; v++)
	{
		getchar();
		<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%c"</span>, &amp;G-&gt;List[v].vex);
		G-&gt;List[v].First = <span class="hljs-literal">NULL</span>;
	}

	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; G-&gt;vexNum; i++)
	{
		G-&gt;List[i].in = <span class="hljs-number">0</span>;
	}

	<span class="hljs-built_in">printf</span>(<span class="hljs-string">"请依次输入弧头序号、弧尾序号：\n"</span>);
	<span class="hljs-keyword">int</span> start, end;
	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>; k &lt; G-&gt;arcsNum; k++)
	{
		<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d"</span>, &amp;start, &amp;end);
		arcNode* s = (arcNode*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(arcNode));
		s-&gt;vex_num = end;
		s-&gt;next = G-&gt;List[start].First;
		G-&gt;List[start].First = s;
		G-&gt;List[end].in++;
	}
	<span class="hljs-keyword">return</span> G;
}

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">printALGraph</span><span class="hljs-params">(ALGraph* LG)</span>
</span>{
	<span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n图的邻接表为：\n"</span>);
	<span class="hljs-built_in">printf</span>(<span class="hljs-string">"\tin  vex\n"</span>);
	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; LG-&gt;vexNum; i++)
	{
		<span class="hljs-built_in">printf</span>(<span class="hljs-string">"\t________\n"</span>);
		<span class="hljs-built_in">printf</span>(<span class="hljs-string">"\t(%d) V%d  |--&gt;"</span>, LG-&gt;List[i].in, (<span class="hljs-keyword">int</span>)(LG-&gt;List[i].vex - <span class="hljs-string">'a'</span>));
		arcNode* s = LG-&gt;List[i].First;
		<span class="hljs-keyword">while</span> (s)
		{
			arcNode* p = s-&gt;next;
			<span class="hljs-built_in">printf</span>(<span class="hljs-string">"V%d "</span>, (<span class="hljs-keyword">int</span>)(LG-&gt;List[s-&gt;vex_num].vex - <span class="hljs-string">'a'</span>));
			<span class="hljs-keyword">if</span> (p)
				<span class="hljs-built_in">printf</span>(<span class="hljs-string">"--&gt;"</span>);
			s = s-&gt;next;
		}
		<span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n"</span>);
		<span class="hljs-built_in">printf</span>(<span class="hljs-string">"\t￣￣￣￣\n"</span>);
	}
}

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">ToologicalSort</span><span class="hljs-params">(ALGraph* GL)</span>
</span>{
	<span class="hljs-built_in">printf</span>(<span class="hljs-string">"拓扑序列为：\n\n\t"</span>);
	arcNode* e;
	<span class="hljs-keyword">int</span> i, k;
	<span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;

	<span class="hljs-keyword">int</span>* <span class="hljs-built_in">stack</span> = (<span class="hljs-keyword">int</span>*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>) * GL-&gt;vexNum);
	<span class="hljs-keyword">int</span> top = <span class="hljs-number">-1</span>;
	<span class="hljs-keyword">int</span> getTop;

	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; GL-&gt;vexNum; i++)
		<span class="hljs-keyword">if</span> (GL-&gt;List[i].in == <span class="hljs-number">0</span>)
			<span class="hljs-built_in">stack</span>[++top] = i;
		
	<span class="hljs-keyword">int</span> flag = <span class="hljs-number">0</span>;

	<span class="hljs-keyword">while</span> (top != <span class="hljs-number">-1</span>)
	{
		getTop = <span class="hljs-built_in">stack</span>[top--];
		<span class="hljs-built_in">printf</span>(<span class="hljs-string">"V%d"</span>, (<span class="hljs-keyword">int</span>)(GL-&gt;List[getTop].vex-<span class="hljs-string">'a'</span>)+<span class="hljs-number">1</span>);
		<span class="hljs-keyword">if</span> (flag != GL-&gt;vexNum - <span class="hljs-number">1</span>)
		{
			<span class="hljs-built_in">printf</span>(<span class="hljs-string">" -&gt; "</span>);
			flag++;
		}
		count++;
		<span class="hljs-keyword">for</span> (e = GL-&gt;List[getTop].First; e; e = e-&gt;next)
		{
			k = e-&gt;vex_num;
			GL-&gt;List[k].in--;
			<span class="hljs-keyword">if</span> (GL-&gt;List[k].in == <span class="hljs-number">0</span>)			
				<span class="hljs-built_in">stack</span>[++top] = k;	
		}
	}
	<span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n"</span>);
	<span class="hljs-keyword">if</span> (count &lt; GL-&gt;vexNum)
	{
		<span class="hljs-built_in">printf</span>(<span class="hljs-string">"\t有环！\n"</span>);
		<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
	}		
	<span class="hljs-keyword">else</span>
		<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
}

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span>* argv[])</span>
</span>{
	ALGraph* GL = CreateALGraph();
	printALGraph(GL);
	ToologicalSort(GL);
	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</div></code></pre>
<h5 id="%E5%9F%BA%E4%BA%8E%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5%E7%9A%84%E4%BB%A3%E7%A0%81">基于邻接矩阵的代码</h5>
<pre class="hljs"><code><div><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> _CRT_SECURE_NO_WARNINGS</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;windows.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;conio.h&gt;</span></span>

<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MAXSIZE 20</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MAX 52725</span>

<span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Graph</span>
{</span>
	<span class="hljs-keyword">char</span> vexs[MAXSIZE];
	<span class="hljs-keyword">int</span> arcs[MAXSIZE][MAXSIZE];
	<span class="hljs-keyword">int</span> vexNum, arcNum;
}Graph;

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">CreateGraph</span><span class="hljs-params">(Graph* G)</span>
</span>{
	<span class="hljs-built_in">printf</span>(<span class="hljs-string">"请输入顶点数和边数："</span>);
	<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d %d"</span>, &amp;G-&gt;vexNum, &amp;G-&gt;arcNum);

	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; G-&gt;vexNum; i++)
		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; G-&gt;vexNum; j++)		
			G-&gt;arcs[i][j] = MAX;

	<span class="hljs-built_in">printf</span>(<span class="hljs-string">"请依次输入弧头序号、弧尾序号、权值："</span>);
	<span class="hljs-keyword">int</span> start, <span class="hljs-built_in">end</span>, w;
	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>; k &lt; G-&gt;arcNum; k++)
	{
		<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d%d"</span>, &amp;start, &amp;<span class="hljs-built_in">end</span>, &amp;w);
		G-&gt;arcs[start][<span class="hljs-built_in">end</span>] = w;
	}
}

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">printMGraph</span><span class="hljs-params">(Graph* G)</span>
</span>{
	<span class="hljs-built_in">printf</span>(<span class="hljs-string">"图的邻接矩阵为：\n"</span>);			<span class="hljs-comment">//输出图的邻接矩阵</span>
	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; G-&gt;vexNum; i++)
	{
		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; G-&gt;vexNum; j++)
		{
			<span class="hljs-keyword">if</span> (j == <span class="hljs-number">0</span>)
			{
				<span class="hljs-built_in">printf</span>(<span class="hljs-string">"\t"</span>);
			}
			<span class="hljs-built_in">printf</span>(<span class="hljs-string">"\t%d"</span>, G-&gt;arcs[i][j]);
		}
		<span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n\n"</span>);
	}
}

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">DFS</span><span class="hljs-params">(Graph* G, <span class="hljs-keyword">int</span>* visited, <span class="hljs-keyword">int</span> index)</span>
</span>{
	<span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\t"</span>, index + <span class="hljs-number">1</span>);
	visited[index] = <span class="hljs-number">1</span>;
	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; G-&gt;vexNum; i++)
	{
		<span class="hljs-keyword">if</span> (G-&gt;arcs[index][i] &gt; <span class="hljs-number">0</span> &amp;&amp; G-&gt;arcs[index][i] != MAX &amp;&amp; visited[i] != <span class="hljs-number">1</span>)
		{
			DFS(G, visited, i);
		}
	}
}

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">DFS_Extended</span><span class="hljs-params">(Graph *G, <span class="hljs-keyword">int</span> *visited)</span>
</span>{
	DFS(G, visited, <span class="hljs-number">0</span>);
	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; G-&gt;vexNum; i++)
	{
		<span class="hljs-keyword">if</span> (visited[i] != <span class="hljs-number">1</span>)
		{
			DFS(G, visited, i);
		}
	}
}

<span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Stack</span>
{</span>
	<span class="hljs-keyword">int</span> data;
	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Stack</span>* <span class="hljs-title">next</span>;</span>
}Stack, * StackPtr;

<span class="hljs-function">Stack* <span class="hljs-title">initStack</span><span class="hljs-params">()</span>
</span>{
	Stack* <span class="hljs-built_in">stack</span> = (Stack*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(Stack));
	<span class="hljs-built_in">stack</span>-&gt;data = <span class="hljs-number">0</span>;
	<span class="hljs-built_in">stack</span>-&gt;next = <span class="hljs-literal">NULL</span>;
	<span class="hljs-keyword">return</span> <span class="hljs-built_in">stack</span>;
}

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">isEmpty</span><span class="hljs-params">(Stack* <span class="hljs-built_in">stack</span>)</span>
</span>{
	<span class="hljs-keyword">if</span> (<span class="hljs-built_in">stack</span>-&gt;next == <span class="hljs-literal">NULL</span>)
	{
		<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
	}
	<span class="hljs-keyword">else</span>
	{
		<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
	}
}

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">push</span><span class="hljs-params">(Stack* <span class="hljs-built_in">stack</span>, <span class="hljs-keyword">int</span> data)</span>
</span>{
	Stack* s = (Stack*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(Stack));
	s-&gt;data = data;
	s-&gt;next = <span class="hljs-built_in">stack</span>-&gt;next;
	<span class="hljs-built_in">stack</span>-&gt;next = s;
}

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">pop</span><span class="hljs-params">(Stack* <span class="hljs-built_in">stack</span>)</span>
</span>{
	<span class="hljs-keyword">if</span> (!isEmpty(<span class="hljs-built_in">stack</span>))
	{
		Stack* s = <span class="hljs-built_in">stack</span>-&gt;next;
		<span class="hljs-built_in">stack</span>-&gt;next = s-&gt;next;
		<span class="hljs-keyword">return</span> s-&gt;data;
	}
	<span class="hljs-keyword">else</span>
	{
		<span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;
	}
}

<span class="hljs-function"><span class="hljs-keyword">int</span>* <span class="hljs-title">FindInDegrees</span><span class="hljs-params">(Graph* G)</span>
</span>{
	<span class="hljs-keyword">int</span>* inDegrees = (<span class="hljs-keyword">int</span>*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>) * G-&gt;vexNum);
	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; G-&gt;vexNum; i++)
	{
		inDegrees[i] = <span class="hljs-number">0</span>;
	}
	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; G-&gt;vexNum; i++)
	{
		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; G-&gt;vexNum; j++)
		{
			<span class="hljs-keyword">if</span> ( G-&gt;arcs[i][j] &gt; <span class="hljs-number">0</span> &amp;&amp; G-&gt;arcs[i][j] != MAX)
			{
				inDegrees[j]++;
			}
		}
	}
	<span class="hljs-keyword">return</span> inDegrees;
}

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">ToologicalSort</span><span class="hljs-params">(Graph* G, <span class="hljs-keyword">int</span> *inDegrees, <span class="hljs-keyword">int</span> *tp)</span>
</span>{
	<span class="hljs-keyword">int</span> index = <span class="hljs-number">0</span>;
	Stack* <span class="hljs-built_in">stack</span> = initStack();
	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; G-&gt;vexNum; i++)
	{
		<span class="hljs-keyword">if</span> (inDegrees[i] == <span class="hljs-number">0</span>)
		{
			push(<span class="hljs-built_in">stack</span>, i); 
			inDegrees[i]--;		<span class="hljs-comment">//已经入栈准备输出，置为-1，避免再次入栈</span>
		}
	}
	<span class="hljs-keyword">while</span> (!isEmpty(<span class="hljs-built_in">stack</span>))
	{
		<span class="hljs-keyword">int</span> top = pop(<span class="hljs-built_in">stack</span>);
		tp[index++] = top;
		<span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\t"</span>, top + <span class="hljs-number">1</span>);
		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>; k &lt; G-&gt;vexNum; k++)
		{
			<span class="hljs-keyword">if</span> (G-&gt;arcs[top][k] &gt; <span class="hljs-number">0</span> &amp;&amp; G-&gt;arcs[top][k] != MAX)
			{
				inDegrees[k]--;
			}
		}
		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> m = <span class="hljs-number">0</span>; m &lt; G-&gt;vexNum; m++)
		{
			<span class="hljs-keyword">if</span> (inDegrees[m] == <span class="hljs-number">0</span>)
			{
				push(<span class="hljs-built_in">stack</span>, m);
				inDegrees[m]--;
			}
		}
	}
}

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">ToologicalSort2</span><span class="hljs-params">(Graph* G, <span class="hljs-keyword">int</span>* inDegrees)</span>
</span>{
	Stack* <span class="hljs-built_in">stack</span> = initStack();
	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; G-&gt;vexNum; i++)	
		<span class="hljs-keyword">if</span> (inDegrees[i] == <span class="hljs-number">0</span>)		
			push(<span class="hljs-built_in">stack</span>, i);		
	
	<span class="hljs-keyword">while</span> (!isEmpty(<span class="hljs-built_in">stack</span>))
	{
		<span class="hljs-keyword">int</span> top = pop(<span class="hljs-built_in">stack</span>);
		<span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\t"</span>, top + <span class="hljs-number">1</span>);
		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>; k &lt; G-&gt;vexNum; k++)
		{
			<span class="hljs-keyword">if</span> (G-&gt;arcs[top][k] &gt; <span class="hljs-number">0</span> &amp;&amp; G-&gt;arcs[top][k] != MAX)
			{
				inDegrees[k]--;
				<span class="hljs-keyword">if</span> (inDegrees[k] == <span class="hljs-number">0</span>)
					push(<span class="hljs-built_in">stack</span>, k);
			}
		}						
	}
}

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span>* argv[])</span>
</span>{
	Graph* G = (Graph*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(Graph));
	CreateGraph(G);
	<span class="hljs-built_in">printf</span>(<span class="hljs-string">"序号:\t"</span>);
	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; G-&gt;vexNum; i++) {
		<span class="hljs-built_in">printf</span>(<span class="hljs-string">"\t%d"</span>, i);
	}
	<span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n"</span>);
	printMGraph(G);
	<span class="hljs-keyword">int</span>* visited = (<span class="hljs-keyword">int</span>*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>) * G-&gt;vexNum);
	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; G-&gt;vexNum; i++)
		visited[i] = <span class="hljs-number">0</span>;
	<span class="hljs-built_in">printf</span>(<span class="hljs-string">"DFS:\t\t"</span>);
	DFS_Extended(G, visited);
	<span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n"</span>);
	
	<span class="hljs-keyword">int</span>* tp = (<span class="hljs-keyword">int</span>*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>) * G-&gt;vexNum);
	<span class="hljs-keyword">int</span>* inDegrees = FindInDegrees(G);
	<span class="hljs-built_in">printf</span>(<span class="hljs-string">"\ninDegrees[]:\n\t"</span>);
	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; G-&gt;vexNum; i++)
	{
		<span class="hljs-built_in">printf</span>(<span class="hljs-string">"\t%d"</span>, inDegrees[i]);
	}
	<span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n\nTopological Order:\n\t\t"</span>);
	ToologicalSort(G, inDegrees, tp);
	
	<span class="hljs-built_in">printf</span>(<span class="hljs-string">"\ntp[]:\n\t"</span>);
	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; G-&gt;vexNum; i++)
		<span class="hljs-built_in">printf</span>(<span class="hljs-string">"\t%d"</span>, tp[i]+<span class="hljs-number">1</span>);
	<span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n"</span>);

	<span class="hljs-keyword">int</span>* inDegrees2 = FindInDegrees(G);
	<span class="hljs-built_in">printf</span>(<span class="hljs-string">"\ninDegrees2[]:\n\t"</span>);
	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; G-&gt;vexNum; i++)
	{
		<span class="hljs-built_in">printf</span>(<span class="hljs-string">"\t%d"</span>, inDegrees2[i]);
	}
	<span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n\nTopological Order 2:\n\t\t"</span>);
	ToologicalSort(G, inDegrees2);
	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}

</div></code></pre>
<h3 id="67-a-name-1a%E5%85%B3%E9%94%AE%E8%B7%AF%E5%BE%84">6.7. <a name='-1'></a>关键路径</h3>
<h4 id="671-a-name-1a%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5">6.7.1. <a name='-1'></a>基本概念</h4>
<h5 id="aoe%E7%BD%91-activity-on-edge-network">AOE网 Activity On Edge Network</h5>
<ol>
<li>表示工程的<strong>带权有向图</strong></li>
<li>顶点表示事件</li>
<li>有向边表示活动</li>
<li>边上权值表示活动持续时间</li>
</ol>
<h5 id="%E4%BA%8B%E4%BB%B6%E7%9A%84%E6%9C%80%E6%97%A9%E5%8F%91%E7%94%9F%E6%97%B6%E9%97%B4etv-earliest-time-of-vertex">事件的最早发生时间etv (earliest time of vertex)</h5>
<p>$即顶点v_k的最早发生时间,也记为Ve$
注意:</p>
<ol>
<li>“发生”是针对于事件的，也就是图中的顶点。</li>
<li>只有在指向该顶点的<strong>所有</strong>有向边对应的活动结束，该顶点所代表的事件才发生。
$求顶点v_k最早发生时间的公式是$
$$
{\rm VE}[k] = \begin{cases}
0,\qquad\qquad\qquad\qquad\qquad\qquad 当k=0时\
{\rm max}\left{{\rm VE}[i]+{\rm len}&lt;v_i,v_k&gt;\right},当k\neq 0且&lt;v_i,v_k&gt;\in {\rm P}[k]时 \quad \
\end{cases}
$$
$其中{\rm P}[k]表示所有到达顶点v_k的弧集合$</li>
</ol>
<h5 id="%E4%BA%8B%E4%BB%B6%E7%9A%84%E6%9C%80%E6%99%9A%E5%8F%91%E7%94%9F%E6%97%B6%E9%97%B4ltv-latest-time-of-vertex">事件的最晚发生时间ltv (latest time of vertex)</h5>
<p>$即顶点v_k的最晚发生时间,即最晚需要开始对应事件的时间,超出此时间会延误整个工期,也记为Vl$</p>
<h5 id="%E6%B4%BB%E5%8A%A8%E7%9A%84%E6%9C%80%E6%97%A9%E5%BC%80%E5%B7%A5%E6%97%B6%E9%97%B4ete-earliest-time-of-edge">活动的最早开工时间ete (earliest time of edge)</h5>
<p>$即弧a_k的最晚发生时间$</p>
<p>注意:</p>
<ol>
<li>“开始”是针对于活动的</li>
<li>只有在一个顶点所代表的事件发生后，从该顶点出发的所有边对应的活动才能开始。
$$
{\rm VL}[k] = \begin{cases}
{\rm VE}[k],\quad\quad\qquad\qquad\qquad\qquad 当k=n-1时\
{\rm min}\left{{\rm VL}[j]+{\rm len}&lt;v_k,v_j&gt;\right},当k&lt;n-1且&lt;v_k,v_j&gt;\in {\rm S}[k]时 \quad \
\end{cases}
$$
$其中{\rm S}[k]表示所有从顶点v_k出发的弧集合$</li>
</ol>
<h5 id="%E6%B4%BB%E5%8A%A8%E7%9A%84%E6%9C%80%E6%99%9A%E5%BC%80%E5%B7%A5%E6%97%B6%E9%97%B4lte-latest-time-of-edge">活动的最晚开工时间lte (latest time of edge)</h5>
<p>$即弧a_k的最晚发生时间,即不推迟工期的最晚开工时间$</p>
<p><a href="https://blog.csdn.net/qq_45831414/article/details/110395645">关于&quot;发生&quot;与&quot;开始&quot;</a></p>
<h5 id="%E6%97%B6%E9%97%B4%E4%BD%99%E9%87%8F">时间余量</h5>
<p>$$活动的最晚开工时间-活动的最早开工时间$$
$即$
$$L(l)-L(e)$$</p>
<h5 id="%E8%B7%AF%E5%BE%84%E9%95%BF%E5%BA%A6">路径长度</h5>
<p>$各个活动所持续的时间之和$</p>
<h5 id="%E5%85%B3%E9%94%AE%E6%B4%BB%E5%8A%A8%E5%85%B3%E9%94%AE%E8%B7%AF%E5%BE%84">关键活动、关键路径</h5>
<p>$①最早开始时间和最晚开始时间相等的活动称为关键活动\
②关键活动间的路径成为关键路径,也是从源点到汇点具有最大长度的路径$</p>
<h4 id="672-a-name-1a%E5%85%B3%E9%94%AE%E8%B7%AF%E5%BE%84%E7%9A%84%E7%AE%97%E6%B3%95">6.7.2. <a name='-1'></a>关键路径的算法</h4>
<h5 id="%E5%9F%BA%E4%BA%8E%E9%82%BB%E6%8E%A5%E8%A1%A8%E7%9A%84%E4%BB%A3%E7%A0%81">基于邻接表的代码</h5>
<p>$$首先要进行拓扑排序求得拓扑序列并保存在栈中$$</p>
<pre class="hljs"><code><div><span class="hljs-keyword">int</span>* VE;	<span class="hljs-comment">//记录时间最早发生时间的数组</span>
<span class="hljs-keyword">int</span>* VL;	<span class="hljs-comment">//记录时间最晚发生时间的数组</span>
<span class="hljs-keyword">int</span>* stack_TpOrder;<span class="hljs-comment">//存储拓扑序列的栈</span>
<span class="hljs-keyword">int</span> top_TpOrder;

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">ToologicalSort</span><span class="hljs-params">(ALGraph* GL)</span>
</span>{
	<span class="hljs-built_in">printf</span>(<span class="hljs-string">"拓扑序列为：\n\n\t"</span>);

	<span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;		<span class="hljs-comment">//记录已经输出的顶点数量</span>

	<span class="hljs-keyword">int</span>* <span class="hljs-built_in">stack</span> = (<span class="hljs-keyword">int</span>*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>) * GL-&gt;vexNum);	<span class="hljs-comment">//顺序栈</span>
	<span class="hljs-keyword">int</span> top = <span class="hljs-number">-1</span>;		<span class="hljs-comment">//规定为-1,方便后续操作</span>
	<span class="hljs-keyword">int</span> getTop;			<span class="hljs-comment">//取栈顶值</span>
	<span class="hljs-comment">//栈里的值为顶点对应的序号</span>

	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; GL-&gt;vexNum; i++)
		<span class="hljs-keyword">if</span> (GL-&gt;List[i].in == <span class="hljs-number">0</span>)		<span class="hljs-comment">//将入度为0的顶点入栈</span>
			<span class="hljs-built_in">stack</span>[++top] = i;			<span class="hljs-comment">//top记得++</span>

<span class="hljs-comment">//******************************************************************</span>
	top_TpOrder = <span class="hljs-number">-1</span>;										<span class="hljs-comment">//初始化</span>
	VE = (<span class="hljs-keyword">int</span>*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>) * GL-&gt;vexNum);			<span class="hljs-comment">//初始化</span>
	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; GL-&gt;vexNum; i++)				 <span class="hljs-comment">//初始化为0</span>
		VE[i] = <span class="hljs-number">0</span>;
	stack_TpOrder = (<span class="hljs-keyword">int</span>*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>) * GL-&gt;vexNum);	<span class="hljs-comment">//初始化</span>
<span class="hljs-comment">//******************************************************************</span>

	arcNode* e;			<span class="hljs-comment">//用来遍历顶点对应的边表</span>
	<span class="hljs-keyword">int</span> flag = <span class="hljs-number">0</span>;		<span class="hljs-comment">//控制"-&gt;"的输出数量</span>
	<span class="hljs-keyword">while</span> (top != <span class="hljs-number">-1</span>)	<span class="hljs-comment">//栈非空</span>
	{
		getTop = <span class="hljs-built_in">stack</span>[top--];		<span class="hljs-comment">//取栈顶值并出栈</span>
		<span class="hljs-comment">//专注于关键路径,这里可以不输出拓扑排序结果 printf("V%d", (int)(GL-&gt;List[getTop].vex - 'a') + 1);	//输出序列</span>
		<span class="hljs-keyword">if</span> (flag != GL-&gt;vexNum - <span class="hljs-number">1</span>)		<span class="hljs-comment">//n个顶点应该有n-1个"-&gt;"</span>
		{
			<span class="hljs-built_in">printf</span>(<span class="hljs-string">" -&gt; "</span>);
			flag++;
		}
		count++;	<span class="hljs-comment">//已输出顶点数++</span>

<span class="hljs-comment">//******************************************************************************</span>
		stack_TpOrder[++top_TpOrder] = getTop;	<span class="hljs-comment">//将弹出的顶点序号压入拓扑序列栈</span>
<span class="hljs-comment">//******************************************************************************</span>

		<span class="hljs-keyword">for</span> (e = GL-&gt;List[getTop].First; e; e = e-&gt;next)	<span class="hljs-comment">//遍历边表</span>
		{
			<span class="hljs-keyword">int</span> k = e-&gt;vex_num;		<span class="hljs-comment">//k记录当前顶点序号</span>
			GL-&gt;List[k].in--;		<span class="hljs-comment">//由于上个顶点以删除,故入度-1</span>
			<span class="hljs-keyword">if</span> (GL-&gt;List[k].in == <span class="hljs-number">0</span>)	<span class="hljs-comment">//将入度为0的顶点入栈</span>
				<span class="hljs-built_in">stack</span>[++top] = k;

<span class="hljs-comment">//***********************************************************************		</span>
			<span class="hljs-keyword">if</span> (VE[getTop] + e-&gt;weight &gt; VE[k])		<span class="hljs-comment">// 求各顶点时间的					</span>
				VE[k] = VE[getTop] + e-&gt;weight;	<span class="hljs-comment">//最早发生时间etv的值</span>
<span class="hljs-comment">//***********************************************************************</span>

		}
	}
	<span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n"</span>);
	<span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n"</span>);

	<span class="hljs-built_in">printf</span>(<span class="hljs-string">"最早发生时间的数组：\n\n"</span>);
	<span class="hljs-built_in">printf</span>(<span class="hljs-string">"\t序号\t"</span>);
	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; GL-&gt;vexNum; i++)
		<span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\t"</span>, i);
	<span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n\n\t\t"</span>);
	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; GL-&gt;vexNum; i++)
		<span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\t"</span>, VE[i]);
	<span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n"</span>);

	<span class="hljs-keyword">if</span> (count &lt; GL-&gt;vexNum)		<span class="hljs-comment">//输出顶点数量小于总顶点数说明存在环路</span>
	{
		<span class="hljs-built_in">printf</span>(<span class="hljs-string">"\t有环！\n"</span>);
		<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
	}
	<span class="hljs-keyword">else</span>
		<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
}
</div></code></pre>
<p>$$接着才是关键路径的求解\
①求时间指标\②求活动指标\③求时间余量$$</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">CriticalPath</span><span class="hljs-params">(ALGraph* GL)</span>
</span>{
	<span class="hljs-keyword">int</span> ete, lte;		<span class="hljs-comment">//声明活动最早发生时间和最晚发生时间的变量</span>
	<span class="hljs-keyword">int</span> getTop;			<span class="hljs-comment">//取栈顶值</span>
	ToologicalSort(GL);	<span class="hljs-comment">//先进行拓扑排序，保存拓扑序列栈，计算各顶点最早发生时间etv数组的值</span>
	
	VL = (<span class="hljs-keyword">int</span>*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>) * GL-&gt;vexNum);	<span class="hljs-comment">//事件最晚发生时间数组</span>
	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; GL-&gt;vexNum; i++)			<span class="hljs-comment">//从汇点开始</span>
		VL[i] = VE[GL-&gt;vexNum - <span class="hljs-number">1</span>];				<span class="hljs-comment">//让最晚发生时间初始化为汇点最早发生时间</span>

	<span class="hljs-keyword">while</span> (top_TpOrder != <span class="hljs-number">-1</span>)	<span class="hljs-comment">//栈非空</span>
	{
		getTop = stack_TpOrder[top_TpOrder--];		<span class="hljs-comment">//取栈顶</span>
		<span class="hljs-keyword">for</span> (arcNode* e = GL-&gt;List[getTop].First ; e; e = e-&gt;next)	<span class="hljs-comment">//遍历边表,修改最晚发生时间数组的值</span>
		{
			<span class="hljs-keyword">int</span> k = e-&gt;vex_num;		<span class="hljs-comment">//当前访问顶点序号</span>
			<span class="hljs-keyword">if</span> (VL[k] - e-&gt;weight &lt; VL[getTop])		<span class="hljs-comment">//更新当前顶点最晚发生时间</span>
				VL[getTop] = VL[k] - e-&gt;weight;		<span class="hljs-comment">//最晚发生时间要不影响后续的最晚发生时间,故取小的值</span>
		}
	}

	<span class="hljs-built_in">printf</span>(<span class="hljs-string">"最晚发生时间的数组：\n\n"</span>);		<span class="hljs-comment">//输出最晚发生时间的数组</span>
	<span class="hljs-built_in">printf</span>(<span class="hljs-string">"\t序号\t"</span>);
	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; GL-&gt;vexNum; i++)
		<span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\t"</span>, i);
	<span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n\n\t\t"</span>);
	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; GL-&gt;vexNum; i++)
		<span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\t"</span>, VL[i]);
	<span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n"</span>);

	<span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n关键路径为：\n\t"</span>);			<span class="hljs-comment">//输出关键路径</span>
	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; GL-&gt;vexNum; j++)
	{
		<span class="hljs-keyword">for</span> (arcNode* e = GL-&gt;List[j].First; e; e = e-&gt;next)
		{
			<span class="hljs-keyword">int</span> k = e-&gt;vex_num;
			ete = VE[j];				<span class="hljs-comment">//活动的最早发生时间</span>
			lte = VL[k] - e-&gt;weight;	<span class="hljs-comment">//活动的最迟发生时间</span>
			<span class="hljs-keyword">if</span> (ete == lte)				<span class="hljs-comment">//相等即在关键路径上</span>
			{
				<span class="hljs-keyword">if</span> (j == <span class="hljs-number">0</span>)
					<span class="hljs-built_in">printf</span>(<span class="hljs-string">"V%d "</span>, (<span class="hljs-keyword">int</span>)(GL-&gt;List[j].vex - <span class="hljs-string">'a'</span>));
				<span class="hljs-built_in">printf</span>(<span class="hljs-string">"--&gt;"</span>);
				<span class="hljs-built_in">printf</span>(<span class="hljs-string">" V%d "</span>, (<span class="hljs-keyword">int</span>)(GL-&gt;List[k].vex - <span class="hljs-string">'a'</span>));
			}
		}
	}
	<span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n"</span>);
}

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span>* argv[])</span>
</span>{
	ALGraph* GL = CreateALGraph();
	CriticalPath(GL);
	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</div></code></pre>
<h5 id="%E5%9F%BA%E4%BA%8E%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5%E7%9A%84%E4%BB%A3%E7%A0%81">基于邻接矩阵的代码</h5>
<p>在关键路径完整代码的基础上增加一下两个函数</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getIndex</span><span class="hljs-params">(<span class="hljs-keyword">int</span>* tp, <span class="hljs-keyword">int</span> i, Graph *G)</span>		<span class="hljs-comment">//返回顶点i在拓扑序列里面的位置</span>
</span>{
	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> index = <span class="hljs-number">0</span>; index &lt; G-&gt;vexNum; index++)
		<span class="hljs-keyword">if</span> (tp[index] == i)
			<span class="hljs-keyword">break</span>;
	<span class="hljs-keyword">return</span> index;
}
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">CriticalPath</span><span class="hljs-params">(Graph* G, <span class="hljs-keyword">int</span>* tp)</span>
</span>{
	<span class="hljs-keyword">int</span>* early = (<span class="hljs-keyword">int</span>*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>) * G-&gt;vexNum);		<span class="hljs-comment">//最早发生时间数组</span>
	<span class="hljs-keyword">int</span>* late = (<span class="hljs-keyword">int</span>*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>) * G-&gt;vexNum);		<span class="hljs-comment">//最晚发生时间数组</span>
	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; G-&gt;vexNum; i++)			<span class="hljs-comment">//两个数组初始化为0</span>
		early[i] = late[i] = <span class="hljs-number">0</span>;

	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; G-&gt;vexNum; i++)		<span class="hljs-comment">//生成最早发生时间数组</span>
	{	<span class="hljs-comment">//直接从顶点1开始就可以了,0没有必要比较</span>
		<span class="hljs-keyword">int</span> index = getIndex(tp, i, G);		<span class="hljs-comment">//i作为弧尾,得到顶点i在拓扑序列中的位置</span>
		<span class="hljs-keyword">int</span> <span class="hljs-built_in">max</span> = <span class="hljs-number">0</span>;	<span class="hljs-comment">//初始化最大值</span>
		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; index; j++)		<span class="hljs-comment">//j表示拓扑序列的第j个位置,只需要在index之前找就可以了,不必遍历全部</span>
			<span class="hljs-keyword">if</span> (G-&gt;arcs[tp[j]][i] &gt; <span class="hljs-number">0</span> &amp;&amp; G-&gt;arcs[tp[j]][i] != MAX)	<span class="hljs-comment">//有弧,top[j]作为弧头</span>
				<span class="hljs-keyword">if</span> (G-&gt;arcs[tp[j]][i] + early[tp[j]] &gt; <span class="hljs-built_in">max</span>)		
					<span class="hljs-built_in">max</span> = G-&gt;arcs[tp[j]][i] + early[tp[j]];		<span class="hljs-comment">//更新最大值	</span>
		early[i] = <span class="hljs-built_in">max</span>;		<span class="hljs-comment">//得到顶点i的最早发生时间</span>
	}

	<span class="hljs-built_in">printf</span>(<span class="hljs-string">"early[]:\n\t"</span>);		<span class="hljs-comment">//输出最早发生时间数组</span>
	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; G-&gt;vexNum; i++)
		<span class="hljs-built_in">printf</span>(<span class="hljs-string">"\t%d"</span>, early[i]);

	late[(G-&gt;vexNum) - <span class="hljs-number">1</span>] = early[(G-&gt;vexNum) - <span class="hljs-number">1</span>];		<span class="hljs-comment">//从汇点开始</span>
	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = G-&gt;vexNum - <span class="hljs-number">2</span>; i &gt;= <span class="hljs-number">0</span>; i--)		<span class="hljs-comment">//生成最晚发生时间数组,同样的道理，汇点没有必要判断</span>
	{
		<span class="hljs-keyword">int</span> <span class="hljs-built_in">min</span> = late[(G-&gt;vexNum) - <span class="hljs-number">1</span>];	<span class="hljs-comment">//初始化最大值</span>
		<span class="hljs-keyword">int</span> index2 = getIndex(tp, i, G);	<span class="hljs-comment">//这里的顶点i作为弧头,返回顶点i在拓扑序列中的位置</span>
		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = (G-&gt;vexNum) - <span class="hljs-number">1</span>; j  &gt; index2; j--)		<span class="hljs-comment">//j是拓扑序列中的第j个位置,只要在index2的后面找,不必全部遍历判断</span>
			<span class="hljs-keyword">if</span> (G-&gt;arcs[i][tp[j]] &gt; <span class="hljs-number">0</span> &amp;&amp; G-&gt;arcs[i][tp[j]] != MAX)	<span class="hljs-comment">//有弧,top[j]作为弧尾	</span>
				<span class="hljs-keyword">if</span> (late[tp[j]] - G-&gt;arcs[i][tp[j]] &lt; <span class="hljs-built_in">min</span>)					
					<span class="hljs-built_in">min</span> = late[tp[j]] - G-&gt;arcs[i][tp[j]];			<span class="hljs-comment">//更新最小值				</span>
		late[i] = <span class="hljs-built_in">min</span>;		<span class="hljs-comment">//得到顶点i的最晚发生时间</span>
	}

	<span class="hljs-built_in">printf</span>(<span class="hljs-string">"\nlate[]:\n\t"</span>);		<span class="hljs-comment">//输出最晚发生时间数组</span>
	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; G-&gt;vexNum; i++)
		<span class="hljs-built_in">printf</span>(<span class="hljs-string">"\t%d"</span>, late[i]);

	<span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n关键路径：\n\t"</span>);
	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; G-&gt;vexNum; i++) {	<span class="hljs-comment">//顶点i作为弧尾</span>
		<span class="hljs-keyword">int</span> index_c = getIndex(tp, i, G);	<span class="hljs-comment">//先得到顶点i在拓扑序列中的位置</span>
		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; index_c; j++) {	<span class="hljs-comment">//j是拓扑序列中的第j个顶点,在index_c之前找就可以了</span>
			<span class="hljs-keyword">if</span> (G-&gt;arcs[tp[j]][i] &gt; <span class="hljs-number">0</span> &amp;&amp; G-&gt;arcs[tp[j]][i] != MAX) {	<span class="hljs-comment">//有弧,top[j]是弧头</span>
				<span class="hljs-keyword">if</span> (late[i] - G-&gt;arcs[tp[j]][i] == early[tp[j]]) {		<span class="hljs-comment">//时间余量为0</span>
					<span class="hljs-built_in">printf</span>(<span class="hljs-string">"\t%d -(%d)-&gt; %d"</span>, tp[j], G-&gt;arcs[tp[j]][i], i);		<span class="hljs-comment">//输出路径</span>
				}
			}
		}
	}
	<span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n"</span> );
}
</div></code></pre>
<h2 id="7-a-name-1a%E6%9F%A5%E6%89%BE">7. <a name='-1'></a>查找</h2>
<h3 id="71-a-name-1a%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5">7.1. <a name='-1'></a>基本概念</h3>
<h4 id="711-a-namesearchtablea%E6%9F%A5%E6%89%BE%E8%A1%A8-search-table">7.1.1. <a name='SearchTable'></a>查找表 Search Table</h4>
<pre><code>同一类型的数据元素(或记录)构成的集合
</code></pre>
<h4 id="712-a-namekeya%E5%85%B3%E9%94%AE%E5%AD%97-key">7.1.2. <a name='Key'></a>关键字 Key</h4>
<pre><code>数据元素中某个数据项的值
</code></pre>
<h4 id="713-a-namesecondarykeya%E6%AC%A1%E5%85%B3%E9%94%AE%E5%AD%97-secondary-key">7.1.3. <a name='SecondaryKey'></a>次关键字 Secondary Key</h4>
<pre><code>可以识别多个数据元素(或记录)的关键字
</code></pre>
<h4 id="714-a-namestaticsearchtablea%E9%9D%99%E6%80%81%E6%9F%A5%E6%89%BE%E8%A1%A8-static-search-table">7.1.4. <a name='StaticSearchTable'></a>静态查找表 Static Search Table</h4>
<pre><code>只做查找操作的查找表
</code></pre>
<h4 id="715-a-namedynamicsearchtablea%E5%8A%A8%E6%80%81%E6%9F%A5%E6%89%BE%E8%A1%A8-dynamic-search-table">7.1.5. <a name='DynamicSearchTable'></a>动态查找表 Dynamic Search Table</h4>
<pre><code>在查找的过程中同时进行插入或删除数据元素的操作
</code></pre>
<h4 id="716-a-nameasla%E5%B9%B3%E5%9D%87%E6%9F%A5%E6%89%BE%E9%95%BF%E5%BA%A6asl">7.1.6. <a name='ASL'></a>平均查找长度ASL</h4>
<p>$$ASL=\sum_{i=1}^n P_iC_i\其中P_i是元素i被查找的概率\C_i是查到元素i时的查找次数$$</p>
<h3 id="72-a-name-1a%E9%A1%BA%E5%BA%8F%E8%A1%A8%E6%9F%A5%E6%89%BE">7.2. <a name='-1'></a>顺序表查找</h3>
<p>$$ASL_{success}=\frac{1}{n}\sum_{i=1}^n C_i =\frac{1}{n} \frac{n(n+1)}{2} =\frac{n+1}{2} $$
$$ASL_{fail}=\frac{1}{n}\sum_{i=1}^n C_i =\frac{1}{n} {n(n+1)} =n+1$$</p>
<h4 id="721-a-name-1a%E6%99%AE%E9%80%9A%E6%B3%95">7.2.1. <a name='-1'></a>普通法</h4>
<pre class="hljs"><code><div><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> _CRT_SECURE_NO_WARNINGS</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;windows.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;conio.h&gt;</span></span>

<span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">List</span>
{</span>
	<span class="hljs-keyword">int</span> *data;
	<span class="hljs-keyword">int</span> length;
	<span class="hljs-keyword">int</span> num;
}List, * ListPtr;

<span class="hljs-function">List* <span class="hljs-title">initList</span><span class="hljs-params">(<span class="hljs-keyword">int</span> length)</span>
</span>{
	List* L = (ListPtr)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(List));
	L-&gt;data = (<span class="hljs-keyword">int</span>*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>) * length);
	L-&gt;length = length;
	L-&gt;num = <span class="hljs-number">0</span>;
	<span class="hljs-keyword">return</span> L;
}

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">addList</span><span class="hljs-params">(List* L, <span class="hljs-keyword">int</span> data)</span>
</span>{
	L-&gt;data[L-&gt;num++] = data;
}

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">printList</span><span class="hljs-params">(List* L)</span>
</span>{
	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; L-&gt;num; i++) {
		<span class="hljs-built_in">printf</span>(<span class="hljs-string">"\t%d"</span>, L-&gt;data[i]);
	}
}

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">searchList</span><span class="hljs-params">(List* L, <span class="hljs-keyword">int</span> key)</span>
</span>{
	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; L-&gt;num; i++) {
		<span class="hljs-keyword">if</span> (L-&gt;data[i] == key)
			<span class="hljs-keyword">return</span> i;
	}
	<span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;
}

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span>* argv[])</span>
</span>{
	List* L = initList(<span class="hljs-number">10</span>);
	addList(L, <span class="hljs-number">2</span>);
	addList(L, <span class="hljs-number">3</span>);
	addList(L, <span class="hljs-number">7</span>);
	addList(L, <span class="hljs-number">5</span>);
	addList(L, <span class="hljs-number">4</span>);
	addList(L, <span class="hljs-number">0</span>);
	addList(L, <span class="hljs-number">6</span>);
	addList(L, <span class="hljs-number">8</span>);
	printList(L);
	<span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n"</span>);
	<span class="hljs-built_in">printf</span>(<span class="hljs-string">"\t%d"</span>, searchList(L, <span class="hljs-number">4</span>));
	<span class="hljs-built_in">printf</span>(<span class="hljs-string">"\t%d"</span>, searchList(L, <span class="hljs-number">3</span>));
	<span class="hljs-built_in">printf</span>(<span class="hljs-string">"\t%d"</span>, searchList(L, <span class="hljs-number">7</span>));
	<span class="hljs-built_in">printf</span>(<span class="hljs-string">"\t%d"</span>, searchList(L, <span class="hljs-number">10</span>));
	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</div></code></pre>
<h4 id="722-a-namesentrya%E4%BC%98%E5%8C%96%E6%B3%95%E8%AE%BE%E7%BD%AE%E5%93%A8%E5%85%B5sentry">7.2.2. <a name='sentry'></a>优化法(设置哨兵)sentry</h4>
<pre class="hljs"><code><div><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> _CRT_SECURE_NO_WARNINGS</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;windows.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;conio.h&gt;</span></span>

<span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">List</span>
{</span>
	<span class="hljs-keyword">int</span>* data;
	<span class="hljs-keyword">int</span> length;
	<span class="hljs-keyword">int</span> num;
}List, * ListPtr;

<span class="hljs-function">List* <span class="hljs-title">initList</span><span class="hljs-params">(<span class="hljs-keyword">int</span> length)</span>
</span>{
	List* L = (ListPtr)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(List));
	L-&gt;data = (<span class="hljs-keyword">int</span>*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>) * length);
	L-&gt;length = length;
	L-&gt;num = <span class="hljs-number">1</span>;
	<span class="hljs-keyword">return</span> L;
}

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">addList</span><span class="hljs-params">(List* L, <span class="hljs-keyword">int</span> data)</span>
</span>{
	L-&gt;data[L-&gt;num++] = data;
}

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">printList</span><span class="hljs-params">(List* L)</span>
</span>{
	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; L-&gt;num; i++) {
		<span class="hljs-built_in">printf</span>(<span class="hljs-string">"\t%d"</span>, L-&gt;data[i]);
	}
}

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">searchList_sentry</span><span class="hljs-params">(List* L, <span class="hljs-keyword">int</span> key)</span>
</span>{
	L-&gt;data[<span class="hljs-number">0</span>] = key;
	<span class="hljs-keyword">int</span> i;
	<span class="hljs-keyword">for</span> (i = L-&gt;num - <span class="hljs-number">1</span>; L-&gt;data[i] != key; i--){}
	<span class="hljs-keyword">return</span> i;
}

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span>* argv[])</span>
</span>{
	List* L = initList(<span class="hljs-number">10</span>);
	addList(L, <span class="hljs-number">2</span>);
	addList(L, <span class="hljs-number">3</span>);
	addList(L, <span class="hljs-number">7</span>);
	addList(L, <span class="hljs-number">5</span>);
	addList(L, <span class="hljs-number">4</span>);
	addList(L, <span class="hljs-number">0</span>);
	addList(L, <span class="hljs-number">6</span>);
	addList(L, <span class="hljs-number">8</span>);
	printList(L);
	<span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n"</span>);
	<span class="hljs-built_in">printf</span>(<span class="hljs-string">"\t%d"</span>, searchList_sentry(L, <span class="hljs-number">4</span>));
	<span class="hljs-built_in">printf</span>(<span class="hljs-string">"\t%d"</span>, searchList_sentry(L, <span class="hljs-number">10</span>));
	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}

</div></code></pre>
<h3 id="73-a-name-1a%E6%9C%89%E5%BA%8F%E8%A1%A8%E6%9F%A5%E6%89%BE">7.3. <a name='-1'></a>有序表查找</h3>
<h4 id="731-a-name-1a%E6%8A%98%E5%8D%8A%E6%9F%A5%E6%89%BE%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE">7.3.1. <a name='-1'></a>折半查找(二分查找)</h4>
<p>$$ASL_{success}=\frac{1}{n}\sum_{i=1}^n C_i =\frac{1}{n} \sum_{k=1}^{h}{k 2^{k-1}}=\frac{n+1}{n}log_2(n+1)-1\approx log_2(n+1)$$
$$ASL_{fail}:补全左右子节点为多出的结点,对每一层多出的结点个数乘以对应层数再求和即可$$</p>
<pre class="hljs"><code><div><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> _CRT_SECURE_NO_WARNINGS</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;windows.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;conio.h&gt;</span></span>

<span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">List</span>
{</span>
	<span class="hljs-keyword">int</span>* data;
	<span class="hljs-keyword">int</span> length;
}List, * ListPtr;

<span class="hljs-function">List* <span class="hljs-title">initList</span><span class="hljs-params">(<span class="hljs-keyword">int</span> length)</span>
</span>{
	List* L = (ListPtr)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(List));
	L-&gt;data = (<span class="hljs-keyword">int</span>*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>) * length);
	L-&gt;length = length;
	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; L-&gt;length; i++) {
		L-&gt;data[i] = i + <span class="hljs-number">1</span>;
	}
	<span class="hljs-keyword">return</span> L;
}

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">printList</span><span class="hljs-params">(List* L)</span>
</span>{
	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; L-&gt;length; i++) {
		<span class="hljs-built_in">printf</span>(<span class="hljs-string">"\t%d"</span>, L-&gt;data[i]);
	}
}

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">binarySearch</span><span class="hljs-params">(List* L, <span class="hljs-keyword">int</span> key)</span>		<span class="hljs-comment">//循环</span>
</span>{
	<span class="hljs-keyword">int</span> start = <span class="hljs-number">0</span>;
	<span class="hljs-keyword">int</span> end = L-&gt;length - <span class="hljs-number">1</span>;
	<span class="hljs-keyword">int</span> mid;
	<span class="hljs-keyword">while</span> (start &lt;= end) {
		mid = (start + end) / <span class="hljs-number">2</span>;
		<span class="hljs-keyword">if</span> (L-&gt;data[mid] &lt; key) {
			start = mid + <span class="hljs-number">1</span>;
		}
		<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (key &lt; L-&gt;data[mid]) {
			end = mid - <span class="hljs-number">1</span>;
		}
		<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (L-&gt;data[mid] == key)
			<span class="hljs-keyword">return</span> mid;
	}
	<span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;
}

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">binarySearch_recurs</span><span class="hljs-params">(List* L, <span class="hljs-keyword">int</span> key, <span class="hljs-keyword">int</span> start, <span class="hljs-keyword">int</span> end)</span>	<span class="hljs-comment">//递归法</span>
</span>{
	<span class="hljs-keyword">if</span> (start == end) {
		<span class="hljs-keyword">if</span> (L-&gt;data[start] == key)
			<span class="hljs-keyword">return</span> start;
		<span class="hljs-keyword">else</span>
			<span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;
	}
	<span class="hljs-keyword">int</span> mid = (start + end) / <span class="hljs-number">2</span>;
	<span class="hljs-keyword">if</span> (key &lt; L-&gt;data[mid]) {
		binarySearch_recurs(L, key, start, mid - <span class="hljs-number">1</span>);
	}
	<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (L-&gt;data[mid] &lt; key) {
		binarySearch_recurs(L, key, mid + <span class="hljs-number">1</span>, end);
	}
	<span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> mid;
}


<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span>* argv[])</span>
</span>{
	List* L = initList(<span class="hljs-number">10</span>);
	printList(L);
	<span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n"</span>);
	<span class="hljs-built_in">printf</span>(<span class="hljs-string">"\t%d"</span>, binarySearch(L,<span class="hljs-number">3</span>));
	<span class="hljs-built_in">printf</span>(<span class="hljs-string">"\t%d"</span>, binarySearch(L,<span class="hljs-number">5</span>));
	<span class="hljs-built_in">printf</span>(<span class="hljs-string">"\t%d"</span>, binarySearch(L,<span class="hljs-number">11</span>));
	<span class="hljs-built_in">printf</span>(<span class="hljs-string">"\t%d"</span>, binarySearch(L,<span class="hljs-number">1</span>));
	<span class="hljs-built_in">printf</span>(<span class="hljs-string">"\t%d"</span>, binarySearch_recurs(L, <span class="hljs-number">6</span>, <span class="hljs-number">0</span>, L-&gt;length - <span class="hljs-number">1</span>));
	<span class="hljs-built_in">printf</span>(<span class="hljs-string">"\t%d"</span>, binarySearch_recurs(L,<span class="hljs-number">99</span>,<span class="hljs-number">0</span>,L-&gt;length<span class="hljs-number">-1</span>));
	<span class="hljs-built_in">printf</span>(<span class="hljs-string">"\t%d"</span>, binarySearch_recurs(L,<span class="hljs-number">10</span>,<span class="hljs-number">0</span>,L-&gt;length<span class="hljs-number">-1</span>));
	<span class="hljs-built_in">printf</span>(<span class="hljs-string">"\t%d"</span>, binarySearch_recurs(L,<span class="hljs-number">9</span>,<span class="hljs-number">0</span>,L-&gt;length<span class="hljs-number">-1</span>));
	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}

<span class="hljs-comment">/*	OUTPUT
*	1       2       3		 4       5       6       7       8       9       10
*	2       4		-1		 0       5		 -1      9       8
*/</span>

</div></code></pre>
<h4 id="732-a-name-1a%E6%8F%92%E5%80%BC%E6%9F%A5%E6%89%BE">7.3.2. <a name='-1'></a>插值查找</h4>
<h4 id="733-a-name-1a%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%9F%A5%E6%89%BE">7.3.3. <a name='-1'></a>斐波那契查找</h4>
<h3 id="74-a-name-1a%E7%B4%A2%E5%BC%95%E6%9F%A5%E6%89%BE">7.4. <a name='-1'></a>索引查找</h3>
<h4 id="741-a-name-1a%E7%A8%A0%E5%AF%86%E7%B4%A2%E5%BC%95">7.4.1. <a name='-1'></a>稠密索引</h4>
<p>稠密索引是指再线性索引中,将数据集中的每个记录对应一个索引项,索引表中的索引项是按照关键码有序排列的.</p>
<h4 id="742-a-name-1a%E5%88%86%E5%9D%97%E7%B4%A2%E5%BC%95">7.4.2. <a name='-1'></a>分块索引</h4>
<p>$块间有序,块内无序$
$$ASL_{success} = \frac{1}{2}(\frac{n}{t}+t)+1\n个记录的数据集被平均分成m块,每个块中有t条记录\即有\ n = mt \ or \ m = \frac{n}{t}$$</p>
<h4 id="743-a-name-1a%E5%80%92%E6%8E%92%E7%B4%A2%E5%BC%95">7.4.3. <a name='-1'></a>倒排索引</h4>
<h3 id="75-a-namebstbinarysorttreea%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91-bstbinary-sort-tree">7.5. <a name='BSTBinarySortTree'></a>二叉排序树 BST(Binary Sort Tree)</h3>
<pre class="hljs"><code><div><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> _CRT_SECURE_NO_WARNINGS</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;windows.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;conio.h&gt;</span></span>

<span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">BSTNode</span>
{</span>
	<span class="hljs-keyword">int</span> data;
	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">BSTNode</span>* <span class="hljs-title">lchild</span>;</span>
	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">BSTNode</span>* <span class="hljs-title">rchild</span>;</span>
}BSTNode, * BSTNodePtr;

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">BSTInsert</span><span class="hljs-params">(BSTNode** T, <span class="hljs-keyword">int</span> data)</span>
</span>{
	<span class="hljs-keyword">if</span> (*T == <span class="hljs-literal">NULL</span>) {
		*T = (BSTNodePtr)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(BSTNode));
		(*T)-&gt;data = data;
		(*T)-&gt;lchild = <span class="hljs-literal">NULL</span>;
		(*T)-&gt;rchild = <span class="hljs-literal">NULL</span>;
	}
	<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (data &lt; (*T)-&gt;data) {
		BSTInsert(&amp;(*T)-&gt;lchild, data);
	}
	<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (data &gt; (*T)-&gt;data) {
		BSTInsert(&amp;(*T)-&gt;rchild, data);
	}
	<span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span>;
}

<span class="hljs-function"><span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* <span class="hljs-title">BST_Search</span><span class="hljs-params">(BSTNode* T, <span class="hljs-keyword">int</span> key)</span>
</span>{
	<span class="hljs-keyword">if</span> (T) {
		<span class="hljs-keyword">if</span> (T-&gt;data == key)
			<span class="hljs-keyword">return</span> <span class="hljs-string">"SEARCH SUCCESS!"</span>;
		<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (T-&gt;data &gt; key) {
			BST_Search(T-&gt;lchild, key);
		}
		<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (T-&gt;data &lt; key) {
			BST_Search(T-&gt;rchild, key);
		}
	}
	<span class="hljs-keyword">else</span> {
		<span class="hljs-keyword">return</span> <span class="hljs-string">"SEARCH FAIL!"</span>;
	}
}

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">delNode</span><span class="hljs-params">(BSTNode** T)</span>
</span>{
	BSTNode* s;
	BSTNode* rightDeepest;
	BSTNode* rightDeepest_pri;
	<span class="hljs-keyword">if</span> ((*T)-&gt;lchild == <span class="hljs-literal">NULL</span> ) {
		s = (*T);
		(*T) = (*T)-&gt;rchild;
		<span class="hljs-built_in">free</span>(s);
	}
	<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((*T)-&gt;rchild == <span class="hljs-literal">NULL</span>) {
		s = (*T);
		(*T) = (*T)-&gt;lchild;
		<span class="hljs-built_in">free</span>(s);
	}
	<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((*T)-&gt;lchild &amp;&amp; (*T)-&gt;lchild) {
		rightDeepest = (*T)-&gt;lchild;
		rightDeepest_pri = (*T)-&gt;lchild;
		<span class="hljs-keyword">while</span> (rightDeepest) {
			rightDeepest_pri = rightDeepest;
			rightDeepest = rightDeepest-&gt;rchild;
		}
		<span class="hljs-keyword">if</span> (rightDeepest) {
			(*T)-&gt;data = rightDeepest-&gt;data;
			rightDeepest_pri-&gt;rchild = rightDeepest-&gt;lchild;
			<span class="hljs-built_in">free</span>(rightDeepest);
		}
		<span class="hljs-keyword">else</span> {
			(*T)-&gt;data = rightDeepest_pri-&gt;data;
			(*T)-&gt;lchild = rightDeepest_pri-&gt;lchild;
			<span class="hljs-built_in">free</span>(rightDeepest_pri);
		}	
	}
	<span class="hljs-keyword">return</span>;
}

<span class="hljs-function"><span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* <span class="hljs-title">Delete</span><span class="hljs-params">(BSTNode** T, <span class="hljs-keyword">int</span> key)</span>
</span>{
	<span class="hljs-keyword">if</span> (*T) {
		<span class="hljs-keyword">if</span> ((*T)-&gt;data == key) {
			delNode(&amp;(*T));
			<span class="hljs-keyword">return</span> <span class="hljs-string">"SUCCESSFULLY DELETE!"</span>;
		}
		<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((*T)-&gt;data &lt; key)
			Delete(&amp;(*T)-&gt;rchild, key);
		<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((*T)-&gt;data &gt; key)
			Delete(&amp;(*T)-&gt;lchild, key);
	}
	<span class="hljs-keyword">else</span> {
		<span class="hljs-keyword">return</span> <span class="hljs-string">"NOT EXSIST!"</span>;
	}
}

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">preOrder</span><span class="hljs-params">(BSTNode* T)</span>
</span>{
	<span class="hljs-keyword">if</span> (T) {
		<span class="hljs-built_in">printf</span>(<span class="hljs-string">"\t%d"</span>, T-&gt;data);
		preOrder(T-&gt;lchild);
		preOrder(T-&gt;rchild);
	}
}

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">inOrder</span><span class="hljs-params">(BSTNode* T)</span>
</span>{
	<span class="hljs-keyword">if</span> (T) {
		preOrder(T-&gt;lchild);
		<span class="hljs-built_in">printf</span>(<span class="hljs-string">"\t%d"</span>, T-&gt;data);
		preOrder(T-&gt;rchild);
	}
}

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">postOrder</span><span class="hljs-params">(BSTNode* T)</span>
</span>{
	<span class="hljs-keyword">if</span> (T) {
		preOrder(T-&gt;lchild);
		<span class="hljs-built_in">printf</span>(<span class="hljs-string">"\t%d"</span>, T-&gt;data);
		preOrder(T-&gt;rchild);
	}
}

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span>* argv[])</span>
</span>{
	BSTNode* T = <span class="hljs-literal">NULL</span>;
	<span class="hljs-keyword">int</span> init[<span class="hljs-number">10</span>] = { <span class="hljs-number">62</span>,<span class="hljs-number">88</span>,<span class="hljs-number">58</span>,<span class="hljs-number">47</span>,<span class="hljs-number">35</span>,<span class="hljs-number">73</span>,<span class="hljs-number">51</span>,<span class="hljs-number">99</span>,<span class="hljs-number">37</span>,<span class="hljs-number">93</span> };
	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) {
		BSTInsert(&amp;T, init[i]);
	}
	<span class="hljs-built_in">printf</span>(<span class="hljs-string">"\nPREORDER\t"</span>);
	preOrder(T);
	<span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n\n"</span>);

	<span class="hljs-built_in">printf</span>(<span class="hljs-string">"INORDER \t"</span>);
	inOrder(T);
	<span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n\n"</span>);

	<span class="hljs-built_in">printf</span>(<span class="hljs-string">"POSTORDER\t"</span>);
	postOrder(T);		
	<span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n\n"</span>);

	<span class="hljs-built_in">puts</span>(BST_Search(T, <span class="hljs-number">99</span>));
	<span class="hljs-built_in">puts</span>(BST_Search(T, <span class="hljs-number">27</span>));
	<span class="hljs-built_in">puts</span>(BST_Search(T, <span class="hljs-number">47</span>));
	<span class="hljs-built_in">puts</span>(BST_Search(T, <span class="hljs-number">100</span>));

	<span class="hljs-built_in">puts</span>(Delete(&amp;T, <span class="hljs-number">73</span>));
	<span class="hljs-built_in">puts</span>(Delete(&amp;T, <span class="hljs-number">100</span>));
	<span class="hljs-built_in">puts</span>(Delete(&amp;T, <span class="hljs-number">62</span>));
	<span class="hljs-built_in">puts</span>(Delete(&amp;T, <span class="hljs-number">73</span>));
	<span class="hljs-built_in">puts</span>(Delete(&amp;T, <span class="hljs-number">51</span>));
	<span class="hljs-built_in">puts</span>(Delete(&amp;T, <span class="hljs-number">47</span>));
	<span class="hljs-built_in">puts</span>(Delete(&amp;T, <span class="hljs-number">35</span>));
	<span class="hljs-built_in">puts</span>(Delete(&amp;T, <span class="hljs-number">99</span>));

	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}

<span class="hljs-comment">//OUTPUT</span>
<span class="hljs-comment">//		PREORDER                62      58      47      35      37      51      88      73      99      93</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">//		INORDER                 58      47      35      37      51      62      88      73      99      93</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">//		POSTORDER               58      47      35      37      51      62      88      73      99      93</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">//		SEARCH SUCCESS!</span>
<span class="hljs-comment">//		SEARCH FAIL!</span>
<span class="hljs-comment">//		SEARCH SUCCESS!</span>
<span class="hljs-comment">//		SEARCH FAIL!</span>
<span class="hljs-comment">//		SUCCESSFULLY DELETE!</span>
<span class="hljs-comment">//		NOT EXSIST!</span>
<span class="hljs-comment">//		SUCCESSFULLY DELETE!</span>
<span class="hljs-comment">//		NOT EXSIST!</span>
<span class="hljs-comment">//		SUCCESSFULLY DELETE!</span>
<span class="hljs-comment">//		SUCCESSFULLY DELETE!</span>
<span class="hljs-comment">//		SUCCESSFULLY DELETE!</span>
<span class="hljs-comment">//		SUCCESSFULLY DELETE!</span>
</div></code></pre>
<h3 id="76-a-namealva%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91-alv%E6%A0%91">7.6. <a name='ALV'></a>平衡二叉树 ALV树</h3>
<p>$平衡二叉树(Self-Balancing\ Binary\ Search\ Tree\ or \ Height-Balanced\ Binary\ Search\ Tree),是一种二叉排序树,其中\textbf{每一个结点}的左子树和右子树的高度差至多等于1\
①高度平衡的二叉排序树\
②平衡因子BF(Balanced\ Factor):二叉树上结点的左子树高度减去右子树高度的值\
③要注意|BF|≤1是对每一个节点\
④最小不平衡子树:距离插入结点最近的,以且|BF|≥1的结点为根的子树$</p>
<h4 id="761-a-name-1a%E4%BA%8C%E5%8F%89%E5%B9%B3%E8%A1%A1%E6%A0%91%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86">7.6.1. <a name='-1'></a>二叉平衡树的实现原理</h4>
<p>$BF\begin{cases}
+\quad→\quad右旋\
-\quad→\quad左旋
\end{cases}
\旋转后要注意最小不平衡子树的根节点与它的子节点符号要相同(这里的相同是包括0的)$</p>
<h3 id="77-a-nameba%E5%A4%9A%E8%B7%AF%E6%9F%A5%E6%89%BE%E6%A0%91b%E6%A0%91">7.7. <a name='B'></a>多路查找树(B树)</h3>
<h4 id="771-a-name-1a2-3%E6%A0%91">7.7.1. <a name='-1'></a>2-3树</h4>
<h4 id="772-a-name-1a2-3-4%E6%A0%91">7.7.2. <a name='-1'></a>2-3-4树</h4>
<h4 id="773-a-nameb-1ab%E6%A0%91">7.7.3. <a name='B-1'></a>B树</h4>
<h4 id="774-a-nameb-1ab%E6%A0%91">7.7.4. <a name='B-1'></a>B+树</h4>
<h3 id="78-a-name-1a%E5%93%88%E5%B8%8C%E8%A1%A8%E6%95%A3%E5%88%97%E8%A1%A8%E6%9F%A5%E6%89%BE">7.8. <a name='-1'></a>哈希表(散列表)查找)</h3>
<p>$散列表/哈希表(Hash\ Table):采用散列技术将存储记录的一块连续的存储空间$
$散列技术:在记录的存储位置和它的关键字之间建立一个确定的对应关系f,使得$
$$存储位置=f(关键字)$$
$每一个关键字只对应一个存储位置.其中对应关系f称为散列函数或哈希(Hash)函数\
散列技术既是一种存储方法,也是一种查找方法\
散列技术的记录之间不存在逻辑关系,只与关键字有关联,适合求解&quot;查找值与给定值相等的记录&quot;的问题.\
散列是面向查找的存储结构.\
冲突现象(collision):两个关键字key_1\neq key_2,但是有f(key_1)=f(key_2).\ \ key_1和key_2称为这个散列函数的同义词(synonym).$</p>
<h4 id="781-a-name-1a%E6%95%A3%E5%88%97%E5%87%BD%E6%95%B0%E7%9A%84%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95">7.8.1. <a name='-1'></a>散列函数的构造方法</h4>
<p>$$原则\begin{cases}
计算简单\
散列地址分布均匀
\end{cases}$$</p>
<h5 id="%E7%9B%B4%E6%8E%A5%E5%AE%9A%E5%9D%80%E6%B3%95">直接定址法</h5>
<p>取关键字的某个线性函数值为散列地址.
$$f(key)=a\cdot key=b$$</p>
<h5 id="%E6%95%B0%E5%AD%97%E5%88%86%E6%9E%90%E6%B3%95">数字分析法</h5>
<p>抽取、反转、右环移位、左环移位、前后叠加等等</p>
<h5 id="%E5%B9%B3%E6%96%B9%E5%8F%96%E4%B8%AD%E6%B3%95">平方取中法</h5>
<p>例如$$1234^2→1522756→227$$</p>
<h5 id="%E6%8A%98%E5%8F%A0%E6%B3%95fen">折叠法fen</h5>
<p>等位数分割叠加求和,按散列表表长,取后几位作为散列地址.</p>
<h5 id="%E9%99%A4%E7%95%99%E4%BD%99%E6%95%B0%E6%B3%95">除留余数法</h5>
<p>$$f(key)=key\ mod\ p(p≤m)$$
m为散列表长.
根据经验,p通常为小于等于m的最小质数或不包含小于20质因子的合数.</p>
<h5 id="%E9%9A%8F%E6%9C%BA%E6%95%B0%E6%B3%95">随机数法</h5>
<p>$$f(key)=random(key)$$</p>
<h4 id="782-a-name-1a%E5%A4%84%E7%90%86%E6%95%A3%E5%88%97%E5%86%B2%E7%AA%81%E7%9A%84%E6%96%B9%E6%B3%95">7.8.2. <a name='-1'></a>处理散列冲突的方法</h4>
<h2 id="8-a-name-1a%E6%8E%92%E5%BA%8F">8. <a name='-1'></a>排序</h2>
<h2 id="9-a-nameora%E5%AE%9E%E9%AA%8Cor%E5%BA%94%E7%94%A8">9. <a name='or'></a>实验or应用</h2>
<h3 id="91-a-name-1a%E7%BA%BF%E6%80%A7%E8%A1%A8">9.1. <a name='-1'></a>线性表</h3>
<h4 id="911-a-name-1a%E7%AE%80%E5%8D%95%E7%9A%84%E5%AD%A6%E7%94%9F%E6%88%90%E7%BB%A9%E7%AE%A1%E7%90%86">9.1.1. <a name='-1'></a>简单的学生成绩管理</h4>
<center>Visual Studio 2019 中实现</center>
<pre class="hljs"><code><div><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdio.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;string.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> OK 1</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> OVERFLOW -2</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ListIncrement 2</span>
<span class="hljs-keyword">int</span> n;
<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">int</span> Status;

<span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span>
{</span>
	<span class="hljs-keyword">char</span> name[<span class="hljs-number">10</span>];
	<span class="hljs-keyword">float</span> score;
}STD;

STD *newbase;

<span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span>
{</span>
	STD *data;
	<span class="hljs-keyword">int</span> length;
	<span class="hljs-keyword">int</span> listsize;
}SqList;

<span class="hljs-function">Status <span class="hljs-title">InitList</span><span class="hljs-params">(SqList *L)</span>
</span>{
	<span class="hljs-built_in">printf</span>(<span class="hljs-string">"请输入学生人数n："</span>);
	scanf_s(<span class="hljs-string">"%d"</span>, &amp;n);
	L-&gt;data = (STD*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(STD) * n);

	<span class="hljs-keyword">if</span> (!L-&gt;data)
	{
		<span class="hljs-built_in">printf</span>(<span class="hljs-string">"Create failed!"</span>);
		<span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);
	}
	L-&gt;length = <span class="hljs-number">0</span>;
	L-&gt;listsize = n;
	
		<span class="hljs-built_in">printf</span>(<span class="hljs-string">"Successfully creat!Please initialize the Sequence List\n"</span>);
	<span class="hljs-comment">//	printf("%d\n", L-&gt;listsize);</span>
	<span class="hljs-keyword">return</span> OK;
}

<span class="hljs-function">Status <span class="hljs-title">InputList</span><span class="hljs-params">(SqList *L, <span class="hljs-keyword">int</span> n)</span>
</span>{
	<span class="hljs-keyword">int</span> i;
	<span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; n; i++)
	{
		scanf_s(<span class="hljs-string">"%s"</span>,L-&gt;data[i].name,<span class="hljs-number">10</span>);
		scanf_s(<span class="hljs-string">"%f"</span>,&amp;L-&gt;data[i].score);
	}
	L-&gt;length = n;
	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}

<span class="hljs-function">Status <span class="hljs-title">DisplayList</span><span class="hljs-params">(SqList *L,<span class="hljs-keyword">int</span> n)</span>
</span>{
	<span class="hljs-keyword">int</span> i;
	<span class="hljs-keyword">char</span> *na = <span class="hljs-string">"name"</span>;
	<span class="hljs-keyword">char</span> *p = <span class="hljs-string">"score"</span>;
	<span class="hljs-built_in">printf</span>(<span class="hljs-string">"%-8s%-8s\n"</span>,na,p);
	<span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; n; i++)
	{
		<span class="hljs-built_in">printf</span>(<span class="hljs-string">"%-8s%-8.1f \n"</span>, L-&gt;data[i].name, L-&gt;data[i].score);
		
	}
	<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
}

<span class="hljs-function">Status <span class="hljs-title">GetSTD1</span><span class="hljs-params">(SqList* L)</span>
</span>{
	<span class="hljs-built_in">printf</span>(<span class="hljs-string">"请输入要查找的学生的姓名："</span>);
	<span class="hljs-keyword">char</span> FindName[<span class="hljs-number">10</span>];
	scanf_s(<span class="hljs-string">"%s"</span>, FindName, <span class="hljs-number">10</span>);
	<span class="hljs-keyword">int</span> i;
	<span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; n ; i++)
	{
		<span class="hljs-keyword">if</span> (<span class="hljs-built_in">strcmp</span>(FindName, L-&gt;data[i].name) == <span class="hljs-number">0</span>)
		{
			<span class="hljs-built_in">printf</span>(<span class="hljs-string">"%8s%8.1f\n"</span>, L-&gt;data[i].name, L-&gt;data[i].score);
			<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
		}	
	}
	<span class="hljs-built_in">printf</span>(<span class="hljs-string">"该学生不存在！\n"</span>);
		<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}

<span class="hljs-function">Status <span class="hljs-title">GetSTD2</span><span class="hljs-params">(SqList* L)</span>
</span>{
	<span class="hljs-keyword">int</span> i;
	<span class="hljs-built_in">printf</span>(<span class="hljs-string">"请输入你要查找的学生序号："</span>);
	scanf_s(<span class="hljs-string">"%d"</span>, &amp;i);
	<span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span> &amp;&amp; i &lt;= L-&gt;length)
		<span class="hljs-built_in">printf</span>(<span class="hljs-string">"第%d个学生是%s\n"</span>, i, L-&gt;data[i - <span class="hljs-number">1</span>].name);
	<span class="hljs-keyword">else</span> <span class="hljs-built_in">printf</span>(<span class="hljs-string">"该序号不存在，请重新输入！"</span>);
	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}

<span class="hljs-function">Status <span class="hljs-title">ListInsert</span><span class="hljs-params">(SqList *L)</span>
</span>{
	<span class="hljs-keyword">int</span> i;
	<span class="hljs-built_in">printf</span>(<span class="hljs-string">"Please the position i you want to insert.\n"</span>);
	<span class="hljs-keyword">int</span> <span class="hljs-keyword">bool</span> = <span class="hljs-number">1</span>;
	<span class="hljs-keyword">while</span> (<span class="hljs-keyword">bool</span>)
	{
		scanf_s(<span class="hljs-string">"%d"</span>, &amp;i);
		<span class="hljs-keyword">if</span> (i &lt; <span class="hljs-number">1</span> || i &gt; L-&gt;length+<span class="hljs-number">1</span>)
		{
			<span class="hljs-built_in">printf</span>(<span class="hljs-string">"插入的位置不合理！请重新输入！\n"</span>);
		}
		<span class="hljs-keyword">else</span> <span class="hljs-keyword">bool</span> = <span class="hljs-number">0</span>;
	}
	newbase = (STD*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(STD));
	<span class="hljs-keyword">if</span> (L-&gt;length = L-&gt;listsize)
	{
		newbase = (STD*)<span class="hljs-built_in">realloc</span>(L-&gt;data, (L-&gt;listsize + ListIncrement) * <span class="hljs-keyword">sizeof</span>(STD));
		<span class="hljs-keyword">if</span> (!L-&gt;data)
		{
			<span class="hljs-built_in">printf</span>(<span class="hljs-string">"Recreate failed!\n"</span>);
			<span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);
		}
		L-&gt;data = newbase;
		L-&gt;listsize += ListIncrement;
		L-&gt;length += <span class="hljs-number">1</span>;
		n = n + <span class="hljs-number">1</span>;
	}

	<span class="hljs-keyword">int</span> j;
	<span class="hljs-keyword">for</span> (j = L-&gt;length; j &gt;= i; j--)
	{
		L-&gt;data[j] = L-&gt;data[j - <span class="hljs-number">1</span>];
	}
	
	<span class="hljs-built_in">printf</span>(<span class="hljs-string">"Please input the data to insert.\n"</span>);
	scanf_s(<span class="hljs-string">"%s"</span>,L-&gt;data[i<span class="hljs-number">-1</span>].name,<span class="hljs-number">10</span>);
	scanf_s(<span class="hljs-string">"%f"</span>,&amp;L-&gt;data[i<span class="hljs-number">-1</span>].score);
	<span class="hljs-built_in">printf</span>(<span class="hljs-string">"插入成功"</span>);
	<span class="hljs-keyword">return</span> OK;
}

<span class="hljs-function">Status <span class="hljs-title">DeleteList</span><span class="hljs-params">(SqList* L)</span>
</span>{
	<span class="hljs-keyword">int</span> i;
	<span class="hljs-built_in">printf</span>(<span class="hljs-string">"Please the position i you want to delete.\n"</span>);
	<span class="hljs-keyword">int</span> <span class="hljs-keyword">bool</span> = <span class="hljs-number">1</span>;
	<span class="hljs-keyword">while</span>(<span class="hljs-keyword">bool</span>)
	{
		scanf_s(<span class="hljs-string">"%d"</span>, &amp;i);
		<span class="hljs-keyword">if</span> (i &lt; <span class="hljs-number">1</span> || i &gt; L-&gt;length)
		{
			<span class="hljs-built_in">printf</span>(<span class="hljs-string">"删除的位置不合理！请重新输入！\n"</span>);
		}
		<span class="hljs-keyword">else</span> <span class="hljs-keyword">bool</span> = <span class="hljs-number">0</span>;
	}
	
	<span class="hljs-keyword">int</span> j;
	<span class="hljs-keyword">for</span> (j = i<span class="hljs-number">-1</span>; j &lt; L-&gt;length<span class="hljs-number">-1</span>; j++)
	{
		L-&gt;data[j] = L-&gt;data[j + <span class="hljs-number">1</span>];
	}
	L-&gt;length -= <span class="hljs-number">1</span>;
	n = n - <span class="hljs-number">1</span>;
	<span class="hljs-keyword">return</span> OK;
}

<span class="hljs-function">Status <span class="hljs-title">GetNum</span><span class="hljs-params">(SqList *L)</span>
</span>{
	<span class="hljs-keyword">if</span> (!IsEmpty(L))
		<span class="hljs-built_in">printf</span>(<span class="hljs-string">"The number of the students is “%d”\n"</span>, L-&gt;length);
	<span class="hljs-keyword">else</span> <span class="hljs-built_in">printf</span>(<span class="hljs-string">"线性表不存在，请选择新建表格（0）\n"</span>);
	<span class="hljs-keyword">return</span> OK;
}

<span class="hljs-function">Status <span class="hljs-title">IsEmpty</span><span class="hljs-params">(SqList* L)</span>
</span>{
	<span class="hljs-keyword">if</span> (L-&gt;length == <span class="hljs-number">0</span>)
		<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
	<span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}

<span class="hljs-function">Status <span class="hljs-title">DestroyList</span><span class="hljs-params">(SqList* L)</span>
</span>{
	<span class="hljs-keyword">if</span> (L-&gt;data)
	{
		<span class="hljs-built_in">free</span>(L-&gt;data);
		L-&gt;data = <span class="hljs-literal">NULL</span>;
		L-&gt;length = <span class="hljs-number">0</span>;
		L-&gt;listsize = <span class="hljs-number">0</span>;
	}	
	<span class="hljs-keyword">return</span> OK;
}

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
	SqList* L = (SqList*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(SqList));
	<span class="hljs-keyword">int</span> sta = <span class="hljs-number">1</span>;
	<span class="hljs-built_in">printf</span>(<span class="hljs-string">"--------------------------功能界面--------------------------\n"</span>);
	<span class="hljs-built_in">printf</span>(<span class="hljs-string">"-------------------------0.创建新表--------------------------\n"</span>);
	<span class="hljs-built_in">printf</span>(<span class="hljs-string">"1.添加学生\t2.显示学生表\t3.按姓名查找学生\t4.按序号查找学生\n"</span>);
	<span class="hljs-built_in">printf</span>(<span class="hljs-string">"5.插入学生\t6.删除学生信息\t7.统计学生人数\t\t8.清空表格\n"</span>);
	<span class="hljs-built_in">printf</span>(<span class="hljs-string">"------------------------------------------------------------\n"</span>);

	
	<span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)
	{
		<span class="hljs-keyword">int</span> fun;
		<span class="hljs-built_in">printf</span>(<span class="hljs-string">"请输入功能对应数字"</span>);
		scanf_s(<span class="hljs-string">"%d"</span>, &amp;fun);
		getchar();
		<span class="hljs-keyword">switch</span> (fun)
		{
			<span class="hljs-keyword">case</span> <span class="hljs-number">-1</span>:
				<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
			<span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:
				InitList(L); 
				<span class="hljs-keyword">break</span>;
			<span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:
				<span class="hljs-keyword">if</span> (sta == <span class="hljs-number">1</span>)
				{
					InputList(L, n);
					sta = <span class="hljs-number">0</span>;
				}
				<span class="hljs-keyword">else</span>
					<span class="hljs-built_in">printf</span>(<span class="hljs-string">"线性表已存在，请选择插入（5）或清空（8）！\n"</span>);
				<span class="hljs-keyword">break</span>;
			<span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:
				<span class="hljs-keyword">if</span> (!IsEmpty(L))
					DisplayList(L, n);
				<span class="hljs-keyword">else</span> <span class="hljs-built_in">printf</span>(<span class="hljs-string">"线性表不存在，请选择新建表格（0）\n"</span>);
				<span class="hljs-keyword">break</span>;
			<span class="hljs-keyword">case</span> <span class="hljs-number">3</span>:
				<span class="hljs-keyword">if</span> (!IsEmpty(L))
					GetSTD1(L);
				<span class="hljs-keyword">else</span> <span class="hljs-built_in">printf</span>(<span class="hljs-string">"线性表不存在，请选择新建表格（0）\n"</span>);
				<span class="hljs-keyword">break</span>;
			<span class="hljs-keyword">case</span> <span class="hljs-number">4</span>:
				<span class="hljs-keyword">if</span> (!IsEmpty(L))
					GetSTD2(L);
				<span class="hljs-keyword">else</span> <span class="hljs-built_in">printf</span>(<span class="hljs-string">"线性表不存在，请选择新建表格（0）\n"</span>);
				<span class="hljs-keyword">break</span>;
			<span class="hljs-keyword">case</span> <span class="hljs-number">5</span>:
				<span class="hljs-keyword">if</span> (!IsEmpty(L))
					ListInsert(L);
				<span class="hljs-keyword">else</span> <span class="hljs-built_in">printf</span>(<span class="hljs-string">"线性表不存在，请选择新建表格（0）\n"</span>);
				<span class="hljs-keyword">break</span>;
			<span class="hljs-keyword">case</span> <span class="hljs-number">6</span>:
				<span class="hljs-keyword">if</span> ( !IsEmpty(L) &amp;&amp; ((L-&gt;listsize) &gt; <span class="hljs-number">0</span>))
					DeleteList(L);
				<span class="hljs-keyword">else</span>
				{
					DestroyList(L);
					<span class="hljs-built_in">printf</span>(<span class="hljs-string">"线性表不存在，请选择新建表格（0）\n"</span>);
				}
				<span class="hljs-keyword">break</span>;
			<span class="hljs-keyword">case</span> <span class="hljs-number">7</span>:
				GetNum(L);
				<span class="hljs-keyword">break</span>;
			<span class="hljs-keyword">case</span> <span class="hljs-number">8</span>:
				DestroyList(L);
				sta = <span class="hljs-number">1</span>;
				<span class="hljs-keyword">break</span>;
			<span class="hljs-keyword">default</span>:
				<span class="hljs-built_in">printf</span>(<span class="hljs-string">"输入错误，请重新输入！\n"</span>);
		}
	}
	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</div></code></pre>
<h4 id="912-a-name-1a%E5%9B%BE%E4%B9%A6%E4%BF%A1%E6%81%AF%E7%AE%A1%E7%90%86">9.1.2. <a name='-1'></a>图书信息管理</h4>
<center>Visual Studio 2019 中实现</center>
<pre class="hljs"><code><div><span class="hljs-comment">/*
*	实现图书信息管理，具体要求如下：
*
*	定义图书结构体类型ElemType，至少包括三个属性（书号，书名，价格）；
*	定义图书顺序表SqList（ElemType指针，表长，容量）。
*
*	功能：1、初始化创建一个空表（提示：需要分配存储空间）；
*		  2、插入一条新的图书信息到表中第i个元素；
*		  3、删除表中第i条图书信息；
*		  4、按书名进行查找，并返回找到的图书的完整信息；
*		  5、查找表中的第i条图书信息；
*		  6、输出顺序表中的所有图书信息（注意排版清楚美观）；
*		  7、修改指定图书信息的价格；
*		  8、自己分析，扩展有意义的功能。
*
*	主函数中定义顺序表变量L，通过调用各功能函数顺序完成以下操作：
*		1. 初始化创建空表L，
*		2. 连续插入3条数据到表头，
*		3. 输出顺序表，
*		4. 插入一条数据使其成为表中第3条数据，
*		5. 输出顺序表，
*		6. 根据指定的书名进行删除；
*		7. 输出顺序表；
*		8. 按书名进行查找，并输出查找到的图书完整信息;
*		9. 按书名查找后进行对应记录价格的修改；
*		10.输出修改后全部图书信息。
*/</span>

<span class="hljs-comment">/*	测试样例
	ISBN				书名					定价
	9787302257646		程序设计基础				25
	9787302219972		单片机技术及应用			32
	9787302203513		编译原理					46
	9787811234923		汇编语言程序设计教程		21
	9787512100831		计算机操作系统			17
	9787302265436		计算机导论实验指导		18
	9787302180630		实用数据结构				29
	9787302225065		数据结构(C语言版)		38
	9787302171676		C#面向对象程序设计		39
	9787302250692		c语言程序设计			42
	9787302150664		数据库原理				35
	9787302260806		Java编程与实践			56
	9787302252887		Java程序设计与应用教程	39
	9787302198505		嵌入式操作系统及编程		25
	9787302169666		软件测试					24
	9787811231557		Eclipse基础与应用		35
*/</span>

<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdio.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;string.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> OK 1</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> OVERFLOW -2</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ListIncrement 2</span>
<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">int</span> Status;
<span class="hljs-keyword">int</span> n;

<span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span>
{</span>
	<span class="hljs-keyword">char</span> ISBN[<span class="hljs-number">15</span>];
	<span class="hljs-keyword">char</span> BookName[<span class="hljs-number">50</span>];
	<span class="hljs-keyword">float</span> price;
}TBook;

<span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span>
{</span>
	TBook* data;
	<span class="hljs-keyword">int</span> length;
	<span class="hljs-keyword">int</span> listsize;
}SqList;

TBook* newbase;

<span class="hljs-function">Status <span class="hljs-title">InitList</span><span class="hljs-params">(SqList* L,<span class="hljs-keyword">int</span> n)</span></span>;	<span class="hljs-comment">//初始化</span>
<span class="hljs-function">Status <span class="hljs-title">InputList</span><span class="hljs-params">(SqList* L,<span class="hljs-keyword">int</span> i)</span></span>;	<span class="hljs-comment">//输入图书信息</span>
<span class="hljs-function">Status <span class="hljs-title">DisplayList</span><span class="hljs-params">(SqList* L)</span></span>;		<span class="hljs-comment">//输出图书信息</span>
<span class="hljs-function">Status <span class="hljs-title">ListInsert</span><span class="hljs-params">(SqList* L)</span></span>;		<span class="hljs-comment">//插入图书信息</span>
<span class="hljs-function">Status <span class="hljs-title">DeListAcoName</span><span class="hljs-params">(SqList* L)</span></span>;	<span class="hljs-comment">//根据书名删除图书信息</span>
<span class="hljs-function">Status <span class="hljs-title">DeListAcoNum</span><span class="hljs-params">(SqList* L)</span></span>;		<span class="hljs-comment">//根据序号删除图书信息</span>
<span class="hljs-function">Status <span class="hljs-title">GetName</span><span class="hljs-params">(SqList* L)</span></span>;			<span class="hljs-comment">//根据书名查找图书</span>
<span class="hljs-function">Status <span class="hljs-title">GetSeNum</span><span class="hljs-params">(SqList* L)</span></span>;			<span class="hljs-comment">//根据序号查找图书</span>
<span class="hljs-function">Status <span class="hljs-title">GetNum</span><span class="hljs-params">(SqList* L)</span></span>;			<span class="hljs-comment">//输出图书总数</span>
<span class="hljs-function">Status <span class="hljs-title">MdfPrice</span><span class="hljs-params">(SqList* L)</span></span>;			<span class="hljs-comment">//修改图书价格</span>
<span class="hljs-function">Status <span class="hljs-title">IsEmpty</span><span class="hljs-params">(SqList* L)</span></span>;			<span class="hljs-comment">//判断表格是否为空</span>
<span class="hljs-function">Status <span class="hljs-title">DestroyList</span><span class="hljs-params">(SqList* L)</span></span>;		<span class="hljs-comment">//销毁图书信息；</span>

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span>* argv[])</span>
</span>{
	SqList* L = (SqList*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(SqList));
	<span class="hljs-built_in">printf</span>(<span class="hljs-string">"--------------------------功能界面--------------------------\n"</span>);
	<span class="hljs-built_in">printf</span>(<span class="hljs-string">"------------------------图书信息管理------------------------\n"</span>);
	<span class="hljs-built_in">printf</span>(<span class="hljs-string">"1. 初始化创建空表L；\n"</span>);
	<span class="hljs-built_in">printf</span>(<span class="hljs-string">"2. 初始化后输入图书信息；\n"</span>);
	<span class="hljs-built_in">printf</span>(<span class="hljs-string">"3. 输出全部图书信息；\n"</span>);
	<span class="hljs-built_in">printf</span>(<span class="hljs-string">"4. 插入图书信息\n"</span>);
	<span class="hljs-built_in">printf</span>(<span class="hljs-string">"5. 根据指定的书名进行删除；\n"</span>);
	<span class="hljs-built_in">printf</span>(<span class="hljs-string">"6. 根据指定的序号进行删除；\n"</span>);
	<span class="hljs-built_in">printf</span>(<span class="hljs-string">"7. 按书名进行查找，并输出查找到的图书完整信息；\n"</span>);
	<span class="hljs-built_in">printf</span>(<span class="hljs-string">"8. 按序号进行查找，并输出查找到的图书完整信息；\n"</span>);
	<span class="hljs-built_in">printf</span>(<span class="hljs-string">"9. 按书名查找后进行对应记录价格的修改；\n"</span>);
	<span class="hljs-built_in">printf</span>(<span class="hljs-string">"10.输出图书总数。\n"</span>);
	<span class="hljs-built_in">printf</span>(<span class="hljs-string">"11.销毁所有图书信息。\n"</span>);
	<span class="hljs-built_in">printf</span>(<span class="hljs-string">"12.退出。\n"</span>);


	<span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)
	{
		<span class="hljs-keyword">int</span> fun;
		<span class="hljs-built_in">printf</span>(<span class="hljs-string">"------------------------请输入功能对应数字："</span>);
		scanf_s(<span class="hljs-string">"%d"</span>, &amp;fun);
		getchar();
		<span class="hljs-keyword">switch</span> (fun)
		{
		<span class="hljs-keyword">case</span> <span class="hljs-number">12</span>:
			<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
		<span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:
			<span class="hljs-built_in">printf</span>(<span class="hljs-string">"请输入图书数量："</span>);
			scanf_s(<span class="hljs-string">"%d"</span>, &amp;n);
			InitList(L,n);
			<span class="hljs-keyword">break</span>;
		<span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:
			<span class="hljs-keyword">if</span> (!IsEmpty(L))
			{
				<span class="hljs-keyword">int</span> i;
				<span class="hljs-built_in">printf</span>(<span class="hljs-string">"请依次输入书号（ISBN）、书名、价格：\n"</span>);
				<span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; n; i++)
				{
					InputList(L,i);
				}
			}
			<span class="hljs-keyword">else</span> <span class="hljs-built_in">printf</span>(<span class="hljs-string">"线性表不存在，请选择初始化（1）\n"</span>);
			<span class="hljs-keyword">break</span>;
		<span class="hljs-keyword">case</span> <span class="hljs-number">3</span>:
			<span class="hljs-keyword">if</span> (!IsEmpty(L))
				DisplayList(L);
			<span class="hljs-keyword">else</span> <span class="hljs-built_in">printf</span>(<span class="hljs-string">"线性表不存在，请选择初始化（1）\n"</span>);
			<span class="hljs-keyword">break</span>;
		<span class="hljs-keyword">case</span> <span class="hljs-number">4</span>:
			<span class="hljs-keyword">if</span> (!IsEmpty(L))
			{
				ListInsert(L);
			}
			<span class="hljs-keyword">else</span> <span class="hljs-built_in">printf</span>(<span class="hljs-string">"线性表不存在，请选择新建表格（0）\n"</span>);
			<span class="hljs-keyword">break</span>;
		<span class="hljs-keyword">case</span> <span class="hljs-number">5</span>:
			<span class="hljs-keyword">if</span> (!IsEmpty(L))
			{
				DeListAcoName(L);
			}
			<span class="hljs-keyword">else</span> <span class="hljs-built_in">printf</span>(<span class="hljs-string">"线性表不存在，请选择初始化（1）\n"</span>);
			<span class="hljs-keyword">break</span>;
		<span class="hljs-keyword">case</span> <span class="hljs-number">6</span>:
			<span class="hljs-keyword">if</span> (!IsEmpty(L))
			{
				DeListAcoNum(L);
			}
			<span class="hljs-keyword">else</span> <span class="hljs-built_in">printf</span>(<span class="hljs-string">"线性表不存在，请选择初始化（1）\n"</span>);
			<span class="hljs-keyword">break</span>;
		<span class="hljs-keyword">case</span> <span class="hljs-number">7</span>:
			<span class="hljs-keyword">if</span> (!IsEmpty(L))
				GetName(L);
			<span class="hljs-keyword">else</span>
			{
				DestroyList(L);
				<span class="hljs-built_in">printf</span>(<span class="hljs-string">"线性表不存在，请选择初始化（1）\n"</span>);
			}
			<span class="hljs-keyword">break</span>;
		<span class="hljs-keyword">case</span> <span class="hljs-number">8</span>:
			<span class="hljs-keyword">if</span> (!IsEmpty(L))
			{
				GetSeNum(L);
			}
			<span class="hljs-keyword">else</span>
			{
				DestroyList(L);
				<span class="hljs-built_in">printf</span>(<span class="hljs-string">"线性表不存在，请选择初始化（1）\n"</span>);
			}
			<span class="hljs-keyword">break</span>;
		<span class="hljs-keyword">case</span> <span class="hljs-number">9</span>:
			<span class="hljs-keyword">if</span> (!IsEmpty(L))
			{
				MdfPrice(L);
			}
			<span class="hljs-keyword">else</span>
			{
				DestroyList(L);
				<span class="hljs-built_in">printf</span>(<span class="hljs-string">"线性表不存在，请选择初始化（1）\n"</span>);
			}
			<span class="hljs-keyword">break</span>;
		<span class="hljs-keyword">case</span> <span class="hljs-number">10</span>:
			<span class="hljs-keyword">if</span> (!IsEmpty(L))
			{
				GetNum(L);
			}
			<span class="hljs-keyword">else</span>
			{
				DestroyList(L);
				<span class="hljs-built_in">printf</span>(<span class="hljs-string">"线性表不存在，请选择初始化（1）\n"</span>);
			}
			<span class="hljs-keyword">break</span>;
		<span class="hljs-keyword">case</span> <span class="hljs-number">11</span>:
			DestroyList(L);
			<span class="hljs-built_in">printf</span>(<span class="hljs-string">"销毁成功！请选择重新初始化（1）或者退出（12）\n"</span>);
			<span class="hljs-keyword">break</span>;
		<span class="hljs-keyword">default</span>:
			<span class="hljs-built_in">printf</span>(<span class="hljs-string">"输入错误，请重新输入！\n"</span>);
		}
		<span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n"</span>);
	}
	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}

<span class="hljs-function">Status <span class="hljs-title">InitList</span><span class="hljs-params">(SqList* L,<span class="hljs-keyword">int</span> n)</span>
</span>{
	L-&gt;data = (TBook*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(TBook)*n);

	<span class="hljs-keyword">if</span> (!L-&gt;data)
	{
		<span class="hljs-built_in">printf</span>(<span class="hljs-string">"Create failed!"</span>);
		<span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);
	}
	L-&gt;length = <span class="hljs-number">0</span>;
	L-&gt;listsize = n;

	<span class="hljs-built_in">printf</span>(<span class="hljs-string">"Successfully creat!Please initialize the Sequence List\n"</span>);
	<span class="hljs-comment">//printf("Listsize:%d\n", L-&gt;listsize);</span>
	<span class="hljs-comment">//printf("Length:%d\n", L-&gt;length);</span>
	<span class="hljs-keyword">return</span> OK;
}

<span class="hljs-function">Status <span class="hljs-title">InputList</span><span class="hljs-params">(SqList* L,<span class="hljs-keyword">int</span> i)</span>
</span>{

	scanf_s(<span class="hljs-string">"%s"</span>, L-&gt;data[i].ISBN, <span class="hljs-number">15</span>);
	scanf_s(<span class="hljs-string">"%s"</span>, L-&gt;data[i].BookName, <span class="hljs-number">50</span>);
	scanf_s(<span class="hljs-string">"%f"</span>, &amp;L-&gt;data[i].price);

	L-&gt;length += <span class="hljs-number">1</span>;
	<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
}

<span class="hljs-function">Status <span class="hljs-title">DisplayList</span><span class="hljs-params">(SqList* L)</span>
</span>{
	<span class="hljs-keyword">int</span> i;
	<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *Is = <span class="hljs-string">"ISBN"</span>;
	<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *Na = <span class="hljs-string">"书名"</span>;
	<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *Pr = <span class="hljs-string">"价格"</span>;
	<span class="hljs-built_in">printf</span>(<span class="hljs-string">"%-20s%-25s%-25s\n"</span>, Is, Na, Pr);
	<span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; L-&gt;length; i++)
	{
		<span class="hljs-built_in">printf</span>(<span class="hljs-string">"%-20s%-25s%-10.2f\n"</span>, L-&gt;data[i].ISBN, L-&gt;data[i].BookName, L-&gt;data[i].price);
	}
	<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
}

<span class="hljs-function">Status <span class="hljs-title">ListInsert</span><span class="hljs-params">(SqList* L)</span>
</span>{
	<span class="hljs-keyword">int</span> i;
	<span class="hljs-built_in">printf</span>(<span class="hljs-string">"Please input the position i you want to insert： "</span>);
	<span class="hljs-keyword">int</span> b = <span class="hljs-number">1</span>;
	<span class="hljs-keyword">while</span> (b)
	{
		scanf_s(<span class="hljs-string">"%d"</span>, &amp;i);
		<span class="hljs-keyword">if</span> (i &lt; <span class="hljs-number">1</span> || i &gt; L-&gt;length + <span class="hljs-number">1</span>)
		{
			<span class="hljs-built_in">printf</span>(<span class="hljs-string">"插入的位置不合理！请重新输入！\n"</span>);
		}
		<span class="hljs-keyword">else</span> b = <span class="hljs-number">0</span>;
	}
	newbase = (TBook*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(TBook));
	<span class="hljs-keyword">if</span> (L-&gt;length == L-&gt;listsize)
	{
		newbase = (TBook*)<span class="hljs-built_in">realloc</span>(L-&gt;data, (L-&gt;listsize + ListIncrement) * <span class="hljs-keyword">sizeof</span>(TBook));
		<span class="hljs-keyword">if</span> (!L-&gt;data)
		{
			<span class="hljs-built_in">printf</span>(<span class="hljs-string">"Recreate failed!\n"</span>);
			<span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);
		}
		L-&gt;data = newbase;
		L-&gt;listsize += ListIncrement;
	}

	<span class="hljs-keyword">int</span> j;
	<span class="hljs-keyword">for</span> (j = L-&gt;length; j &gt;= i; j--)
	{
		L-&gt;data[j] = L-&gt;data[j - <span class="hljs-number">1</span>];
	}
	<span class="hljs-built_in">printf</span>(<span class="hljs-string">"请依次输入书号（ISBN）、书名、价格：\n"</span>);
	InputList(L,i<span class="hljs-number">-1</span>);
	<span class="hljs-built_in">printf</span>(<span class="hljs-string">"插入成功！\n"</span>);

	<span class="hljs-keyword">return</span> OK;
}

<span class="hljs-function">Status <span class="hljs-title">DeListAcoName</span><span class="hljs-params">(SqList* L)</span>
</span>{
	<span class="hljs-keyword">int</span> i, j;
	<span class="hljs-built_in">printf</span>(<span class="hljs-string">"Please input the Bookname you want to delete： "</span>);
	<span class="hljs-keyword">int</span> b = <span class="hljs-number">1</span>;
	<span class="hljs-keyword">char</span> FindName[<span class="hljs-number">50</span>] = { <span class="hljs-number">0</span> };

	<span class="hljs-keyword">while</span> (b)
	{
		scanf_s(<span class="hljs-string">"%s"</span>, FindName,<span class="hljs-number">50</span>);
		<span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; L-&gt;length; i++)
		{
			<span class="hljs-keyword">if</span> ( <span class="hljs-built_in">strcmp</span>(L-&gt;data[i].BookName, FindName) == <span class="hljs-number">0</span> )
			{
				b = <span class="hljs-number">0</span>;
				<span class="hljs-keyword">break</span>;
			}
		}
		<span class="hljs-keyword">if</span> (i == L-&gt;length)
			<span class="hljs-built_in">printf</span>(<span class="hljs-string">"删除的图书不存在！请重新输入！\n"</span>);
	}

	<span class="hljs-keyword">for</span> (j = i; j &lt; L-&gt;length - <span class="hljs-number">1</span>; j++)
	{
		L-&gt;data[j] = L-&gt;data[j + <span class="hljs-number">1</span>];
	}
	L-&gt;length -= <span class="hljs-number">1</span>;
	<span class="hljs-built_in">printf</span>(<span class="hljs-string">"删除成功！\n"</span>);

	<span class="hljs-keyword">if</span> (L-&gt;length == <span class="hljs-number">0</span>)
		DestroyList(L);

	<span class="hljs-keyword">return</span> OK;
}

<span class="hljs-function">Status <span class="hljs-title">DeListAcoNum</span><span class="hljs-params">(SqList* L)</span>
</span>{
	<span class="hljs-keyword">int</span> i;
	<span class="hljs-built_in">printf</span>(<span class="hljs-string">"Please input the position i you want to delete： "</span>);
	<span class="hljs-keyword">int</span> b = <span class="hljs-number">1</span>;
	<span class="hljs-keyword">while</span> (b)
	{
		scanf_s(<span class="hljs-string">"%d"</span>, &amp;i);
		<span class="hljs-keyword">if</span> (i &lt; <span class="hljs-number">1</span> || i &gt; L-&gt;length)
		{
			<span class="hljs-built_in">printf</span>(<span class="hljs-string">"删除的位置不合理！请重新输入！\n"</span>);
		}
		<span class="hljs-keyword">else</span> b = <span class="hljs-number">0</span>;
	}

	<span class="hljs-keyword">int</span> j;
	<span class="hljs-keyword">for</span> (j = i - <span class="hljs-number">1</span>; j &lt; L-&gt;length - <span class="hljs-number">1</span>; j++)
	{
		L-&gt;data[j] = L-&gt;data[j + <span class="hljs-number">1</span>];
	}
	L-&gt;length -= <span class="hljs-number">1</span>;
	<span class="hljs-built_in">printf</span>(<span class="hljs-string">"删除成功！\n"</span>);

	<span class="hljs-keyword">if</span> (L-&gt;length == <span class="hljs-number">0</span>)
		DestroyList(L);

	<span class="hljs-keyword">return</span> OK;
}

<span class="hljs-function">Status <span class="hljs-title">GetName</span><span class="hljs-params">(SqList* L)</span>
</span>{
	<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* Is = <span class="hljs-string">"ISBN"</span>;
	<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* Na = <span class="hljs-string">"书名"</span>;
	<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* Pr = <span class="hljs-string">"价格"</span>;

	<span class="hljs-built_in">printf</span>(<span class="hljs-string">"请输入要查找的书名："</span>);
	<span class="hljs-keyword">char</span> FindName[<span class="hljs-number">50</span>] = { <span class="hljs-number">0</span> };
	scanf_s(<span class="hljs-string">"%s"</span>, FindName, <span class="hljs-number">50</span>);
	<span class="hljs-keyword">int</span> i;
	<span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; L-&gt;length; i++)
	{
		<span class="hljs-keyword">if</span> (<span class="hljs-built_in">strcmp</span>(FindName, L-&gt;data[i].BookName) == <span class="hljs-number">0</span>)
		{			
			<span class="hljs-built_in">printf</span>(<span class="hljs-string">"%-20s%-25s%-25s\n"</span>, Is, Na, Pr);
			<span class="hljs-built_in">printf</span>(<span class="hljs-string">"%-20s%-25s%-10.2f\n"</span>, L-&gt;data[i].ISBN, L-&gt;data[i].BookName, L-&gt;data[i].price);
			<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
		}
	}
	<span class="hljs-built_in">printf</span>(<span class="hljs-string">"查找的书名不存在！\n"</span>);
	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}

<span class="hljs-function">Status <span class="hljs-title">GetSeNum</span><span class="hljs-params">(SqList* L)</span>
</span>{
	<span class="hljs-keyword">int</span> i;
	<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* Is = <span class="hljs-string">"ISBN"</span>;
	<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* Na = <span class="hljs-string">"书名"</span>;
	<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* Pr = <span class="hljs-string">"价格"</span>;
	<span class="hljs-built_in">printf</span>(<span class="hljs-string">"请输入你要查找图书序号："</span>);
	scanf_s(<span class="hljs-string">"%d"</span>, &amp;i);
	<span class="hljs-keyword">if</span> (i &gt;= <span class="hljs-number">0</span> &amp;&amp; i &lt;= L-&gt;length)
	{
		<span class="hljs-built_in">printf</span>(<span class="hljs-string">"第%d条图书信息为\n"</span>, i);
		<span class="hljs-built_in">printf</span>(<span class="hljs-string">"%-20s%-25s%-25s\n"</span>, Is, Na, Pr);
		<span class="hljs-built_in">printf</span>(<span class="hljs-string">"%-20s%-25s%-10.2f\n"</span>, L-&gt;data[i<span class="hljs-number">-1</span>].ISBN, L-&gt;data[i<span class="hljs-number">-1</span>].BookName, L-&gt;data[i<span class="hljs-number">-1</span>].price);
	}
	
	<span class="hljs-keyword">else</span> <span class="hljs-built_in">printf</span>(<span class="hljs-string">"该序号图书不存在，请重新输入！"</span>);
	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}

<span class="hljs-function">Status <span class="hljs-title">GetNum</span><span class="hljs-params">(SqList* L)</span>
</span>{
	<span class="hljs-built_in">printf</span>(<span class="hljs-string">"图书总数为：“%d”\n"</span>, L-&gt;length);
	<span class="hljs-keyword">return</span> OK;
}

<span class="hljs-function">Status <span class="hljs-title">MdfPrice</span><span class="hljs-params">(SqList* L)</span>
</span>{
	<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* Is = <span class="hljs-string">"ISBN"</span>;
	<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* Na = <span class="hljs-string">"书名"</span>;
	<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* Pr = <span class="hljs-string">"价格"</span>;

	<span class="hljs-built_in">printf</span>(<span class="hljs-string">"请输入要修改价格的书名："</span>);
	<span class="hljs-keyword">char</span> FindName[<span class="hljs-number">50</span>] = { <span class="hljs-number">0</span> };
	scanf_s(<span class="hljs-string">"%s"</span>, FindName, <span class="hljs-number">50</span>);
	<span class="hljs-keyword">int</span> i;
	<span class="hljs-keyword">float</span> NewPrice;
	<span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; L-&gt;length; i++)
	{
		<span class="hljs-keyword">if</span> (<span class="hljs-built_in">strcmp</span>(FindName, L-&gt;data[i].BookName) == <span class="hljs-number">0</span>)
		{
			<span class="hljs-built_in">printf</span>(<span class="hljs-string">"该图书的信息为：\n"</span>);
			<span class="hljs-built_in">printf</span>(<span class="hljs-string">"%-20s%-25s%-25s\n"</span>, Is, Na, Pr);
			<span class="hljs-built_in">printf</span>(<span class="hljs-string">"%-20s%-25s%-10.2f \n"</span>, L-&gt;data[i].ISBN, L-&gt;data[i].BookName, L-&gt;data[i].price);
			
			<span class="hljs-built_in">printf</span>(<span class="hljs-string">"请输入新价格："</span>);
			scanf_s(<span class="hljs-string">"%f"</span>, &amp;NewPrice);
			L-&gt;data[i].price = NewPrice;
			<span class="hljs-built_in">printf</span>(<span class="hljs-string">"修改后图书信息为：\n"</span>);
			<span class="hljs-built_in">printf</span>(<span class="hljs-string">"%-20s%-25s%-25s\n"</span>, Is, Na, Pr);
			<span class="hljs-built_in">printf</span>(<span class="hljs-string">"%-20s%-25s%-10.2f\n"</span>, L-&gt;data[i].ISBN, L-&gt;data[i].BookName, L-&gt;data[i].price);
			<span class="hljs-keyword">return</span> OK;
		}
	}
	<span class="hljs-built_in">printf</span>(<span class="hljs-string">"查找的书名不存在！\n"</span>);
	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}

<span class="hljs-function">Status <span class="hljs-title">IsEmpty</span><span class="hljs-params">(SqList* L)</span>
</span>{
	<span class="hljs-keyword">if</span> (L-&gt;length == <span class="hljs-number">0</span> &amp;&amp; L-&gt;listsize == <span class="hljs-number">0</span>)
		<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
	<span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}

<span class="hljs-function">Status <span class="hljs-title">DestroyList</span><span class="hljs-params">(SqList* L)</span>
</span>{
	<span class="hljs-keyword">if</span> (L-&gt;data)
	{
		<span class="hljs-built_in">free</span>(L-&gt;data);
		L-&gt;data = <span class="hljs-literal">NULL</span>;
		L-&gt;length = <span class="hljs-number">0</span>;
		L-&gt;listsize = <span class="hljs-number">0</span>;
	}
	<span class="hljs-keyword">return</span> OK;
}
</div></code></pre>
<h4 id="913-a-name-1a%E5%85%9A%E5%8F%B2%E5%AD%A6%E4%B9%A0">9.1.3. <a name='-1'></a>党史学习</h4>
<pre class="hljs"><code><div><span class="hljs-comment">//120211080526 计算机2105 张烁</span>
<span class="hljs-comment">/*
*      Q1：党史学习（50分）
*      （1）将不少于3条党史信息初始化保存到单链表中
*      （2）根据代表名字，查找所有相关的历史信息并输出
*      （3）插入一条新的党史信息到单链表中
*      （4）输出全部信息
*      （5）根据输入的年份，修改相关信息（如：代表人数）
*      （6）清空整张表信息
*/</span>
<span class="hljs-comment">/*	测试样例
		事件			时间		主要人物
		中共一大		1921年		毛泽东	董必武
		中共三大		1923年		陈独秀		
		五卅运动		1925年		刘少奇
		南昌起义		1927年		周恩来
		遵义会议		1935年		毛泽东
		中共十二大		1982年		邓小平
		中共十六大		2002年		江泽民
		中共十九大		2017年		习近平
*/</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> _CRT_SECURE_NO_WARNINGS</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string.h&gt;</span></span>

<span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span>
{</span>
	<span class="hljs-keyword">char</span> event[<span class="hljs-number">20</span>];
	<span class="hljs-keyword">char</span> time[<span class="hljs-number">20</span>];
	<span class="hljs-keyword">char</span> MainPeo[<span class="hljs-number">10</span>];
}PartyInfo;

<span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span>
{</span>
	PartyInfo data;
	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span> *<span class="hljs-title">next</span>;</span>
}LNode,*LinkList;

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">InitLink</span><span class="hljs-params">(LinkList* L,LinkList *R)</span>
</span>{
	*L = (LinkList)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(LNode));
	(*R) = (*L);
	<span class="hljs-keyword">if</span> ((*L) == <span class="hljs-literal">NULL</span>)
		<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
	
	(*L)-&gt;next = <span class="hljs-literal">NULL</span>;
	<span class="hljs-built_in">printf</span>(<span class="hljs-string">"创建空表成功!\n"</span>);
	<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
}

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">InsertLink</span><span class="hljs-params">(LinkList* L,LinkList *R)</span>
</span>{
	<span class="hljs-keyword">int</span> n;
	<span class="hljs-built_in">printf</span>(<span class="hljs-string">"请输入要插入的信息条数："</span>);
	<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>, &amp;n);
	<span class="hljs-keyword">int</span> i;
	<span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; n; i++) {
		LinkList s = (LinkList)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(LNode));
		<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%s %s %s"</span>, s-&gt;data.event, s-&gt;data.time, s-&gt;data.MainPeo);
		s-&gt;next = <span class="hljs-literal">NULL</span>;
		(*R)-&gt;next = s;
		(*R) = s;
	}
	<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
}

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">Getname</span><span class="hljs-params">(LinkList L)</span>
</span>{
	<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* Ev = <span class="hljs-string">"事件"</span>;
	<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* Ti = <span class="hljs-string">"时间"</span>;
	<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* Mp = <span class="hljs-string">"主要人物"</span>;
	<span class="hljs-keyword">char</span> FindName[<span class="hljs-number">20</span>];
	<span class="hljs-built_in">printf</span>(<span class="hljs-string">"请输入代表名字："</span>);
	<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%s"</span>, FindName);

	LinkList p = L-&gt;next;
	<span class="hljs-keyword">int</span> head = <span class="hljs-number">1</span>,j = <span class="hljs-number">0</span>;
	<span class="hljs-keyword">while</span> (p) {
		<span class="hljs-keyword">if</span> (<span class="hljs-built_in">strcmp</span>(FindName, p-&gt;data.MainPeo) == <span class="hljs-number">0</span>) {
			<span class="hljs-keyword">if</span> (head == <span class="hljs-number">1</span>) {
				<span class="hljs-built_in">printf</span>(<span class="hljs-string">"		%-15s%-15s%-15s\n"</span>, Ev, Ti, Mp);
				head = <span class="hljs-number">0</span>;
			}
			<span class="hljs-built_in">printf</span>(<span class="hljs-string">"		%-15s%-15s%-15s\n"</span>, p-&gt;data.event, p-&gt;data.time, p-&gt;data.MainPeo);
			j++;
		}
		p = p-&gt;next;
	}
	<span class="hljs-keyword">if</span> (j == <span class="hljs-number">0</span>) {
		<span class="hljs-built_in">printf</span>(<span class="hljs-string">"你所查找的信息为空！\n"</span>);
		<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
	}
	<span class="hljs-keyword">if</span> (j)
		<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
	<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
}

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">TraverLinkList</span><span class="hljs-params">(LinkList L)</span>
</span>{
	<span class="hljs-keyword">if</span> (L-&gt;next) {
		<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* Ev = <span class="hljs-string">"事件"</span>;
		<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* Ti = <span class="hljs-string">"时间"</span>;
		<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* Mp = <span class="hljs-string">"主要人物"</span>;
		<span class="hljs-built_in">printf</span>(<span class="hljs-string">"	%-15s%-15s%-15s\n"</span>, Ev, Ti, Mp);
		LinkList p = L-&gt;next;
		<span class="hljs-keyword">while</span> (p) {
			<span class="hljs-built_in">printf</span>(<span class="hljs-string">"	%-15s%-15s%-15s\n"</span>, p-&gt;data.event, p-&gt;data.time, p-&gt;data.MainPeo);
			p = p-&gt;next;
		}
		<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
	}
	<span class="hljs-keyword">else</span> <span class="hljs-built_in">printf</span>(<span class="hljs-string">"链表为空！\n"</span>);
	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
	
}

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">ModifyAcoYear</span><span class="hljs-params">(LinkList L)</span>
</span>{
	<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* Ev = <span class="hljs-string">"事件"</span>;
	<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* Ti = <span class="hljs-string">"时间"</span>;
	<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* Mp = <span class="hljs-string">"主要人物"</span>;
	<span class="hljs-keyword">char</span> FindTime[<span class="hljs-number">20</span>];
	<span class="hljs-built_in">printf</span>(<span class="hljs-string">"请输入年份（如：2000年）："</span>);
	<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%s"</span>, FindTime);

	LinkList p = L-&gt;next;
	<span class="hljs-keyword">int</span> head = <span class="hljs-number">1</span>, j = <span class="hljs-number">0</span>;
	<span class="hljs-keyword">while</span> (p) {
		<span class="hljs-keyword">if</span> (<span class="hljs-built_in">strcmp</span>(FindTime, p-&gt;data.time) == <span class="hljs-number">0</span>) {
			<span class="hljs-keyword">if</span> (head == <span class="hljs-number">1</span>) {
				<span class="hljs-built_in">printf</span>(<span class="hljs-string">"	%-10s%-10s%-10s\n"</span>, Ev, Ti, Mp);
				head = <span class="hljs-number">0</span>;
			}
			<span class="hljs-built_in">printf</span>(<span class="hljs-string">"	%-10s%-10s%-10s\n"</span>, p-&gt;data.event, p-&gt;data.time, p-&gt;data.MainPeo);
			<span class="hljs-built_in">printf</span>(<span class="hljs-string">"请输入新的代表人物信息："</span>);
			<span class="hljs-keyword">char</span> NewPeoInfo[<span class="hljs-number">20</span>];
				<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%s"</span>, NewPeoInfo);
				<span class="hljs-built_in">strcpy</span>(p-&gt;data.MainPeo, NewPeoInfo);
			j++;
		}
		p = p-&gt;next;
	}
	<span class="hljs-keyword">if</span> (j == <span class="hljs-number">0</span>) {
		<span class="hljs-built_in">printf</span>(<span class="hljs-string">"你所查找的信息为空！\n"</span>);
		<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
	}
	<span class="hljs-keyword">if</span> (j)
		<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
	<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
}

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">ClearLink</span><span class="hljs-params">(LinkList L)</span>
</span>{
	LinkList p;
	<span class="hljs-keyword">while</span> (L-&gt;next)
	{
		p = L-&gt;next;
		L-&gt;next = p-&gt;next;
		<span class="hljs-built_in">free</span>(p);
	}
	<span class="hljs-built_in">printf</span>(<span class="hljs-string">"链表已清空！\n"</span>);
	<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
}

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
	LinkList L = (LinkList)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(LNode));
	LinkList R;
	<span class="hljs-keyword">int</span> sta = <span class="hljs-number">1</span>;
	<span class="hljs-built_in">printf</span>(<span class="hljs-string">"--------------------------功能界面--------------------------\n"</span>);
	<span class="hljs-built_in">printf</span>(<span class="hljs-string">"--------------------------党史学习--------------------------\n"</span>);
	<span class="hljs-built_in">printf</span>(<span class="hljs-string">"	1. 初始化创建空链表；\n"</span>);
	<span class="hljs-built_in">printf</span>(<span class="hljs-string">"	2. 初始化后输入党史信息；\n"</span>);
	<span class="hljs-built_in">printf</span>(<span class="hljs-string">"	3. 输出全部党史信息；\n"</span>);
	<span class="hljs-built_in">printf</span>(<span class="hljs-string">"	4. 插入新的党史信息；\n"</span>);
	<span class="hljs-built_in">printf</span>(<span class="hljs-string">"	5. 根据代表名字，查找所有相关的历史信息并输出；\n"</span>);
	<span class="hljs-built_in">printf</span>(<span class="hljs-string">"	6. 根据输入的年份，修改代表人物信息；\n"</span>);
	<span class="hljs-built_in">printf</span>(<span class="hljs-string">"	7. 清空整张表信息；\n"</span>);
	<span class="hljs-built_in">printf</span>(<span class="hljs-string">"	8. 退出。\n"</span>);

	<span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)
	{
		<span class="hljs-keyword">int</span> fun;
		<span class="hljs-built_in">printf</span>(<span class="hljs-string">"------------------------请输入功能对应数字："</span>);
		scanf_s(<span class="hljs-string">"%d"</span>, &amp;fun);
		getchar();
		<span class="hljs-keyword">switch</span> (fun)
		{
			<span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:
				InitLink(&amp;L,&amp;R);
				<span class="hljs-keyword">break</span>;
			<span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:
				InsertLink(&amp;L, &amp;R);
				<span class="hljs-keyword">break</span>;
			<span class="hljs-keyword">case</span> <span class="hljs-number">3</span>:
				TraverLinkList(L);
				<span class="hljs-keyword">break</span>;
			<span class="hljs-keyword">case</span> <span class="hljs-number">4</span>:
				InsertLink(&amp;L, &amp;R);
				<span class="hljs-keyword">break</span>;
			<span class="hljs-keyword">case</span> <span class="hljs-number">5</span>:
				Getname(L);
				<span class="hljs-keyword">break</span>;
			<span class="hljs-keyword">case</span> <span class="hljs-number">6</span>:
				ModifyAcoYear(L);
				<span class="hljs-keyword">break</span>;
			<span class="hljs-keyword">case</span> <span class="hljs-number">7</span>:
				ClearLink(L);
				<span class="hljs-keyword">break</span>;
			<span class="hljs-keyword">case</span> <span class="hljs-number">8</span>:
				<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
				<span class="hljs-keyword">break</span>;
			<span class="hljs-keyword">default</span>:
				<span class="hljs-built_in">printf</span>(<span class="hljs-string">"输入错误，请重新输入！\n"</span>);
				<span class="hljs-keyword">break</span>;
			}
			<span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n"</span>);
	}
	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</div></code></pre>
<h4 id="914-a-name-1a%E5%AD%A6%E4%B9%A0%E5%BC%BA%E5%9B%BD">9.1.4. <a name='-1'></a>学习强国</h4>
<pre class="hljs"><code><div><span class="hljs-comment">/*  
*	采用单链表存储。存储信息为：学习强国中所列新思想或要闻。
*	具体包括：发布时间，内容标题，阅读量，点赞量。
*	完成功能：
*			1. 初始化创建空表；
*			2. 插入；
*			3. 删除；
*			4. 查找（按关键字）；
*			5. 输出
*			6. 排序
*	主函数中调用，顺序完成以下操作：
*			初始化空表；插入至少5条数据；
*			输出；按关键字查找（关键字可以根据表中信息自定义，比如，“冬奥”，“碳汇”等）；
*			输出；删除找到的信息；
*			输出；
*			按点赞量排序；
*			输出。
*/</span>
<span class="hljs-comment">/*	测试样例
	发布时间	内容标题	阅读量		点赞量
	0407		冬奥		123			111
	0408		抗疫		222			527
	0409		抗疫在行动  345			555
	0410		冬奥进行时  333			666
	0411		学习党史    567			444
	0504		五四运动	725			999
*/</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> _CRT_SECURE_NO_WARNINGS</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;locale.h&gt;</span></span>

<span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span>
{</span>
	<span class="hljs-keyword">char</span> time[<span class="hljs-number">10</span>];
	<span class="hljs-keyword">char</span> head[<span class="hljs-number">20</span>];
	<span class="hljs-keyword">int</span> <span class="hljs-built_in">read</span>;
	<span class="hljs-keyword">int</span> Like;
}Learn;

<span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span>
{</span>
	Learn data;
	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span>* <span class="hljs-title">next</span>;</span>
}LNode, * LinkList;

<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* Ti = <span class="hljs-string">"发布时间"</span>;
<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* He = <span class="hljs-string">"内容标题"</span>;
<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* Re = <span class="hljs-string">"阅读量"</span>;
<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* Li = <span class="hljs-string">"点赞量"</span>;
<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* po = <span class="hljs-string">"位置"</span>;

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">Init</span><span class="hljs-params">(LinkList* L)</span>
</span>{
	*L = (LinkList)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(LNode));
	(*L)-&gt;next = <span class="hljs-literal">NULL</span>;
	<span class="hljs-built_in">printf</span>(<span class="hljs-string">"	创建成功!\n"</span>);
	<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
}

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">Insert</span><span class="hljs-params">(LinkList* L)</span>
</span>{
	<span class="hljs-keyword">int</span> n;
	<span class="hljs-built_in">printf</span>(<span class="hljs-string">"    Please input the number of the informtions:"</span>);
	<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>, &amp;n);
	<span class="hljs-keyword">int</span> i;
	<span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; n; i++)
	{
		LinkList s = (LinkList)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(LNode));
		<span class="hljs-built_in">printf</span>(<span class="hljs-string">"  	"</span>);
		<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%s%s%d%d"</span>, &amp;s-&gt;data.time, &amp;s-&gt;data.head, &amp;s-&gt;data.<span class="hljs-built_in">read</span>, &amp;s-&gt;data.Like);
		s-&gt;next = (*L)-&gt;next;
		(*L)-&gt;next = s;
	}
	<span class="hljs-built_in">printf</span>(<span class="hljs-string">"    Succeed!\n"</span>);
	<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
}

<span class="hljs-function">LinkList <span class="hljs-title">Pos</span><span class="hljs-params">(LinkList* L, LinkList s)</span>
</span>{
	LinkList p = *L;
	<span class="hljs-keyword">while</span> (p-&gt;next != s) {
		p = p-&gt;next;
	}
	<span class="hljs-keyword">return</span> p;
}

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">Del</span><span class="hljs-params">(LinkList* L, <span class="hljs-keyword">int</span> Dp)</span>
</span>{
	LinkList p = *L;
	<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>;
	<span class="hljs-keyword">while</span> (p &amp;&amp; j &lt; Dp - <span class="hljs-number">1</span>) {
		p = p-&gt;next;
		j++;
	}

	LinkList q = p-&gt;next;
	p-&gt;next = q-&gt;next;
	<span class="hljs-built_in">free</span>(q);
	<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;

}

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sort</span><span class="hljs-params">(LinkList* L)</span>
</span>{
	LinkList p;
	p = (*L)-&gt;next;
	(*L)-&gt;next = <span class="hljs-literal">NULL</span>;
	<span class="hljs-keyword">while</span> (p)
	{
		LinkList q = p-&gt;next;
		LinkList s = (*L);
		<span class="hljs-keyword">while</span> (s-&gt;next != <span class="hljs-literal">NULL</span> &amp;&amp; s-&gt;next-&gt;data.Like &lt; p-&gt;data.Like) {
			s = s-&gt;next;
		}
		p-&gt;next = s-&gt;next;
		s-&gt;next = p;
		p = q;
	}
	<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
}

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">Disp</span><span class="hljs-params">(LinkList L)</span>
</span>{
	<span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n"</span>);
	LinkList p = L-&gt;next;
	<span class="hljs-built_in">printf</span>(<span class="hljs-string">"	%-15s%-15s%-15s%-15s%-15s\n"</span>, Ti, He, Re, Li, po);
	<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>;
	<span class="hljs-keyword">while</span> (p)
	{
		<span class="hljs-built_in">printf</span>(<span class="hljs-string">"	%-15s%-15s%-15d%-15d%-15d\n"</span>, p-&gt;data.time, p-&gt;data.head, p-&gt;data.<span class="hljs-built_in">read</span>, p-&gt;data.Like, j);
		p = p-&gt;next;
		j++;
	}
	<span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n"</span>);
	<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
}

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">Substring</span><span class="hljs-params">(<span class="hljs-keyword">char</span>* main, <span class="hljs-keyword">char</span>* sub)</span>
</span>{
	<span class="hljs-keyword">if</span> (<span class="hljs-built_in">strstr</span>(main, sub))
		<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
}

<span class="hljs-function">LinkList <span class="hljs-title">GetKeyWord</span><span class="hljs-params">(LinkList L)</span>
</span>{
	LinkList p = L-&gt;next;
	<span class="hljs-keyword">char</span> keyword[<span class="hljs-number">100</span>];
	<span class="hljs-built_in">printf</span>(<span class="hljs-string">"	请输入关键词："</span>);
	<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%s"</span>, keyword);
	<span class="hljs-keyword">int</span> sta = <span class="hljs-number">1</span>;
	<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>;
	<span class="hljs-keyword">while</span> (p) {
		<span class="hljs-keyword">if</span> (Substring(p-&gt;data.head, keyword)) {
			<span class="hljs-keyword">if</span> (sta == <span class="hljs-number">1</span>) {
				<span class="hljs-built_in">printf</span>(<span class="hljs-string">"	%-15s%-15s%-15s%-15s%-15s\n"</span>, Ti, He, Re, Li, po);
				sta = <span class="hljs-number">0</span>;
			}
			<span class="hljs-built_in">printf</span>(<span class="hljs-string">"	%-15s%-15s%-15d%-15d%-15d\n"</span>, p-&gt;data.time, p-&gt;data.head, p-&gt;data.<span class="hljs-built_in">read</span>, p-&gt;data.Like, j);

		}
		j++;
		p = p-&gt;next;

	}
	<span class="hljs-keyword">return</span> p;
}

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">PrintMenu</span><span class="hljs-params">()</span>
</span>{
	<span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n"</span>);
	<span class="hljs-built_in">printf</span>(<span class="hljs-string">"        ******************************************\n"</span>);
	<span class="hljs-built_in">printf</span>(<span class="hljs-string">"        **************** 学习强国 ****************\n"</span>);
	<span class="hljs-built_in">printf</span>(<span class="hljs-string">"        ******************************************\n"</span>);
}

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">Clear</span><span class="hljs-params">(LinkList* L)</span>
</span>{
	(*L)-&gt;next = <span class="hljs-literal">NULL</span>;
	<span class="hljs-built_in">printf</span>(<span class="hljs-string">"清空成功！\n"</span>);
	<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
}

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">IsEmpty</span><span class="hljs-params">(LinkList L)</span>
</span>{
	<span class="hljs-keyword">if</span> (L-&gt;next == <span class="hljs-literal">NULL</span>)
	{
		<span class="hljs-built_in">printf</span>(<span class="hljs-string">"链表为空！请插入信息！\n"</span>);
		<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
	}
	<span class="hljs-keyword">else</span>
		<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
	PrintMenu();
	LinkList L = (LinkList)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(LNode));
	LinkList R = (LinkList)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(LNode));
	LinkList Find = (LinkList)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(LNode));
	<span class="hljs-keyword">int</span> sta = <span class="hljs-number">1</span>;
	<span class="hljs-built_in">printf</span>(<span class="hljs-string">"	1. 初始化\n"</span>);
	<span class="hljs-built_in">printf</span>(<span class="hljs-string">"	2. 插入信息\n"</span>);
	<span class="hljs-built_in">printf</span>(<span class="hljs-string">"	3. 输出\n"</span>);
	<span class="hljs-built_in">printf</span>(<span class="hljs-string">"	4. 按点赞量输出\n"</span>);
	<span class="hljs-built_in">printf</span>(<span class="hljs-string">"	5. 关键字查找并输出\n"</span>);
	<span class="hljs-built_in">printf</span>(<span class="hljs-string">"	6. 删除信息\n"</span>);
	<span class="hljs-built_in">printf</span>(<span class="hljs-string">"	7. 清空\n"</span>);
	<span class="hljs-built_in">printf</span>(<span class="hljs-string">"	8. 退出\n"</span>);
	<span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n"</span>);
	<span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)
	{
		<span class="hljs-keyword">int</span> fun;
		<span class="hljs-built_in">printf</span>(<span class="hljs-string">"  Input The Corresponding Number:"</span>);
		<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>, &amp;fun);
		getchar();
		<span class="hljs-keyword">switch</span> (fun)
		{
			<span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:
				Init(&amp;L);
				<span class="hljs-keyword">break</span>;
			<span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:
				Insert(&amp;L);
				<span class="hljs-keyword">break</span>;
			<span class="hljs-keyword">case</span> <span class="hljs-number">3</span>:
				IsEmpty(L);
				Disp(L);
				<span class="hljs-keyword">break</span>;
			<span class="hljs-keyword">case</span> <span class="hljs-number">4</span>:
				IsEmpty(L);
				sort(&amp;L);
				Disp(L);
				<span class="hljs-keyword">break</span>;
			<span class="hljs-keyword">case</span> <span class="hljs-number">5</span>:
				IsEmpty(L);
				GetKeyWord(L);
				<span class="hljs-keyword">int</span> yn;
				<span class="hljs-built_in">printf</span>(<span class="hljs-string">"	要删除吗？(1/0)"</span>);
				<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>, &amp;yn);
				<span class="hljs-keyword">while</span> (yn) {
					<span class="hljs-keyword">int</span> Dp;
					<span class="hljs-built_in">printf</span>(<span class="hljs-string">"	请输入要删除的位置"</span>);
					<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>, &amp;Dp);
					Del(&amp;L, Dp);
					<span class="hljs-keyword">int</span> YN;
					<span class="hljs-built_in">printf</span>(<span class="hljs-string">"    继续吗？(1/0)\n     "</span>);
					<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>, &amp;YN);
					<span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n"</span>);
					<span class="hljs-keyword">if</span> (YN == <span class="hljs-number">1</span>)
						<span class="hljs-keyword">continue</span>;
					<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (YN == <span class="hljs-number">0</span>)
						<span class="hljs-keyword">break</span>;
				}
				<span class="hljs-keyword">break</span>;
			<span class="hljs-keyword">case</span> <span class="hljs-number">6</span>:
				IsEmpty(L);
				<span class="hljs-keyword">int</span> D;
				<span class="hljs-built_in">printf</span>(<span class="hljs-string">"	请输入要删除的位置:"</span>);
				<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>, &amp;D);
				Del(&amp;L, D);
				<span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n"</span>);
				<span class="hljs-keyword">break</span>;
			<span class="hljs-keyword">case</span> <span class="hljs-number">7</span>:
				Clear(&amp;L);
				<span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n"</span>);
				<span class="hljs-keyword">break</span>;
			<span class="hljs-keyword">case</span> <span class="hljs-number">8</span>:
				<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
			<span class="hljs-keyword">default</span>:
				<span class="hljs-built_in">printf</span>(<span class="hljs-string">"ERROR!\n"</span>);
				<span class="hljs-keyword">break</span>;
		}
	}
	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</div></code></pre>
<h4 id="915-a-name-1a%E9%9B%86%E5%90%88%E5%8F%8A%E5%85%B6%E8%BF%90%E7%AE%97">9.1.5. <a name='-1'></a>集合及其运算</h4>
<pre class="hljs"><code><div><span class="hljs-comment">/*
*      Q2：整数集合用单链表实现存储，实现如下操作：（30分）
*		（1）初始化集合
*		（2）插入一个数到集合指定位置
*		（3）按值删除集合中的元素
*		（4）按值在集合中进行查找
*		（5）清空集合
*		（6）求两个集合的交集
*		（7）求两个集合的并集
*		（8）求两个集合的差集
*		（9）输出集合
*/</span>
<span class="hljs-comment">/*
	测试样例
		初始化 5 2 7 3 3 6 4 9 7 0 8 1 6
		LA：1 9 9 1 27 8 16 2 3 5 7 7 0 0 
		LB：2  2357 3 0 57 8 52 8 8 8 
*/</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> _CRT_SECURE_NO_WARNINGS</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string.h&gt;</span></span>

<span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span>
{</span>
	<span class="hljs-keyword">int</span> data;
	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span>* <span class="hljs-title">next</span>;</span>
}LNode, * LinkList;


<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">InitLink</span><span class="hljs-params">(LinkList* L, LinkList R)</span>
</span>{
	<span class="hljs-keyword">if</span> ((*L) == <span class="hljs-literal">NULL</span>)
		<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;

	(*L)-&gt;next = <span class="hljs-literal">NULL</span>;
	<span class="hljs-built_in">printf</span>(<span class="hljs-string">"创建空表成功!\n"</span>);
	<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
}

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">InsertLink</span><span class="hljs-params">(LinkList* L, LinkList R)</span>
</span>{
	<span class="hljs-keyword">int</span> n;
	LinkList Rear = (*L);
	<span class="hljs-built_in">printf</span>(<span class="hljs-string">"请输入要插入个数："</span>);
	<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>, &amp;n);
	<span class="hljs-keyword">int</span> i;
	<span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; n; i++) {
		LinkList s = (LinkList)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(LNode));
		<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>, &amp;s-&gt;data);
		s-&gt;next = <span class="hljs-literal">NULL</span>;
		Rear-&gt;next = s;
		Rear = s;
	}
	<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
}

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">DeleteLinkPos</span><span class="hljs-params">(LinkList* L)</span>
</span>{
	<span class="hljs-keyword">int</span> e;
	<span class="hljs-built_in">printf</span>(<span class="hljs-string">"请输入要删除的值："</span>);
	<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>, &amp;e);
	LinkList p = (*L)-&gt;next;
	LinkList q = p-&gt;next;
	<span class="hljs-keyword">while</span> (q) {
		<span class="hljs-keyword">if</span> (q-&gt;data == e) {
			p-&gt;next = q-&gt;next;
			<span class="hljs-built_in">free</span>(q);
			q = p-&gt;next;
		}
		<span class="hljs-keyword">else</span> {
			p = p-&gt;next;
			q = q-&gt;next;
		}
	}
	<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
}

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">GetPosAcoNum</span><span class="hljs-params">(LinkList L)</span>
</span>{
	LinkList p = L-&gt;next;
	<span class="hljs-keyword">int</span> e;
	<span class="hljs-built_in">printf</span>(<span class="hljs-string">"请输入要查找的值:"</span>);
	<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>, &amp;e);
	<span class="hljs-keyword">int</span> sta = <span class="hljs-number">1</span>;
	<span class="hljs-keyword">int</span> pos = <span class="hljs-number">1</span>;
	<span class="hljs-keyword">while</span> (p)
	{
		<span class="hljs-keyword">if</span> (p-&gt;data == e) {
			<span class="hljs-keyword">if</span> (sta = <span class="hljs-number">1</span>) {
				<span class="hljs-built_in">printf</span>(<span class="hljs-string">"	该元素出现在"</span>);
				sta = <span class="hljs-number">0</span>;
			}
			<span class="hljs-built_in">printf</span>(<span class="hljs-string">"位置%d"</span>, pos);
		}
		pos++;
		p = p-&gt;next;
	}
	<span class="hljs-keyword">if</span> (sta == <span class="hljs-number">1</span>) {
		<span class="hljs-built_in">printf</span>(<span class="hljs-string">"查无此数！\n"</span>);
		<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
	}
	<span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n"</span>);
	<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;					
}

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">InsertLinkPos</span><span class="hljs-params">(LinkList* L)</span>
</span>{
	<span class="hljs-keyword">int</span> i;
	<span class="hljs-built_in">printf</span>(<span class="hljs-string">"请输入要插入的位置："</span>);
	<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>, &amp;i);
	<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>;
	LinkList p = (*L)-&gt;next;
	<span class="hljs-keyword">while</span> ( p &amp;&amp; j &lt; i<span class="hljs-number">-1</span> ) {
		p = p-&gt;next;
		++j;
	}

	<span class="hljs-keyword">if</span> (!p)
		<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;

	LinkList s = (LinkList)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(LNode));
	<span class="hljs-keyword">int</span> e;
	<span class="hljs-built_in">printf</span>(<span class="hljs-string">"请输入要插入的数："</span>);
	<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>, &amp;e);
	s-&gt;data = e;
	s-&gt;next = p-&gt;next;
	p-&gt;next = s;
	<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
}

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">ClearLink</span><span class="hljs-params">(LinkList L)</span>
</span>{
	LinkList p;
	<span class="hljs-keyword">while</span> (L-&gt;next)
	{
		p = L-&gt;next;
		L-&gt;next = p-&gt;next;
		<span class="hljs-built_in">free</span>(p);
	}
	<span class="hljs-built_in">printf</span>(<span class="hljs-string">"链表已清空！\n"</span>);
	<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
}

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">TraverLinkList</span><span class="hljs-params">(LinkList L)</span>
</span>{
	<span class="hljs-keyword">if</span> (L-&gt;next) {
		LinkList p = L-&gt;next;
		<span class="hljs-keyword">while</span> (p) {
			<span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d "</span>, p-&gt;data);
			p = p-&gt;next;
		}
		<span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n"</span>);
		<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
	}
	<span class="hljs-keyword">else</span> <span class="hljs-built_in">printf</span>(<span class="hljs-string">"链表为空！\n"</span>);
	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;

}

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">SortLink</span><span class="hljs-params">(LinkList* L)</span>
</span>{
	LinkList p = (*L)-&gt;next;
	(*L)-&gt;next = <span class="hljs-literal">NULL</span>;

	<span class="hljs-keyword">while</span>(p) {
		LinkList s;
		LinkList q;
		s = (*L);
		q = p-&gt;next;
		<span class="hljs-keyword">while</span> (s-&gt;next &amp;&amp; s-&gt;next-&gt;data &lt; p-&gt;data) {
			s = s-&gt;next;
		}
		p-&gt;next = s-&gt;next;
		s-&gt;next = p;
		p = q;
	}
	<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
}

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">SortAndDelReapted</span><span class="hljs-params">(LinkList L)</span>
</span>{
	LinkList p, q;
	p = L-&gt;next;
	q = p-&gt;next;
	<span class="hljs-keyword">while</span> (p &amp;&amp; q)
	{
		<span class="hljs-keyword">if</span> (p-&gt;data == q-&gt;data)
		{
			p-&gt;next = q-&gt;next;
			<span class="hljs-built_in">free</span>(q);
			q = p-&gt;next;
		}
		<span class="hljs-keyword">else</span>
		{
			p = q;
			q = p-&gt;next;
		}
		
	}
	<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
}

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">Intersection</span><span class="hljs-params">(LinkList LA, LinkList LB)</span>
</span>{
	LinkList LC = (LinkList)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(LNode));
	LC-&gt;next = <span class="hljs-literal">NULL</span>;
	LinkList pc = LC;
	LinkList pa = LA-&gt;next;
	LinkList pb = LB-&gt;next;
	<span class="hljs-keyword">while</span> (pa &amp;&amp; pb) {
		<span class="hljs-keyword">if</span> (pa-&gt;data &lt; pb-&gt;data) {
			pa = pa-&gt;next;
		}
		<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (pa-&gt;data &gt; pb-&gt;data) {
			pb = pb-&gt;next;
		}
		<span class="hljs-keyword">else</span> {
			LinkList s = (LinkList)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(LNode));
			s-&gt;data = pa-&gt;data;
			s-&gt;next = pc-&gt;next;
			pc-&gt;next = s;
			pc = s;
			pa = pa-&gt;next;
			pb = pb-&gt;next;
		}
	}
	
	<span class="hljs-built_in">printf</span>(<span class="hljs-string">"集合Set_A为：\n"</span>);
	<span class="hljs-built_in">printf</span>(<span class="hljs-string">"		"</span>);
	TraverLinkList(LA);
	<span class="hljs-built_in">printf</span>(<span class="hljs-string">"集合Set_B为：\n"</span>);
	<span class="hljs-built_in">printf</span>(<span class="hljs-string">"		"</span>);
	TraverLinkList(LB);
	<span class="hljs-built_in">printf</span>(<span class="hljs-string">"集合Set_A与Set_B的交集为：\n"</span>);
	<span class="hljs-built_in">printf</span>(<span class="hljs-string">"		"</span>);
	TraverLinkList(LC);
	<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
}

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">Union</span><span class="hljs-params">(LinkList LA, LinkList LB)</span>
</span>{
	LinkList LC = (LinkList)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(LNode));
	LC-&gt;next = <span class="hljs-literal">NULL</span>;
	LinkList pc = LC;
	LinkList pa = LA-&gt;next;
	LinkList pb = LB-&gt;next;
	<span class="hljs-keyword">while</span> (pa &amp;&amp; pb) {
		<span class="hljs-keyword">if</span> (pa-&gt;data &lt; pb-&gt;data) {
			LinkList s = (LinkList)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(LNode));
			s-&gt;data = pa-&gt;data;
			s-&gt;next = pc-&gt;next;
			pc-&gt;next = s;
			pc = s;
			pa = pa-&gt;next;
		}
		<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (pa-&gt;data &gt; pb-&gt;data) {
			LinkList s = (LinkList)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(LNode));
			s-&gt;data = pb-&gt;data;
			s-&gt;next = pc-&gt;next;
			pc-&gt;next = s;
			pc = s;
			pb = pb-&gt;next;
		}
		<span class="hljs-keyword">else</span> {
			LinkList s = (LinkList)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(LNode));
			s-&gt;data = pa-&gt;data;
			s-&gt;next = pc-&gt;next;
			pc-&gt;next = s;
			pc = s;
			pa = pa-&gt;next;
			pb = pb-&gt;next;
		}
	}
	<span class="hljs-keyword">if</span> (pa)
		pc-&gt;next = pa;
	<span class="hljs-keyword">if</span> (pb)
		pc-&gt;next = pb;

	<span class="hljs-built_in">printf</span>(<span class="hljs-string">"集合Set_A为：\n"</span>);
	<span class="hljs-built_in">printf</span>(<span class="hljs-string">"		"</span>);
	TraverLinkList(LA);
	<span class="hljs-built_in">printf</span>(<span class="hljs-string">"集合Set_B为：\n"</span>);
	<span class="hljs-built_in">printf</span>(<span class="hljs-string">"		"</span>);
	TraverLinkList(LB);
	<span class="hljs-built_in">printf</span>(<span class="hljs-string">"集合Set_A与Set_B的并集为：\n"</span>);
	<span class="hljs-built_in">printf</span>(<span class="hljs-string">"		"</span>);
	TraverLinkList(LC);
	<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
}

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">Complement</span><span class="hljs-params">(LinkList LA, LinkList LB)</span>
</span>{
	LinkList LC = (LinkList)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(LNode));
	LC-&gt;next = <span class="hljs-literal">NULL</span>;
	LinkList pc = LC;
	LinkList pa = LA-&gt;next;
	LinkList pb = LB-&gt;next;
	<span class="hljs-keyword">while</span> (pa&amp;&amp;pb) {
		<span class="hljs-keyword">if</span> (pa-&gt;data == pb-&gt;data) {
			pa = pa-&gt;next;
			pb = pb-&gt;next;
		}
		<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (pa-&gt;data &lt; pb-&gt;data) {
			LinkList s = (LinkList)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(LNode));
			s-&gt;data = pa-&gt;data;
			s-&gt;next = pc-&gt;next;
			pc-&gt;next = s;
			pc = s;
			pa = pa-&gt;next;
		}
		<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (pa-&gt;data &gt; pb-&gt;data) {
			pb = pb-&gt;next;
		}
	}
	<span class="hljs-keyword">if</span> (pa)
		pc-&gt;next = pa;


	<span class="hljs-built_in">printf</span>(<span class="hljs-string">"集合Set_A为：\n"</span>);
	<span class="hljs-built_in">printf</span>(<span class="hljs-string">"		"</span>);
	TraverLinkList(LA);
	<span class="hljs-built_in">printf</span>(<span class="hljs-string">"集合Set_B为：\n"</span>);
	<span class="hljs-built_in">printf</span>(<span class="hljs-string">"		"</span>);
	TraverLinkList(LB);
	<span class="hljs-built_in">printf</span>(<span class="hljs-string">"集合Set_A与Set_B的差集为：\n"</span>);
	<span class="hljs-built_in">printf</span>(<span class="hljs-string">"		"</span>);
	TraverLinkList(LC);
	<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
}

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
	LinkList LA = (LinkList)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(LNode));
	LinkList LB = (LinkList)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(LNode));
	LinkList LC = (LinkList)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(LNode));
	LinkList Ra = LA;
	LinkList Rb = LB;
	<span class="hljs-built_in">printf</span>(<span class="hljs-string">"--------------------------功能界面--------------------------\n"</span>);
	<span class="hljs-built_in">printf</span>(<span class="hljs-string">"------------------------集合极其运算------------------------\n"</span>);
	<span class="hljs-built_in">printf</span>(<span class="hljs-string">"	1. 初始化创建空集合；\n"</span>);
	<span class="hljs-built_in">printf</span>(<span class="hljs-string">"	2. 初始化后输入集合元素；\n"</span>);
	<span class="hljs-built_in">printf</span>(<span class="hljs-string">"	3. 输出全部集合元素；\n"</span>);
	<span class="hljs-built_in">printf</span>(<span class="hljs-string">"	4. 插入一个数到集合指定位置；\n"</span>);
	<span class="hljs-built_in">printf</span>(<span class="hljs-string">"	5. 按值删除集合中的元素；\n"</span>);
	<span class="hljs-built_in">printf</span>(<span class="hljs-string">"	6. 按值在集合中进行查找；\n"</span>);
	<span class="hljs-built_in">printf</span>(<span class="hljs-string">"	7. 清空集合；\n"</span>);
	<span class="hljs-built_in">printf</span>(<span class="hljs-string">"	8. 进行集合运算；\n"</span>);
	<span class="hljs-built_in">printf</span>(<span class="hljs-string">"	9. 求两个集合的交集；\n"</span>);
	<span class="hljs-built_in">printf</span>(<span class="hljs-string">"	10.求两个集合的并集；\n"</span>);
	<span class="hljs-built_in">printf</span>(<span class="hljs-string">"	11.求两个集合的差集；\n"</span>);
	<span class="hljs-built_in">printf</span>(<span class="hljs-string">"	0. 退出。\n"</span>);

	<span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)
	{
		<span class="hljs-keyword">int</span> fun;
		<span class="hljs-built_in">printf</span>(<span class="hljs-string">"------------------------请输入功能对应数字："</span>);
		scanf_s(<span class="hljs-string">"%d"</span>, &amp;fun);
		getchar();
		<span class="hljs-keyword">switch</span> (fun)
		{
			<span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:
				InitLink(&amp;LA, Ra);
				<span class="hljs-keyword">break</span>;
			<span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:
				InsertLink(&amp;LA, Ra);
				<span class="hljs-keyword">break</span>;
			<span class="hljs-keyword">case</span> <span class="hljs-number">3</span>:
				TraverLinkList(LA);
				<span class="hljs-keyword">break</span>;
			<span class="hljs-keyword">case</span> <span class="hljs-number">4</span>:
				InsertLinkPos(&amp;LA);
				<span class="hljs-keyword">break</span>;
			<span class="hljs-keyword">case</span> <span class="hljs-number">5</span>:
				DeleteLinkPos(&amp;LA);
				<span class="hljs-keyword">break</span>;
			<span class="hljs-keyword">case</span> <span class="hljs-number">6</span>:
				GetPosAcoNum(LA);
				<span class="hljs-keyword">break</span>;
			<span class="hljs-keyword">case</span> <span class="hljs-number">7</span>:
				ClearLink(LA);
				<span class="hljs-keyword">break</span>;
			<span class="hljs-keyword">case</span> <span class="hljs-number">8</span>:
				InitLink(&amp;LA, Ra);
				<span class="hljs-built_in">printf</span>(<span class="hljs-string">"	输入Set_A的元素：\n"</span>);
				InsertLink(&amp;LA, Ra);
				SortLink(&amp;LA);
				<span class="hljs-built_in">printf</span>(<span class="hljs-string">"				"</span>);
				TraverLinkList(LA);

				InitLink(&amp;LB, Rb);
				<span class="hljs-built_in">printf</span>(<span class="hljs-string">"	输入Set_B的元素：\n"</span>);
				InsertLink(&amp;LB, Rb);
				SortLink(&amp;LB);
				<span class="hljs-built_in">printf</span>(<span class="hljs-string">"				"</span>);
				TraverLinkList(LB);
				<span class="hljs-keyword">break</span>;
			<span class="hljs-keyword">case</span> <span class="hljs-number">9</span>:
				Intersection(LA, LB);
				<span class="hljs-keyword">break</span>;
			<span class="hljs-keyword">case</span> <span class="hljs-number">10</span>:
				SortAndDelReapted(LA);
				SortAndDelReapted(LB);
				Union(LA, LB);
				<span class="hljs-keyword">break</span>;
			<span class="hljs-keyword">case</span> <span class="hljs-number">11</span>:
				SortAndDelReapted(LA);
				SortAndDelReapted(LB);
				Complement(LA, LB);
				<span class="hljs-keyword">break</span>;
			<span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:
				<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
				<span class="hljs-keyword">break</span>;
			<span class="hljs-keyword">default</span>:
				<span class="hljs-built_in">printf</span>(<span class="hljs-string">"输入错误，请重新输入！\n"</span>);
				<span class="hljs-keyword">break</span>;
			}
			<span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n"</span>);
	}
	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</div></code></pre>
<h4 id="916-a-name-1a%E5%8F%8C%E5%90%91%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8%E5%AE%9E%E9%AA%8C">9.1.6. <a name='-1'></a>双向循环链表实验</h4>
<pre class="hljs"><code><div><span class="hljs-comment">/*
*		Q3：整数序列保存在双向链表中，实现如下操作：（20分）
*		（1）创建；
*		（2）遍历输出；
*		（3）按值查找；
*		（4）按位序插入；
*		（5）按位序删除；
*/</span>
<span class="hljs-comment">/*
	测试样例
		初始化 5 2 7 3  3  6  4  9 7 0 8 1 6      13个
			   1 9 9 1  27 8  16 2 3 5 7 7		  12个
			   2 3 0 57 8  52 8  8 8 0 0 2357	  12个
*/</span>

<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> _CRT_SECURE_NO_WARNINGS</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span>

<span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">DulNode</span>
{</span>
	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">DulNode</span>* <span class="hljs-title">prior</span>;</span>
	<span class="hljs-keyword">int</span> data;
	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">DulNode</span>* <span class="hljs-title">next</span>;</span>
}DulNode, *DuLinkList;

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">InitDuLinkList</span><span class="hljs-params">(DuLinkList* L)</span>
</span>{
	*L = (DuLinkList)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(DulNode));
	<span class="hljs-keyword">if</span> (*L == <span class="hljs-literal">NULL</span>) {
		<span class="hljs-built_in">printf</span>(<span class="hljs-string">"申请空间失败！\n"</span>);
			<span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);
	}
	(*L)-&gt;next = (*L)-&gt;prior = *L;
	<span class="hljs-built_in">printf</span>(<span class="hljs-string">"创建空表成功!\n"</span>);
	<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
}

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">InputDuLink</span><span class="hljs-params">(DuLinkList L)</span>
</span>{
	DuLinkList p = L;
	<span class="hljs-keyword">int</span> n;
	<span class="hljs-built_in">printf</span>(<span class="hljs-string">"请输入个数："</span>);
	<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>, &amp;n);
	<span class="hljs-keyword">int</span> i;
	<span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; n ; i++) {
		DuLinkList s = (DuLinkList)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(DulNode));
		<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>, &amp;s-&gt;data);
		s-&gt;next = p-&gt;next;		<span class="hljs-comment">//后继</span>
		p-&gt;next = s;
		s-&gt;prior = p;			<span class="hljs-comment">//前驱</span>
		p-&gt;next-&gt;prior = s;
		p = p-&gt;next;
	}
	<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
}

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">GetPosAcoNum</span><span class="hljs-params">(DuLinkList L)</span>
</span>{
	DuLinkList p = L-&gt;next;
	<span class="hljs-keyword">int</span> e;
	<span class="hljs-built_in">printf</span>(<span class="hljs-string">"请输入要查找的值:"</span>);
	<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>, &amp;e);
	<span class="hljs-keyword">int</span> sta = <span class="hljs-number">1</span>;
	<span class="hljs-keyword">int</span> pos = <span class="hljs-number">1</span>;
	<span class="hljs-keyword">while</span> (p-&gt;next!=L)
	{
		<span class="hljs-keyword">if</span> (p-&gt;data == e) {
			<span class="hljs-keyword">if</span> (sta = <span class="hljs-number">1</span>) {
				<span class="hljs-built_in">printf</span>(<span class="hljs-string">"	该元素出现在"</span>);
				sta = <span class="hljs-number">0</span>;
			}
			<span class="hljs-built_in">printf</span>(<span class="hljs-string">"位置%d"</span>, pos);
		}
		pos++;
		p = p-&gt;next;
	}
	<span class="hljs-keyword">if</span> (sta == <span class="hljs-number">1</span>) {
		<span class="hljs-built_in">printf</span>(<span class="hljs-string">"查无此数！\n"</span>);
		<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
	}
	<span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n"</span>);
	<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
}

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">DisDuLink</span><span class="hljs-params">(DuLinkList L)</span>
</span>{
	DuLinkList p = L-&gt;next;
	<span class="hljs-keyword">while</span> (p-&gt;next != L-&gt;next) {
		<span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d "</span>, p-&gt;data);
		p = p-&gt;next;
	}
	<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
}

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">DuDelete</span><span class="hljs-params">(DuLinkList L)</span>
</span>{
	DuLinkList p = L;
	<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>;
	<span class="hljs-keyword">int</span> i;
	<span class="hljs-built_in">printf</span>(<span class="hljs-string">"请输入要删除的位置："</span>);
	<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>, &amp;i);

	<span class="hljs-keyword">while</span> (p-&gt;next != L &amp;&amp; j &lt; i - <span class="hljs-number">1</span>) {
		p = p-&gt;next;
		++j;
	}

	<span class="hljs-keyword">if</span> (j&lt;i - <span class="hljs-number">1</span> || j &gt;i - <span class="hljs-number">1</span>){
		<span class="hljs-built_in">printf</span>(<span class="hljs-string">"链表为空或位置不合理！\n"</span>);
		<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
	}

	DuLinkList q = p-&gt;next;
	p-&gt;next = q-&gt;next;
	q-&gt;next-&gt;prior = p;
	<span class="hljs-built_in">free</span>(q);
	<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
}

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">DuInsert</span><span class="hljs-params">(DuLinkList L)</span>
</span>{
	DuLinkList p = L;		<span class="hljs-comment">//临时指针，指向头结点</span>
	DuLinkList New_p;		<span class="hljs-comment">//用于指向新节点</span>
	<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>;
	<span class="hljs-keyword">int</span> i;
	<span class="hljs-built_in">printf</span>(<span class="hljs-string">"请输入要插入的位置："</span>);
	<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>, &amp;i);

	<span class="hljs-keyword">while</span> (p-&gt;next != L &amp;&amp; j &lt; i - <span class="hljs-number">1</span>) {
		p = p-&gt;next;
		j++;
	}

	<span class="hljs-keyword">if</span> (j&lt;i - <span class="hljs-number">1</span> || j&gt;i - <span class="hljs-number">1</span>) {
		<span class="hljs-built_in">printf</span>(<span class="hljs-string">"位置不合理！\n"</span>);
		<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
	}

	<span class="hljs-keyword">int</span> e;
	<span class="hljs-built_in">printf</span>(<span class="hljs-string">"请输入要插入的数："</span>);
	<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>, &amp;e);
	DuLinkList s = (DuLinkList)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(DulNode));
	s-&gt;data = e;

	s-&gt;next = p-&gt;next;		<span class="hljs-comment">//后继</span>
	p-&gt;next = s;

	s-&gt;prior = p;			<span class="hljs-comment">//前驱</span>
	p-&gt;next-&gt;prior = s;
	<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
}

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
	DuLinkList L = (DuLinkList)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(DulNode));
	<span class="hljs-built_in">printf</span>(<span class="hljs-string">"--------------------------功能界面--------------------------\n"</span>);
	<span class="hljs-built_in">printf</span>(<span class="hljs-string">"------------------------双向循环链表------------------------\n"</span>);
	<span class="hljs-built_in">printf</span>(<span class="hljs-string">"	1. 初始化；\n"</span>);
	<span class="hljs-built_in">printf</span>(<span class="hljs-string">"	2. 初始化后输入元素；\n"</span>);
	<span class="hljs-built_in">printf</span>(<span class="hljs-string">"	3. 遍历输出；\n"</span>);
	<span class="hljs-built_in">printf</span>(<span class="hljs-string">"	4. 按值查找；\n"</span>);
	<span class="hljs-built_in">printf</span>(<span class="hljs-string">"	5. 按位序插入；\n"</span>);
	<span class="hljs-built_in">printf</span>(<span class="hljs-string">"	6. 按位序删除；\n"</span>);
	<span class="hljs-built_in">printf</span>(<span class="hljs-string">"	0. 退出。\n"</span>);

	<span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)
	{
		<span class="hljs-keyword">int</span> fun;
		<span class="hljs-built_in">printf</span>(<span class="hljs-string">"------------------------请输入功能对应数字："</span>);
		scanf_s(<span class="hljs-string">"%d"</span>, &amp;fun);
		getchar();
		<span class="hljs-keyword">switch</span> (fun)
		{
			<span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:
				InitDuLinkList(&amp;L);
				<span class="hljs-keyword">break</span>;
			<span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:
				InputDuLink(L);
				<span class="hljs-keyword">break</span>;
			<span class="hljs-keyword">case</span> <span class="hljs-number">3</span>:
				<span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n"</span>);
				<span class="hljs-built_in">printf</span>(<span class="hljs-string">"		"</span>);
				DisDuLink(L);
				<span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n"</span>);
				<span class="hljs-keyword">break</span>;
			<span class="hljs-keyword">case</span> <span class="hljs-number">4</span>:
				<span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n"</span>);
				GetPosAcoNum(L);
				
				<span class="hljs-keyword">break</span>;
			<span class="hljs-keyword">case</span> <span class="hljs-number">5</span>:
				<span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n"</span>);
				DuInsert(L);
				
				<span class="hljs-keyword">break</span>;
			<span class="hljs-keyword">case</span> <span class="hljs-number">6</span>:
				<span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n"</span>);
				DuDelete(L);
				
				<span class="hljs-keyword">break</span>;
			<span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:
				<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
				<span class="hljs-keyword">break</span>;
			<span class="hljs-keyword">default</span>:
				<span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n"</span>);
				<span class="hljs-built_in">printf</span>(<span class="hljs-string">"输入错误，请重新输入！\n"</span>);
				<span class="hljs-keyword">break</span>;
		}
		<span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n"</span>);
	}
	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</div></code></pre>
<h3 id="92-a-name-1a%E6%A0%88%E7%9A%84%E5%BA%94%E7%94%A8">9.2. <a name='-1'></a>栈的应用</h3>
<h4 id="921-a-name-1a%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2">9.2.1. <a name='-1'></a>进制转换</h4>
<pre class="hljs"><code><div><span class="hljs-comment">//十进制转八进制</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> _CRT_SECURE_NO_WARNINGS</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string.h&gt;</span></span>

<span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">StackNode</span>
{</span>
    <span class="hljs-keyword">int</span> data;
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">StackNode</span> * <span class="hljs-title">next</span>;</span>
}SNode, *LinkStack;

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">Push</span><span class="hljs-params">(LinkStack* S, <span class="hljs-keyword">int</span> e)</span>
</span>{
    LinkStack s = <span class="hljs-keyword">new</span> SNode;
    s-&gt;data = e;
    s-&gt;next = *S;
    *S = s;
    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
}

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">Pop</span><span class="hljs-params">(LinkStack* S)</span>
</span>{
    LinkStack p = *S;
    <span class="hljs-keyword">int</span> e;
    <span class="hljs-keyword">if</span> (p == <span class="hljs-literal">NULL</span>)
        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
    *S = p-&gt;next;
    e = p-&gt;data;
    <span class="hljs-built_in">free</span>(p);
    <span class="hljs-keyword">return</span> e;
}

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    LinkStack S = <span class="hljs-literal">NULL</span>;
    <span class="hljs-keyword">int</span> Ten;
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"请输入十进制数字："</span>);
    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>, &amp;Ten);
    <span class="hljs-keyword">int</span> temp, In;
    <span class="hljs-keyword">while</span> (Ten) {
        In = Ten / <span class="hljs-number">8</span>;
        temp = Ten % <span class="hljs-number">8</span>;
        Push(&amp;S, temp);
        Ten = In;
    }
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"转化为八进制的结果为："</span>);
    LinkStack p = S;
    <span class="hljs-keyword">while</span> (p)
    {
        p = p-&gt;next;
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d"</span>, Pop(&amp;S));
    }
    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
}
</div></code></pre>
<h4 id="922-a-name-1a%E6%8B%AC%E5%8F%B7%E5%8C%B9%E9%85%8D">9.2.2. <a name='-1'></a>括号匹配</h4>
<pre class="hljs"><code><div><span class="hljs-comment">/*
*      写程序，实现括号匹配（提示：首先定义并实现顺序栈）；
*/</span>
<span class="hljs-comment">/*	测试样例
        样例1     (){}[]
        样例2     {[()]}
        样例3     {{{{{{}2727()()][]
        样例4     {654*8-96+454}*(666-66)
        样例5     [[]]{{{}}}(({{[]}}))
*/</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> _CRT_SECURE_NO_WARNINGS</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string.h&gt;</span></span>

                                <span class="hljs-comment">//定义并实现顺序栈</span>
<span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Stack</span>{</span>
    <span class="hljs-keyword">char</span> Bracket[<span class="hljs-number">100</span>];
    <span class="hljs-keyword">int</span> top = <span class="hljs-number">-1</span>;
    <span class="hljs-keyword">int</span> StackSize = <span class="hljs-number">100</span>;
}Sqstack;

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">Empty</span><span class="hljs-params">(Sqstack S)</span> </span>{
    <span class="hljs-keyword">if</span> (S.top == <span class="hljs-number">-1</span>)
        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">Push</span><span class="hljs-params">(Sqstack *S, <span class="hljs-keyword">char</span> bra)</span> </span>{
    <span class="hljs-keyword">if</span>  (S-&gt;StackSize == S-&gt;top + <span class="hljs-number">1</span>)
        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
    S-&gt;top++;
    S-&gt;Bracket[S-&gt;top] = bra;
    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
}

<span class="hljs-function"><span class="hljs-keyword">char</span> <span class="hljs-title">Pop</span><span class="hljs-params">(Sqstack *S)</span> </span>{
    <span class="hljs-keyword">char</span> e;
    <span class="hljs-keyword">if</span> (S-&gt;top == <span class="hljs-number">-1</span>)
        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
    <span class="hljs-keyword">else</span> {
        e = S-&gt;Bracket[S-&gt;top--];
        <span class="hljs-keyword">return</span> e;
    }
}

<span class="hljs-function"><span class="hljs-keyword">char</span> <span class="hljs-title">GetTop</span><span class="hljs-params">(Sqstack S)</span> </span>{
    <span class="hljs-keyword">if</span> (S.top == <span class="hljs-number">-1</span>)
        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
    <span class="hljs-keyword">return</span> S.Bracket[S.top];
}

                                <span class="hljs-comment">//定义并实现顺序栈</span>

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">PrintMenu</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"        ******************************************\n"</span>);
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"        *                括号匹配                *\n"</span>);
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"        ******************************************\n"</span>);
}

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    PrintMenu();
    <span class="hljs-keyword">char</span> arr[<span class="hljs-number">100</span>];
    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)
    {
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"-----------请输入一串字符，包含括号：\n"</span>);
        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%s"</span>, arr);
        Sqstack S;
        <span class="hljs-keyword">int</span> i;
        <span class="hljs-keyword">int</span> state = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span> &amp;&amp; arr[i] != <span class="hljs-string">'\0'</span>; i++) {
            <span class="hljs-keyword">if</span> (arr[i] == <span class="hljs-string">'{'</span> || arr[i] == <span class="hljs-string">'('</span> || arr[i] == <span class="hljs-string">'['</span>) {
                Push(&amp;S, arr[i]);
                state++;
            }
            <span class="hljs-keyword">if</span> (arr[i] == <span class="hljs-string">')'</span>) {
                <span class="hljs-keyword">if</span> (GetTop(S) == <span class="hljs-string">'('</span>) {
                    Pop(&amp;S); 
                }
                <span class="hljs-keyword">else</span> {                 
                    <span class="hljs-keyword">break</span>;
                }
            }
            <span class="hljs-keyword">if</span> (arr[i] == <span class="hljs-string">']'</span>) {
                <span class="hljs-keyword">if</span> (GetTop(S) == <span class="hljs-string">'['</span>) {
                    Pop(&amp;S);  
                }
                <span class="hljs-keyword">else</span> {                
                    <span class="hljs-keyword">break</span>;
                }
            }
            <span class="hljs-keyword">if</span> (arr[i] == <span class="hljs-string">'}'</span>) {
                <span class="hljs-keyword">if</span> (GetTop(S) == <span class="hljs-string">'{'</span>) {
                    Pop(&amp;S);
                }
                <span class="hljs-keyword">else</span> {
                    <span class="hljs-keyword">break</span>;
                }
            }
        }
        <span class="hljs-keyword">if</span> (Empty(S) &amp;&amp; state) {
            <span class="hljs-built_in">printf</span>(<span class="hljs-string">"匹配！\n"</span>);
        }
        <span class="hljs-keyword">else</span> {
            <span class="hljs-built_in">printf</span>(<span class="hljs-string">"不匹配！\n"</span>);
        }
        <span class="hljs-keyword">int</span> YN;
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"继续吗？(1/0)\n"</span>);
        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>, &amp;YN);
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n"</span>);
        <span class="hljs-keyword">if</span> (YN == <span class="hljs-number">1</span>)
            <span class="hljs-keyword">continue</span>;
        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (YN == <span class="hljs-number">0</span>)
            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
    }
}
</div></code></pre>
<h4 id="923-a-name-1a%E5%9B%9E%E6%96%87%E5%88%A4%E6%96%AD">9.2.3. <a name='-1'></a>回文判断</h4>
<pre class="hljs"><code><div><span class="hljs-comment">/*
*      Q1: 写程序，进行回文判断（要求：定义链队和链栈）；
*/</span>
<span class="hljs-comment">/*	测试样例
        样例1     11111111111
        样例2     12321
        样例3     asc12321cba
        样例4     !@!@!@!@!
        样例5     d5z2q7q2z5d
        样例6     !@#$%^&amp;*()(*&amp;^%$#@!
        样例7     _+{}:"&lt;&gt;&lt;":}{+_
        样例7     [];',./.,';][
        样例8     /*-+-*/</span>
<span class="hljs-comment">//      样例9     ...qaq...</span>
<span class="hljs-comment">//      样例10    @!=!@</span>
<span class="hljs-comment">//</span>

<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> _CRT_SECURE_NO_WARNINGS</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string.h&gt;</span></span>

                                                        <span class="hljs-comment">//链栈操作</span>
<span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">StackNode</span>
{</span>
    <span class="hljs-keyword">char</span> data;
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">StackNode</span>* <span class="hljs-title">next</span>;</span>
}SNode, * LinkStack;

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">InitLinkStack</span><span class="hljs-params">(LinkStack* S)</span>
</span>{
    *S = <span class="hljs-literal">NULL</span>;					
    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
}

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">IsLinkStackEmpty</span><span class="hljs-params">(LinkStack S)</span>
</span>{
    <span class="hljs-keyword">if</span> (S == <span class="hljs-literal">NULL</span>)
        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
    <span class="hljs-keyword">else</span>
        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">LinkStackLength</span><span class="hljs-params">(LinkStack S)</span>
</span>{
    <span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>;
    LinkStack p = S;
    <span class="hljs-keyword">while</span> (p) {
        p = p-&gt;next;
        j++;
    }
    <span class="hljs-keyword">return</span> j;
}

<span class="hljs-function"><span class="hljs-keyword">char</span> <span class="hljs-title">GetLinkStackTop</span><span class="hljs-params">(LinkStack S)</span>
</span>{
    <span class="hljs-keyword">if</span> (S == <span class="hljs-literal">NULL</span>)
        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
    <span class="hljs-keyword">return</span> S-&gt;data;
}

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">PushLinkStack</span><span class="hljs-params">(LinkStack* S, <span class="hljs-keyword">char</span> c)</span>
</span>{
    LinkStack p = (LinkStack)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(SNode));
    <span class="hljs-keyword">if</span> (p == <span class="hljs-literal">NULL</span>)
        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
    p-&gt;data = c;
    p-&gt;next = *S;
    *S = p;
    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
}

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">PopLinkStack</span><span class="hljs-params">(LinkStack* S)</span>
</span>{
    LinkStack p = *S;
    <span class="hljs-keyword">if</span> (p == <span class="hljs-literal">NULL</span>)
        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
    *S = p-&gt;next;
    <span class="hljs-built_in">free</span>(p);
    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
}

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">ClearLinkStack</span><span class="hljs-params">(LinkStack* S)</span> </span>{
    LinkStack p = (*S)-&gt;next;
    <span class="hljs-keyword">while</span> (p) {
        p = p-&gt;next;
        PopLinkStack(S);
    }
    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
}

                                                        <span class="hljs-comment">//链队操作</span>
<span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">QNode</span>
{</span>
    <span class="hljs-keyword">char</span> data;
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">QNode</span>* <span class="hljs-title">next</span>;</span>
}QNode, * QueuePtr;

<span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span>
{</span>
    QueuePtr front;
    QueuePtr rear;
}LinkQueue;

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">InitQueue</span><span class="hljs-params">(LinkQueue* Q)</span>
</span>{
    Q-&gt;front = Q-&gt;rear = (QueuePtr)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(QNode));
    <span class="hljs-keyword">if</span> (!Q-&gt;front)
        <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);
    Q-&gt;front-&gt;next = <span class="hljs-literal">NULL</span>;
    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
}

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">LinkQueueLength</span><span class="hljs-params">(LinkQueue Q)</span> </span>{
    QueuePtr p = Q.front-&gt;next;
    <span class="hljs-keyword">int</span> n = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">if</span> (Q.front == Q.rear)
        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
    <span class="hljs-keyword">while</span> (p) {
        n++;
        p = p-&gt;next;
    }
    <span class="hljs-keyword">return</span> n;
}

<span class="hljs-function"><span class="hljs-keyword">char</span> <span class="hljs-title">GetLinkQueueTop</span><span class="hljs-params">(LinkQueue Q)</span>
</span>{
    <span class="hljs-keyword">if</span> (Q.front == Q.rear)
        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
    <span class="hljs-keyword">return</span>  Q.front-&gt;next-&gt;data;;
}

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">AppendQueue</span><span class="hljs-params">(LinkQueue* Q, <span class="hljs-keyword">char</span> e)</span>
</span>{
    QueuePtr p = (QueuePtr)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(QNode));
    <span class="hljs-keyword">if</span> (!p)
        <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);
    p-&gt;data = e;
    p-&gt;next = <span class="hljs-literal">NULL</span>;
    Q-&gt;rear-&gt;next = p;
    Q-&gt;rear = p;
    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
}

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">DeQueue</span><span class="hljs-params">(LinkQueue* Q)</span>
</span>{
    <span class="hljs-keyword">if</span> (Q-&gt;front == Q-&gt;rear)
        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
    QueuePtr p = Q-&gt;front-&gt;next;
    Q-&gt;front-&gt;next = p-&gt;next;

    <span class="hljs-keyword">if</span> (Q-&gt;rear == p)
        Q-&gt;rear = Q-&gt;front;

    <span class="hljs-built_in">free</span>(p);
    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
}

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">ClearQueue</span><span class="hljs-params">(LinkQueue *Q)</span>
</span>{
    Q-&gt;front = Q-&gt;rear;
    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
}

                                                      <span class="hljs-comment">//判断回文</span>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">Palindrome</span><span class="hljs-params">(LinkStack S, LinkQueue Q)</span>
</span>{
    <span class="hljs-keyword">if</span> (LinkStackLength(S) != LinkQueueLength(Q))
        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
    <span class="hljs-keyword">while</span> (!IsLinkStackEmpty(S))
    {
        <span class="hljs-keyword">char</span> e1, e2;
        <span class="hljs-keyword">if</span> (GetLinkStackTop(S) != GetLinkQueueTop(Q))
            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
        <span class="hljs-keyword">else</span> {
            PopLinkStack(&amp;S);
            DeQueue(&amp;Q);
        }
    }
    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
}

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">PrintMenu</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n"</span>);
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"        ******************************************\n"</span>);
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"        *                回文判断                *\n"</span>);
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"        ******************************************\n"</span>);
}

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    PrintMenu();
    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) {
        LinkStack S;
        LinkQueue Q;
        InitLinkStack(&amp;S);
        InitQueue(&amp;Q);
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"        请输入一串字符："</span>);
        <span class="hljs-keyword">char</span> P[<span class="hljs-number">50</span>];
        <span class="hljs-keyword">int</span> i;
        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%s"</span>, P);
        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; P[i] != <span class="hljs-string">'\0'</span>; i++) {
            PushLinkStack(&amp;S, P[i]);
            AppendQueue(&amp;Q, P[i]);
        }
        <span class="hljs-keyword">if</span> (Palindrome(S, Q))
            <span class="hljs-built_in">printf</span>(<span class="hljs-string">"    ——————————%s是回文数！\n"</span>,P);
        <span class="hljs-keyword">else</span>
            <span class="hljs-built_in">printf</span>(<span class="hljs-string">"    ——————————%s不是回文数！\n"</span>,P);

        <span class="hljs-keyword">int</span> YN;
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"    继续吗？(1/0)\n     "</span>);
        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>, &amp;YN);
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n"</span>);
        <span class="hljs-keyword">if</span> (YN == <span class="hljs-number">1</span>)
            <span class="hljs-keyword">continue</span>;
        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (YN == <span class="hljs-number">0</span>)
            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
    }
}
</div></code></pre>
<h4 id="924-a-name-1a%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC">9.2.4. <a name='-1'></a>表达式求值</h4>
<pre class="hljs"><code><div><span class="hljs-comment">/*
*      Q3：写程序，实现表达式求值
*		   基本要求：操作数为1位整数；
*		   高阶要求：操作数为实数。
*/</span>
<span class="hljs-comment">/*	测试样例
	1+2+3#
	1.1+2.2+3.3#
	1+2-3#
	-2+3.1#
	-5.27*2+3.14*5#
	6+1/0#
	2.7+(-5*2.1+4)#
	8.16/5.27+19.91-20.03/3.06+(-7.25*2)#
*/</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> _CRT_SECURE_NO_WARNINGS</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string.h&gt;</span></span>

<span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">StackNode</span>
{</span>
	<span class="hljs-keyword">char</span> data;
	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">StackNode</span>* <span class="hljs-title">next</span>;</span>
}SNode, * LinkStack;

<span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">NumStack</span>
{</span>
	<span class="hljs-keyword">float</span> data;
	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">NumStack</span>* <span class="hljs-title">next</span>;</span>
}NSNode, *NumLinkStack;

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">InitLinkStack</span><span class="hljs-params">(LinkStack* S)</span>
</span>{
	*S = <span class="hljs-literal">NULL</span>;		
	<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
}

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">InitLinkStack2</span><span class="hljs-params">(NumLinkStack* S)</span>
</span>{
	*S = <span class="hljs-literal">NULL</span>;
	<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
}

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">IsLinkStackEmpty</span><span class="hljs-params">(LinkStack S)</span>
</span>{
	<span class="hljs-keyword">if</span> (S == <span class="hljs-literal">NULL</span>)
		<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
	<span class="hljs-keyword">else</span>
		<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">IsLinkStackEmpty2</span><span class="hljs-params">(NumLinkStack S)</span>
</span>{
	<span class="hljs-keyword">if</span> (S == <span class="hljs-literal">NULL</span>)
		<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
	<span class="hljs-keyword">else</span>
		<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}

<span class="hljs-function"><span class="hljs-keyword">char</span> <span class="hljs-title">GetLinkStackTop</span><span class="hljs-params">(LinkStack S)</span>
</span>{
	<span class="hljs-keyword">if</span> (S == <span class="hljs-literal">NULL</span>)
		<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
	<span class="hljs-keyword">return</span> S-&gt;data;
}

<span class="hljs-function"><span class="hljs-keyword">float</span> <span class="hljs-title">GetLinkStackTop2</span><span class="hljs-params">(NumLinkStack S)</span>
</span>{
	<span class="hljs-keyword">if</span> (S == <span class="hljs-literal">NULL</span>)
		<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
	<span class="hljs-keyword">return</span> S-&gt;data;
}

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">LinkStackLength</span><span class="hljs-params">(LinkStack S)</span>
</span>{
	<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>;
	LinkStack p = S;
	<span class="hljs-keyword">while</span> (p) {
		p = p-&gt;next;
		j++;
	}
	<span class="hljs-keyword">return</span> j;
}

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">LinkStackLength2</span><span class="hljs-params">(NumLinkStack S)</span>
</span>{
	<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>;
	NumLinkStack p = S;
	<span class="hljs-keyword">while</span> (p) {
		p = p-&gt;next;
		j++;
	}
	<span class="hljs-keyword">return</span> j;
}

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">PushLinkStack</span><span class="hljs-params">(LinkStack* S,<span class="hljs-keyword">char</span> e)</span>
</span>{
	LinkStack p = (LinkStack)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(SNode));
	<span class="hljs-keyword">if</span> (p == <span class="hljs-literal">NULL</span>)
		<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
	p-&gt;data = e;
	p-&gt;next = *S;
	*S = p;
	<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
}

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">PushLinkStack2</span><span class="hljs-params">(NumLinkStack* S, <span class="hljs-keyword">float</span> e)</span>
</span>{
	NumLinkStack p = (NumLinkStack)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(NSNode));
	<span class="hljs-keyword">if</span> (p == <span class="hljs-literal">NULL</span>)
		<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
	p-&gt;data = e;
	p-&gt;next = *S;
	*S = p;
	<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
}

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">PopLinkStack</span><span class="hljs-params">(LinkStack* S)</span>
</span>{
	LinkStack p = *S;
	<span class="hljs-keyword">if</span> (p == <span class="hljs-literal">NULL</span>)
		<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
	*S = p-&gt;next;
	<span class="hljs-built_in">free</span>(p);
	<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
}

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">PopLinkStack2</span><span class="hljs-params">(NumLinkStack* S)</span>
</span>{
	NumLinkStack p = *S;
	<span class="hljs-keyword">if</span> (p == <span class="hljs-literal">NULL</span>)
		<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
	*S = p-&gt;next;
	<span class="hljs-built_in">free</span>(p);
	<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
}

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">TraversLinkStack</span><span class="hljs-params">(LinkStack S)</span>
</span>{
	<span class="hljs-keyword">if</span> (S == <span class="hljs-literal">NULL</span>) {
		<span class="hljs-built_in">printf</span>(<span class="hljs-string">"栈空！"</span>);
		<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
	}
	<span class="hljs-keyword">while</span> (S) {
		<span class="hljs-built_in">printf</span>(<span class="hljs-string">"%c"</span>, S-&gt;data);
		S = S-&gt;next;
	}
	<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
}

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">TraversLinkStack2</span><span class="hljs-params">(NumLinkStack S)</span>
</span>{
	<span class="hljs-keyword">if</span> (S == <span class="hljs-literal">NULL</span>) {
		<span class="hljs-built_in">printf</span>(<span class="hljs-string">"栈空！"</span>);
		<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
	}
	<span class="hljs-keyword">while</span> (S) {
		<span class="hljs-built_in">printf</span>(<span class="hljs-string">"%.2f "</span>, S-&gt;data);
		S = S-&gt;next;
	}
	<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
}

<span class="hljs-function"><span class="hljs-keyword">char</span> <span class="hljs-title">Prior</span><span class="hljs-params">(<span class="hljs-keyword">char</span> theta1, <span class="hljs-keyword">char</span> theta2)</span>
</span>{
	<span class="hljs-keyword">int</span> i, j;
	<span class="hljs-keyword">char</span> pri[<span class="hljs-number">7</span>][<span class="hljs-number">7</span>] = {<span class="hljs-comment">//  +   -   *   /   (   )   # </span>
						{<span class="hljs-string">'&gt;'</span>,<span class="hljs-string">'&gt;'</span>,<span class="hljs-string">'&lt;'</span>,<span class="hljs-string">'&lt;'</span>,<span class="hljs-string">'&lt;'</span>,<span class="hljs-string">'&gt;'</span>,<span class="hljs-string">'&gt;'</span>},
						{<span class="hljs-string">'&gt;'</span>,<span class="hljs-string">'&gt;'</span>,<span class="hljs-string">'&lt;'</span>,<span class="hljs-string">'&lt;'</span>,<span class="hljs-string">'&lt;'</span>,<span class="hljs-string">'&gt;'</span>,<span class="hljs-string">'&gt;'</span>},
						{<span class="hljs-string">'&gt;'</span>,<span class="hljs-string">'&gt;'</span>,<span class="hljs-string">'&gt;'</span>,<span class="hljs-string">'&gt;'</span>,<span class="hljs-string">'&lt;'</span>,<span class="hljs-string">'&gt;'</span>,<span class="hljs-string">'&gt;'</span>},
						{<span class="hljs-string">'&gt;'</span>,<span class="hljs-string">'&gt;'</span>,<span class="hljs-string">'&gt;'</span>,<span class="hljs-string">'&gt;'</span>,<span class="hljs-string">'&lt;'</span>,<span class="hljs-string">'&gt;'</span>,<span class="hljs-string">'&gt;'</span>},
						{<span class="hljs-string">'&lt;'</span>,<span class="hljs-string">'&lt;'</span>,<span class="hljs-string">'&lt;'</span>,<span class="hljs-string">'&lt;'</span>,<span class="hljs-string">'&lt;'</span>,<span class="hljs-string">'='</span>,<span class="hljs-string">'0'</span>},
						{<span class="hljs-string">'&gt;'</span>,<span class="hljs-string">'&gt;'</span>,<span class="hljs-string">'&gt;'</span>,<span class="hljs-string">'&gt;'</span>,<span class="hljs-string">'0'</span>,<span class="hljs-string">'&gt;'</span>,<span class="hljs-string">'&gt;'</span>},
						{<span class="hljs-string">'&lt;'</span>,<span class="hljs-string">'&lt;'</span>,<span class="hljs-string">'&lt;'</span>,<span class="hljs-string">'&lt;'</span>,<span class="hljs-string">'&lt;'</span>,<span class="hljs-string">'0'</span>,<span class="hljs-string">'='</span>} };

	<span class="hljs-keyword">switch</span> (theta1) {
						<span class="hljs-keyword">case</span> <span class="hljs-string">'+'</span>: i = <span class="hljs-number">0</span>; <span class="hljs-keyword">break</span>;
						<span class="hljs-keyword">case</span> <span class="hljs-string">'-'</span>: i = <span class="hljs-number">1</span>; <span class="hljs-keyword">break</span>;
						<span class="hljs-keyword">case</span> <span class="hljs-string">'*'</span>: i = <span class="hljs-number">2</span>; <span class="hljs-keyword">break</span>;
						<span class="hljs-keyword">case</span> <span class="hljs-string">'/'</span>: i = <span class="hljs-number">3</span>; <span class="hljs-keyword">break</span>;
						<span class="hljs-keyword">case</span> <span class="hljs-string">'('</span>: i = <span class="hljs-number">4</span>; <span class="hljs-keyword">break</span>;
						<span class="hljs-keyword">case</span> <span class="hljs-string">')'</span>: i = <span class="hljs-number">5</span>; <span class="hljs-keyword">break</span>;
						<span class="hljs-keyword">case</span> <span class="hljs-string">'#'</span>: i = <span class="hljs-number">6</span>; <span class="hljs-keyword">break</span>;
	}

	<span class="hljs-keyword">switch</span> (theta2) {
						<span class="hljs-keyword">case</span> <span class="hljs-string">'+'</span>: j = <span class="hljs-number">0</span>; <span class="hljs-keyword">break</span>;
						<span class="hljs-keyword">case</span> <span class="hljs-string">'-'</span>: j = <span class="hljs-number">1</span>; <span class="hljs-keyword">break</span>;
						<span class="hljs-keyword">case</span> <span class="hljs-string">'*'</span>: j = <span class="hljs-number">2</span>; <span class="hljs-keyword">break</span>;
						<span class="hljs-keyword">case</span> <span class="hljs-string">'/'</span>: j = <span class="hljs-number">3</span>; <span class="hljs-keyword">break</span>;
						<span class="hljs-keyword">case</span> <span class="hljs-string">'('</span>: j = <span class="hljs-number">4</span>; <span class="hljs-keyword">break</span>;
						<span class="hljs-keyword">case</span> <span class="hljs-string">')'</span>: j = <span class="hljs-number">5</span>; <span class="hljs-keyword">break</span>;
						<span class="hljs-keyword">case</span> <span class="hljs-string">'#'</span>: j = <span class="hljs-number">6</span>; <span class="hljs-keyword">break</span>;
	}
	<span class="hljs-keyword">return</span> pri[i][j];
}

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">IsOPRT</span><span class="hljs-params">(<span class="hljs-keyword">char</span> c)</span>
</span>{
	<span class="hljs-keyword">if</span> (c == <span class="hljs-string">'+'</span> || c == <span class="hljs-string">'-'</span> || c == <span class="hljs-string">'*'</span> || c == <span class="hljs-string">'/'</span> || c == <span class="hljs-string">'('</span> || c == <span class="hljs-string">')'</span> || c == <span class="hljs-string">'#'</span>)
		<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
	<span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">IsNum</span><span class="hljs-params">(<span class="hljs-keyword">char</span> c)</span>
</span>{
	<span class="hljs-keyword">switch</span> (c)
	{
		<span class="hljs-keyword">case</span> <span class="hljs-string">'0'</span>:
		<span class="hljs-keyword">case</span> <span class="hljs-string">'1'</span>:
		<span class="hljs-keyword">case</span> <span class="hljs-string">'2'</span>:
		<span class="hljs-keyword">case</span> <span class="hljs-string">'3'</span>:
		<span class="hljs-keyword">case</span> <span class="hljs-string">'4'</span>:
		<span class="hljs-keyword">case</span> <span class="hljs-string">'5'</span>:
		<span class="hljs-keyword">case</span> <span class="hljs-string">'6'</span>:
		<span class="hljs-keyword">case</span> <span class="hljs-string">'7'</span>:
		<span class="hljs-keyword">case</span> <span class="hljs-string">'8'</span>:
		<span class="hljs-keyword">case</span> <span class="hljs-string">'9'</span>:
			<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
		<span class="hljs-keyword">default</span>:
			<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
			<span class="hljs-keyword">break</span>;
	}
	<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
}

<span class="hljs-function"><span class="hljs-keyword">float</span> <span class="hljs-title">CCLT</span><span class="hljs-params">(<span class="hljs-keyword">float</span> left, <span class="hljs-keyword">float</span> right, <span class="hljs-keyword">char</span> operators)</span>
</span>{
	<span class="hljs-keyword">switch</span> (operators)
	{
		<span class="hljs-keyword">case</span> <span class="hljs-string">'+'</span>:
			<span class="hljs-keyword">return</span>  left + right;
		<span class="hljs-keyword">case</span> <span class="hljs-string">'-'</span>:
			<span class="hljs-keyword">return</span> left - right;
		<span class="hljs-keyword">case</span> <span class="hljs-string">'*'</span>:	
			<span class="hljs-keyword">return</span> <span class="hljs-keyword">float</span>(left * right);
		<span class="hljs-keyword">case</span> <span class="hljs-string">'/'</span>:
			<span class="hljs-keyword">if</span> (right != <span class="hljs-number">0</span>)
				<span class="hljs-keyword">return</span> <span class="hljs-keyword">float</span>(left / right);
			<span class="hljs-keyword">else</span>
			{
				<span class="hljs-built_in">printf</span>(<span class="hljs-string">"Divisor can not Be zero!\n"</span>);
				<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
			}
	}
	<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
}

<span class="hljs-function"><span class="hljs-keyword">float</span> <span class="hljs-title">CCLT2</span><span class="hljs-params">(<span class="hljs-keyword">float</span> left, <span class="hljs-keyword">float</span> right, <span class="hljs-keyword">char</span> operators)</span>
</span>{
	<span class="hljs-keyword">switch</span> (operators)
	{
		<span class="hljs-keyword">case</span> <span class="hljs-string">'+'</span>:
			<span class="hljs-keyword">return</span>  <span class="hljs-number">1</span>;
		<span class="hljs-keyword">case</span> <span class="hljs-string">'-'</span>:
			<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
		<span class="hljs-keyword">case</span> <span class="hljs-string">'*'</span>:
			<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
		<span class="hljs-keyword">case</span> <span class="hljs-string">'/'</span>:
			<span class="hljs-keyword">if</span> (right != <span class="hljs-number">0</span>)
				<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
			<span class="hljs-keyword">else</span>
			{
				<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
			}
	}
	<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
}

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">PrintMenu</span><span class="hljs-params">()</span>
</span>{
	<span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n"</span>);
	<span class="hljs-built_in">printf</span>(<span class="hljs-string">"        ******************************************\n"</span>);
	<span class="hljs-built_in">printf</span>(<span class="hljs-string">"        *************** 实数范围内 ***************\n"</span>);
	<span class="hljs-built_in">printf</span>(<span class="hljs-string">"        *************** 表达式求值 ***************\n"</span>);
	<span class="hljs-built_in">printf</span>(<span class="hljs-string">"        ******************************************\n"</span>);
	<span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n"</span>);
}

<span class="hljs-function"><span class="hljs-keyword">float</span> <span class="hljs-title">CtoN</span><span class="hljs-params">(<span class="hljs-keyword">char</span> c)</span>
</span>{
	<span class="hljs-keyword">if</span> (IsNum(c))
		<span class="hljs-keyword">return</span> <span class="hljs-keyword">float</span>(c - <span class="hljs-string">'0'</span>);
	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
	PrintMenu();
	<span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)
	{
		NumLinkStack Num;
		LinkStack Oprt;
		InitLinkStack2(&amp;Num);
		InitLinkStack(&amp;Oprt);
		PushLinkStack(&amp;Oprt, <span class="hljs-string">'#'</span>);
		<span class="hljs-built_in">printf</span>(<span class="hljs-string">"	请输入运算表达式，以'#'结束！\n\n"</span>);
		<span class="hljs-built_in">printf</span>(<span class="hljs-string">"	"</span>);
		<span class="hljs-keyword">char</span> Expression[<span class="hljs-number">100</span>];
		<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%s"</span>, Expression);
		<span class="hljs-built_in">printf</span>(<span class="hljs-string">"    \n"</span>);
		<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>;
		<span class="hljs-keyword">int</span> pan = <span class="hljs-number">1</span>;
		<span class="hljs-keyword">while</span> ( pan &amp;&amp;(Expression[j] != <span class="hljs-string">'#'</span> || GetLinkStackTop(Oprt) != <span class="hljs-string">'#'</span>)) {

			<span class="hljs-keyword">if</span> (!IsOPRT(Expression[j])) {
				<span class="hljs-keyword">float</span> sumIn = <span class="hljs-number">0</span>;
				<span class="hljs-keyword">float</span> sumDe = <span class="hljs-number">0</span>;
				<span class="hljs-keyword">float</span> temp = <span class="hljs-number">1</span>;
			
				<span class="hljs-keyword">do</span> {
					sumIn *= <span class="hljs-number">10</span>;
					sumIn += CtoN(Expression[j]);
					j++;
				} <span class="hljs-keyword">while</span> (IsNum(Expression[j]));

				<span class="hljs-keyword">if</span> (Expression[j] == <span class="hljs-string">'.'</span>) {
					j++;
					<span class="hljs-keyword">float</span> power = <span class="hljs-number">1</span>;
					<span class="hljs-keyword">do</span> {
						power /= <span class="hljs-number">10</span>;
						sumDe += power * CtoN(Expression[j]);
						j++;
					} <span class="hljs-keyword">while</span> (IsNum(Expression[j]));
				}
				PushLinkStack2(&amp;Num, (<span class="hljs-keyword">float</span>)(sumIn + sumDe));
				<span class="hljs-built_in">printf</span>(<span class="hljs-string">"	运算符栈："</span>);
				TraversLinkStack(Oprt);
				<span class="hljs-built_in">printf</span>(<span class="hljs-string">" "</span>);
				<span class="hljs-built_in">printf</span>(<span class="hljs-string">"		运算数栈："</span>);
				TraversLinkStack2(Num); 
				<span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n"</span>);
			}
			<span class="hljs-keyword">else</span> {
				<span class="hljs-keyword">switch</span> (Prior(Oprt-&gt;data, Expression[j]))
				{
					<span class="hljs-keyword">case</span> <span class="hljs-string">'&lt;'</span>:
						PushLinkStack(&amp;Oprt, Expression[j]);
						<span class="hljs-built_in">printf</span>(<span class="hljs-string">"	运算符栈："</span>);
						TraversLinkStack(Oprt);
						<span class="hljs-built_in">printf</span>(<span class="hljs-string">" "</span>);
						<span class="hljs-built_in">printf</span>(<span class="hljs-string">"		运算数栈："</span>);
						TraversLinkStack2(Num); 
						<span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n"</span>);
						<span class="hljs-keyword">break</span>;
					<span class="hljs-keyword">case</span> <span class="hljs-string">'='</span>:
						PopLinkStack(&amp;Oprt);
						<span class="hljs-built_in">printf</span>(<span class="hljs-string">"	运算符栈："</span>);
						TraversLinkStack(Oprt);
						<span class="hljs-built_in">printf</span>(<span class="hljs-string">" "</span>);
						<span class="hljs-built_in">printf</span>(<span class="hljs-string">"		运算数栈："</span>);
						TraversLinkStack2(Num); 
						<span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n"</span>);
						<span class="hljs-keyword">break</span>;
					<span class="hljs-keyword">case</span> <span class="hljs-string">'&gt;'</span>:
						<span class="hljs-keyword">char</span> Op = GetLinkStackTop(Oprt);
						PopLinkStack(&amp;Oprt);
						<span class="hljs-keyword">float</span> rigth = GetLinkStackTop2(Num);
						PopLinkStack2(&amp;Num);
						<span class="hljs-keyword">float</span> left = GetLinkStackTop2(Num);
						PopLinkStack2(&amp;Num);
						pan = CCLT2(left, rigth, Op);
						PushLinkStack2(&amp;Num, CCLT(left, rigth, Op));
						<span class="hljs-keyword">if</span> (!pan) {
							<span class="hljs-built_in">printf</span>(<span class="hljs-string">"输入不合法！\n"</span>);
							PushLinkStack2(&amp;Num, <span class="hljs-number">0.00000</span>);
						}
						<span class="hljs-built_in">printf</span>(<span class="hljs-string">"	运算符栈："</span>);
						TraversLinkStack(Oprt);
						<span class="hljs-built_in">printf</span>(<span class="hljs-string">" "</span>);
						<span class="hljs-built_in">printf</span>(<span class="hljs-string">"		运算数栈："</span>);
						TraversLinkStack2(Num); 
						<span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n"</span>);
						j--;
						<span class="hljs-keyword">break</span>;
				}
				j++;
			}
		<span class="hljs-comment">/*	if (j &gt;= strlen(Expression))
				break;*/</span>
		}
		<span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n"</span>);
		<span class="hljs-built_in">printf</span>(<span class="hljs-string">"	%s结果为：%.2f\n\n"</span>, Expression, GetLinkStackTop2(Num));
		
		<span class="hljs-built_in">printf</span>(<span class="hljs-string">"	继续吗？(1/0)\n"</span>);
		<span class="hljs-keyword">int</span> YN;
		<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>, &amp;YN);
		<span class="hljs-keyword">if</span> (YN == <span class="hljs-number">1</span>)
			<span class="hljs-keyword">continue</span>;
		<span class="hljs-keyword">if</span> (YN == <span class="hljs-number">0</span>)
			<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
	}
}
</div></code></pre>
<h3 id="93-a-name-1a%E9%98%9F%E5%88%97%E7%9A%84%E5%BA%94%E7%94%A8">9.3. <a name='-1'></a>队列的应用</h3>
<h4 id="931-a-name-1a%E8%88%9E%E4%BC%B4%E9%97%AE%E9%A2%98">9.3.1. <a name='-1'></a>舞伴问题</h4>
<h4 id="932-a-name-1a%E6%8E%92%E9%98%9F%E6%A8%A1%E6%8B%9F%E9%97%AE%E9%A2%98">9.3.2. <a name='-1'></a>排队模拟问题</h4>
<h4 id="933-a-name-1a%E6%B1%82%E4%BA%8C%E9%A1%B9%E5%BC%8F%E7%B3%BB%E6%95%B0">9.3.3. <a name='-1'></a>求二项式系数</h4>
<h4 id="934-a-name-1a%E6%97%A0%E5%86%B2%E7%AA%81%E5%AD%90%E9%9B%86%E7%9A%84%E5%88%92%E5%88%86">9.3.4. <a name='-1'></a>无冲突子集的划分</h4>
<pre class="hljs"><code><div><span class="hljs-comment">//创建哈夫曼树的算法</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">huff_tree</span><span class="hljs-params">(HufTree ht, <span class="hljs-keyword">int</span> w[], <span class="hljs-keyword">int</span> n)</span>
</span>{
	<span class="hljs-keyword">int</span> i, s1, s2;
	<span class="hljs-keyword">for</span> (i = <span class="hljs-number">1</span>; i &lt; <span class="hljs-number">2</span> * n; i++)
	{
		<span class="hljs-keyword">if</span> (i &gt;= <span class="hljs-number">1</span> &amp;&amp; i &lt;= n)ht[i].weight = w[i - <span class="hljs-number">1</span>];
		<span class="hljs-keyword">else</span> ht[i].weight = <span class="hljs-number">0</span>;
		ht[i].parent = <span class="hljs-number">0</span>;
		ht[i].lch = <span class="hljs-number">0</span>;
		ht[i].rch = <span class="hljs-number">0</span>;
	}
	<span class="hljs-keyword">for</span> (i = n + <span class="hljs-number">1</span>; i &lt; <span class="hljs-number">2</span> * n; i++)
	{
		select(ht, n, &amp;s1, &amp;s2);
		ht[i].weight = ht[s1].weight + ht[s2].weight;
		ht[i].lch = s1; ht[i].rch = s2;
		ht[s1].parent = i; ht[s2].parent = i;
	}
}

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">select</span><span class="hljs-params">(HufTree ht, <span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span>* s1, <span class="hljs-keyword">int</span>* s2)</span>
</span>{
	<span class="hljs-keyword">int</span> i, min;
	<span class="hljs-keyword">for</span> (min = <span class="hljs-number">100</span>, i = <span class="hljs-number">1</span>; i &lt; <span class="hljs-number">2</span> * n; i++)
	{
		<span class="hljs-keyword">if</span> (ht[i].parent == <span class="hljs-number">0</span> &amp;&amp; ht[i].weight != <span class="hljs-number">0</span> &amp;&amp; ht[i].weight &lt; min)
		{
			min = ht[i].weight;
			*s1 = i;
		}
	}<span class="hljs-comment">//for</span>
	<span class="hljs-keyword">for</span> (min = <span class="hljs-number">100</span>, i = <span class="hljs-number">1</span>; i &lt; <span class="hljs-number">2</span> * n; i++)
	{
		<span class="hljs-keyword">if</span> (ht[i].parent == <span class="hljs-number">0</span> &amp;&amp; ht[i].weight != <span class="hljs-number">0</span> &amp;&amp; i != *s1 &amp;&amp; ht[i].weight &lt; min)
		{
		    min = ht[i].weight;
			*s2 = i;
		}
	}<span class="hljs-comment">//for</span>
}

<span class="hljs-comment">//哈夫曼树类型</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> n</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> m 2*N-1</span>
<span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span>
{</span>
	<span class="hljs-keyword">char</span> data;
	<span class="hljs-keyword">int</span> weight;
	<span class="hljs-keyword">int</span> parent, lch, rch;
}HufNodeType, *HufTree;

<span class="hljs-comment">//哈夫曼编码的创建</span>
<span class="hljs-function"><span class="hljs-keyword">char</span> ** <span class="hljs-title">huf_code</span><span class="hljs-params">(HufTree ht,<span class="hljs-keyword">int</span> n)</span>
</span>{
	<span class="hljs-keyword">char</span> *cd, **hcd;
	<span class="hljs-keyword">int</span> i, start, c, f;
	hcd = (<span class="hljs-keyword">char</span>**)<span class="hljs-built_in">malloc</span>((n+<span class="hljs-number">1</span>)*<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">char</span>*));
	cd = (<span class="hljs-keyword">char</span>*)<span class="hljs-built_in">malloc</span>(n*<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">char</span>));
	<span class="hljs-keyword">for</span>(i = <span class="hljs-number">1</span>; i&lt;=n; i++)
	{
		cd[n<span class="hljs-number">-1</span>]=<span class="hljs-string">'\0'</span>;
		start = n<span class="hljs-number">-1</span>;
		c = i;
		f = ht[c].parent;
		<span class="hljs-keyword">while</span> (f)
		{
			<span class="hljs-keyword">if</span> (ht[f].lch == c)
			cd[--start] = <span class="hljs-string">'0'</span>;
			<span class="hljs-keyword">else</span>
			cd[--start] = <span class="hljs-string">'1'</span>;
			c = f;
			f = ht[f],parent;
		}
		hcd[i] = (<span class="hljs-keyword">char</span>*)<span class="hljs-built_in">malloc</span>((n-start)*<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">char</span>));
		<span class="hljs-built_in">strcpy</span>(hud[i], &amp;cd[start]);
	}
	<span class="hljs-keyword">return</span> hcd;
}
</div></code></pre>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">InsertTree</span><span class="hljs-params">(CSTree* T,<span class="hljs-keyword">char</span> fa[], <span class="hljs-keyword">char</span> ch[])</span></span>{
	CSTree p=<span class="hljs-literal">NULL</span>,q,s;
	PreSearch(*T, fa, &amp;p);
	<span class="hljs-keyword">if</span>(p){
		s=(CSTree)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(CSNode));
		<span class="hljs-built_in">strcpy</span>(s-&gt;data,ch);
		s-&gt;firstchild=s-&gt;nextsibling= <span class="hljs-literal">NULL</span>;
		<span class="hljs-keyword">if</span>(!p-&gt;firstchild)
		    p-&gt;firstchild=s;
		<span class="hljs-keyword">else</span>{
			q=p-&gt;firstchild;
			<span class="hljs-keyword">while</span>(q-&gt;nextsibling)
				q=q-&gt;nextsibling;
				q-&gt;nextsibling=s;
		}
		<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
	}
	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; 
}

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">DeleteTree</span><span class="hljs-params">(CSTree* T,CSTree Fa, <span class="hljs-keyword">char</span> ch[], <span class="hljs-keyword">int</span> *<span class="hljs-built_in">find</span>)</span></span>{
	CSTree p;
	<span class="hljs-keyword">if</span>(*T){
		<span class="hljs-keyword">if</span>(<span class="hljs-built_in">strcmp</span>((*T)-&gt;data,ch)==<span class="hljs-number">0</span>){
			p=*T;
			<span class="hljs-keyword">if</span>(Fa!=<span class="hljs-literal">NULL</span>){
				<span class="hljs-keyword">if</span>(Fa-&gt;nextsibling==*T)
					Fa-&gt;nextsibling=(*T)-&gt;nextsibling;
				<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(Fa-&gt;firstchild==*T)
					Fa-&gt;firstchild=(*T)-&gt;nextsibling;	 
			}
			p-&gt;nextsibling=<span class="hljs-literal">NULL</span>;
			PostDelete(p);
			<span class="hljs-keyword">if</span>(Fa==<span class="hljs-literal">NULL</span>)
				*T=<span class="hljs-literal">NULL</span>;
			*<span class="hljs-built_in">find</span>=<span class="hljs-number">1</span>;
		}
		<span class="hljs-keyword">if</span>(*<span class="hljs-built_in">find</span>==<span class="hljs-number">0</span>)DeleteTree(&amp;(*T)-&gt;firstchild, *T, ch, <span class="hljs-built_in">find</span>);
		<span class="hljs-keyword">if</span>(*<span class="hljs-built_in">find</span>==<span class="hljs-number">0</span>)DeleteTree(&amp;(*T)-&gt;nextsibling, *T, ch, <span class="hljs-built_in">find</span>);
	}
}
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">PostDelete</span><span class="hljs-params">(CSTree T)</span></span>{
	<span class="hljs-keyword">if</span>(T){
		PostDelete(T-&gt;firstchild);
		PostDelete(T-&gt;nextsibling);
		<span class="hljs-built_in">free</span>(T);
	}
}
</div></code></pre>

</body>
</html>
